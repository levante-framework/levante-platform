"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoarFirekit = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const get_1 = __importDefault(require("lodash/get"));
const set_1 = __importDefault(require("lodash/set"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const nth_1 = __importDefault(require("lodash/nth"));
const union_1 = __importDefault(require("lodash/union"));
const auth_1 = require("firebase/auth");
const firestore_1 = require("firebase/firestore");
const functions_1 = require("firebase/functions");
const auth_2 = require("./auth");
const util_1 = require("./firestore/util");
const interfaces_1 = require("./interfaces");
const appkit_1 = require("./firestore/app/appkit");
const query_assessment_1 = require("./firestore/query-assessment");
const task_1 = require("./firestore/app/task");
var AuthProviderType;
(function (AuthProviderType) {
    AuthProviderType["CLEVER"] = "clever";
    AuthProviderType["CLASSLINK"] = "classlink";
    AuthProviderType["GOOGLE"] = "google";
    AuthProviderType["EMAIL"] = "email";
    AuthProviderType["USERNAME"] = "username";
    AuthProviderType["PASSWORD"] = "password";
})(AuthProviderType || (AuthProviderType = {}));
class RoarFirekit {
    /**
     * Create a RoarFirekit. This expects an object with keys `roarConfig`,
     * where `roarConfig` is a [[RoarConfig]] object.
     * @param {{roarConfig: RoarConfig }=} destructuredParam
     *     roarConfig: The ROAR firebase config object
     */
    constructor({ roarConfig, verboseLogging = false, authPersistence = util_1.AuthPersistence.session, markRawConfig = {}, listenerUpdateCallback, }) {
        this.roarConfig = roarConfig;
        this._verboseLogging = verboseLogging;
        this._authPersistence = authPersistence;
        this._markRawConfig = markRawConfig;
        this._initialized = false;
        this._idTokens = {};
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.listenerUpdateCallback = listenerUpdateCallback !== null && listenerUpdateCallback !== void 0 ? listenerUpdateCallback : (() => { });
    }
    _getProviderIds() {
        return Object.assign(Object.assign({}, auth_1.ProviderId), { CLEVER: 'oidc.clever', CLASSLINK: 'oidc.classlink', ROAR_ADMIN_PROJECT: `oidc.${this.roarConfig.admin.projectId}` });
    }
    _scrubAuthProperties() {
        this.userData = undefined;
        this.roarAppUserInfo = undefined;
        this._adminOrgs = undefined;
        this._superAdmin = undefined;
        this.currentAssignments = undefined;
        this.oAuthAccessToken = undefined;
        this._adminClaimsListener = undefined;
        this._adminTokenListener = undefined;
        this._appTokenListener = undefined;
        this._idTokens = {};
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.app = yield (0, util_1.initializeFirebaseProject)(this.roarConfig.app, 'app', this._authPersistence, this._markRawConfig);
            this.admin = yield (0, util_1.initializeFirebaseProject)(this.roarConfig.admin, 'admin', this._authPersistence, this._markRawConfig);
            this._initialized = true;
            (0, auth_1.onAuthStateChanged)(this.admin.auth, (user) => __awaiter(this, void 0, void 0, function* () {
                this.verboseLog('onAuthStateChanged triggered for admin auth');
                if (this.admin) {
                    if (user) {
                        this.verboseLog('admin firebase instance and user are defined');
                        this.admin.user = user;
                        this._adminClaimsListener = this._listenToClaims(this.admin);
                        this.verboseLog('adminClaimsListener instance set up using listenToClaims');
                        this._adminTokenListener = this._listenToTokenChange(this.admin, 'admin');
                        this.verboseLog('adminTokenListener instance set up using listenToClaims');
                        this.verboseLog('[admin] Attempting to fire user.getIdToken(), existing token is', this._idTokens.admin);
                        user.getIdToken().then((idToken) => {
                            this.verboseLog('in .then() for user.getIdToken() with new token', idToken);
                            this._idTokens.admin = idToken;
                            this.verboseLog(`Updated internal admin token to ${idToken}`);
                        });
                        this._roarUid = yield this.getRoarUid();
                    }
                    else {
                        this.verboseLog('User for admin is undefined.');
                        this.admin.user = undefined;
                        this._roarUid = undefined;
                    }
                }
                this.verboseLog('[admin] Call this.listenerUpdateCallback()');
                this.listenerUpdateCallback();
            }));
            (0, auth_1.onAuthStateChanged)(this.app.auth, (user) => {
                this.verboseLog('onAuthStateChanged triggered for assessment auth');
                if (this.app) {
                    if (user) {
                        this.verboseLog('assessment firebase instance and user are defiend');
                        this.app.user = user;
                        this._appTokenListener = this._listenToTokenChange(this.app, 'app');
                        this.verboseLog('appTokenListener instance set up using listenToTokenChange');
                        this.verboseLog('[app] Attempting to fire user.getIdToken() from app , existing token is', this._idTokens.app);
                        user.getIdToken().then((idToken) => {
                            this.verboseLog('in .then() for user.getItToken() with new token', idToken);
                            this._idTokens.app = idToken;
                            this.verboseLog('Updated internal app token to', idToken);
                        });
                    }
                    else {
                        this.verboseLog('User for app is undefined');
                        this.app.user = undefined;
                    }
                }
                this.verboseLog('[app] Call this.listenerUpdateCallback()');
                this.listenerUpdateCallback();
            });
            return this;
        });
    }
    verboseLog(...logStatement) {
        if (this._verboseLogging) {
            console.log('[RoarFirekit] ', ...logStatement);
        }
        else
            return;
    }
    get initialized() {
        return this._initialized;
    }
    /**
     * Verifies if the RoarFirekit instance has been initialized.
     *
     * This method checks if the RoarFirekit instance has been initialized by checking the `_initialized` property.
     * If the instance has not been initialized, it throws an error with a descriptive message.
     *
     * @throws {Error} - If the RoarFirekit instance has not been initialized.
     */
    _verifyInit() {
        if (!this._initialized) {
            throw new Error('RoarFirekit has not been initialized. Use the `init` method.');
        }
    }
    //           +--------------------------------+
    // ----------|  Begin Authentication Methods  |----------
    //           +--------------------------------+
    /**
     * Verifies if the user is authenticated in both the admin and app Firebase projects.
     *
     * This method checks if the user is authenticated in both the admin and app Firebase projects.
     * It returns a boolean value indicating whether the user is authenticated or not.
     *
     * @returns {boolean} - A boolean value indicating whether the user is authenticated or not.
     * @throws {Error} - If the Firebase projects are not initialized.
     */
    _isAuthenticated() {
        this._verifyInit();
        return !(this.admin.user === undefined || this.app.user === undefined);
    }
    /**
     * Checks if the current user is an administrator.
     *
     * This method checks if the current user has administrative privileges in the application.
     * It returns a boolean value indicating whether the user is an administrator or not.
     *
     * @returns {boolean} - A boolean value indicating whether the user is an administrator or not.
     *
     * @remarks
     * - If the user is a super administrator, the method returns `true`.
     * - If the user has no adminOrgs, the method returns `false`.
     * - If the application is using the Levante platform, the method checks if the user is an administrator specifically for the Levante platform.
     * - If the adminOrgs are empty, the method returns `false`.
     * - If none of the above conditions are met, the method returns `true`.
     */
    isAdmin() {
        if (this.superAdmin)
            return true;
        if (this._adminOrgs === undefined)
            return false;
        if (this.roarConfig.admin.projectId.includes('levante') || this.roarConfig.app.projectId.includes('levante')) {
            return this._admin;
        }
        if ((0, isEmpty_1.default)((0, union_1.default)(...Object.values(this._adminOrgs))))
            return false;
        return true;
    }
    _verifyAuthentication() {
        this._verifyInit();
        if (!this._isAuthenticated()) {
            throw new Error('User is not authenticated.');
        }
    }
    /**
     * Verifies if the user is authenticated in the application.
     *
     * This method checks if the user is authenticated in both the admin and assessment Firebase projects.
     * If the user is authenticated in both projects, the method returns without throwing an error.
     * If the user is not authenticated in either project, the method throws an error with the message 'User is not authenticated.'
     *
     * @throws {Error} - Throws an error if the user is not authenticated.
     */
    _verifyAdmin() {
        this._verifyAuthentication();
        if (!this.isAdmin()) {
            throw new Error('User is not an administrator.');
        }
    }
    /**
     * Listens for changes in the user's custom claims and updates the internal state accordingly.
     *
     * This method sets up a snapshot listener on the user's custom claims document in the admin Firebase project.
     * When the listener detects changes in the claims, it updates the internal state of the `RoarAuth` instance.
     * It also refreshes the user's ID token if the claims have been updated.
     *
     * @param {FirebaseFirestore.Firestore} firekit.db - The Firestore database instance for the admin Firebase project.
     * @param {FirebaseAuth.User} firekit.user - The user object for the admin Firebase project.
     * @returns {FirebaseFirestore.Unsubscribe} - The unsubscribe function to stop listening for changes in the user's custom claims.
     * @throws {FirebaseError} - If there is an error setting up the snapshot listener.
     */
    _listenToClaims(firekit) {
        this.verboseLog('entry point to listenToClaims');
        this._verifyInit();
        if (firekit.user) {
            this.verboseLog('firekit.user is defined');
            let unsubscribe;
            this.verboseLog('About to try setting up the claims listener');
            try {
                this.verboseLog('Beginning onSnapshot definition');
                unsubscribe = (0, firestore_1.onSnapshot)((0, firestore_1.doc)(firekit.db, 'userClaims', firekit.user.uid), (doc) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c;
                    this.verboseLog('In onSnapshot call for listenToClaims');
                    const data = doc.data();
                    this._adminOrgs = (_a = data === null || data === void 0 ? void 0 : data.claims) === null || _a === void 0 ? void 0 : _a.adminOrgs;
                    this._superAdmin = (_b = data === null || data === void 0 ? void 0 : data.claims) === null || _b === void 0 ? void 0 : _b.super_admin;
                    if (this.roarConfig.admin.projectId.includes('levante') ||
                        this.roarConfig.app.projectId.includes('levante')) {
                        this._admin = ((_c = data === null || data === void 0 ? void 0 : data.claims) === null || _c === void 0 ? void 0 : _c.admin) || false;
                    }
                    this.verboseLog('data, adminOrgs, superAdmin are retrieved from doc.data()');
                    this.verboseLog('about to check for existance of data.lastUpdated');
                    if (data === null || data === void 0 ? void 0 : data.lastUpdated) {
                        this.verboseLog('lastUpdate exists.');
                        const lastUpdated = new Date(data.lastUpdated);
                        this.verboseLog('Checking for firekit.claimsLastUpdated existance or outdated (< lastUpdated from retrieved data)');
                        if (!firekit.claimsLastUpdated || lastUpdated > firekit.claimsLastUpdated) {
                            this.verboseLog("Firekit's last updated either does not exist or is outdated. Await getIdToken and update firekit's claimsLastUpdated field.");
                            // Update the user's ID token and refresh claimsLastUpdated.
                            yield (0, auth_1.getIdToken)(firekit.user, true);
                            firekit.claimsLastUpdated = lastUpdated;
                        }
                    }
                    this.verboseLog('Call listenerUpdateCallback from listenToClaims');
                    this.listenerUpdateCallback();
                }), (error) => {
                    throw error;
                });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                this.verboseLog('Attempt to set up claims listener failed. Error is', error);
                if (error.code !== 'permission-denied') {
                    throw error;
                }
            }
            return unsubscribe;
        }
    }
    /**
     * Forces a refresh of the ID token for the admin and app Firebase users.
     *
     * This method retrieves the ID tokens for the admin and app Firebase users
     * and refreshes them. It ensures that the tokens are up-to-date and valid.
     *
     * @returns {Promise<void>} - A promise that resolves when the ID tokens are refreshed successfully.
     * @throws {FirebaseError} - If an error occurs while refreshing the ID tokens.
     */
    forceIdTokenRefresh() {
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point for forceIdTokenRefresh');
            this._verifyAuthentication();
            yield (0, auth_1.getIdToken)(this.admin.user, true);
            yield (0, auth_1.getIdToken)(this.app.user, true);
        });
    }
    /**
     * Listens for changes in the ID token of the specified Firebase project and updates the corresponding token.
     *
     * This method sets up a listener to track changes in the ID token of the specified Firebase project (either admin or app).
     * When the ID token changes, it retrieves the new ID token and updates the corresponding token in the `_idTokens` object.
     * It also calls the `listenerUpdateCallback` function to notify any listeners of the token update.
     *
     * @param {FirebaseProject} firekit - The Firebase project to listen for token changes.
     * @param {'admin' | 'app'} _type - The type of Firebase project ('admin' or 'app').
     * @returns {firebase.Unsubscribe} - A function to unsubscribe from the listener.
     * @private
     */
    _listenToTokenChange(firekit, _type) {
        this.verboseLog('Entry point for listenToTokenChange, called with', _type);
        this._verifyInit();
        this.verboseLog('Checking for existance of tokenListener with type', _type);
        if ((!this._adminTokenListener && _type === 'admin') || (!this._appTokenListener && _type === 'app')) {
            this.verboseLog('Token listener does not exist, create now.');
            return (0, auth_1.onIdTokenChanged)(firekit.auth, (user) => __awaiter(this, void 0, void 0, function* () {
                this.verboseLog('onIdTokenChanged body');
                if (user) {
                    this.verboseLog('user exists, await user.getIdTokenResult(false)');
                    const idTokenResult = yield user.getIdTokenResult(false);
                    this.verboseLog('Returned with token', idTokenResult);
                    if (_type === 'admin') {
                        this.verboseLog('Type is admin, set idTokenRecieved flag');
                        this._idTokenReceived = true;
                    }
                    this.verboseLog(`Setting idTokens.${_type} to token`, idTokenResult.token);
                    this._idTokens[_type] = idTokenResult.token;
                }
                this.verboseLog('Calling listenerUpdateCallback from listenToTokenChange', _type);
                this.listenerUpdateCallback();
            }));
        }
        else if (_type === 'admin') {
            this.verboseLog('Type is admin, invoking _adminTokenListener');
            return this._adminTokenListener;
        }
        this.verboseLog('Type is app, invoking _appTokenListener');
        return this._appTokenListener;
    }
    /**
     * Sets the UID custom claims for the admin and assessment UIDs in the Firebase projects.
     *
     * This method is responsible for associating the admin and assessment UIDs in the Firebase projects.
     * It calls the setUidClaims cloud function in the admin Firebase project.
     * If the cloud function execution is successful, it refreshes the ID tokens for both projects.
     *
     * @returns {Promise<any>} - A promise that resolves with the result of the setUidClaims cloud function execution.
     * @param {object} input - An object containing the required parameters
     * @param {string} input.identityProviderId - The identity provider ID for the user (optional).
     * @param {AuthProviderType} input.identityProviderType - The type of the identity provider (optional).
     * @throws {Error} - If the setUidClaims cloud function execution fails, an Error is thrown.
     */
    _setUidCustomClaims({ identityProviderId = undefined, identityProviderType = undefined, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point to setUidCustomClaims');
            this._verifyAuthentication();
            this.verboseLog('Calling cloud function for setUidClaims');
            const setUidClaims = (0, functions_1.httpsCallable)(this.admin.functions, 'setUidClaims');
            const result = yield setUidClaims({
                assessmentUid: this.app.user.uid,
                identityProviderId,
                identityProviderType,
            });
            this.verboseLog('setUidClaims returned with result', result);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if ((0, get_1.default)(result.data, 'status') !== 'ok') {
                this.verboseLog('Error in calling setUidClaims cloud function', result.data);
                throw new Error('Failed to set UIDs in the admin and assessment Firebase projects.');
            }
            yield this.forceIdTokenRefresh();
            this.verboseLog('Returning result from setUidCustomClaims', result);
            return result;
        });
    }
    /**
     * Synchronizes Education Single Sign-On (SSO) user data.
     *
     * This method is responsible for synchronizing user data between the
     * Education SSO platform (Clever or ClassLink) and the ROAR (Readiness
     * Outcomes Assessment Reporting) system. It uses the provided OAuth
     * access token to authenticate with the Education SSO platform and
     * calls the appropriate cloud function to sync the user data.
     *
     * @param {string} oAuthAccessToken - The OAuth access token obtained from the Education SSO platform.
     * @param {AuthProviderType} authProvider - The type of the Education SSO platform (Clever or ClassLink).
     * @throws {Error} - If the required parameters are missing or invalid.
     * @returns {Promise<void>} - A promise that resolves when the synchronization is complete.
     */
    _syncEduSSOUser(oAuthAccessToken, authProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point for syncEduSSOUser');
            if (authProvider === AuthProviderType.CLASSLINK) {
                this.verboseLog('Calling syncEduSSOUser cloud function [ClassLink]');
                if (oAuthAccessToken === undefined) {
                    this.verboseLog('Not OAuth token provided.');
                    throw new Error('No OAuth access token provided.');
                }
                this._verifyAuthentication();
                this.verboseLog('Calling syncClassLinkUser cloud function');
                const syncClassLinkUser = (0, functions_1.httpsCallable)(this.admin.functions, 'syncClassLinkUser');
                const adminResult = yield syncClassLinkUser({
                    assessmentUid: this.app.user.uid,
                    accessToken: oAuthAccessToken,
                });
                this.verboseLog('syncClassLinkUser cloud function returned with result', adminResult);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if ((0, get_1.default)(adminResult.data, 'status') !== 'ok') {
                    this.verboseLog('There was an error with the cloud function syncClassLinkUser cloud function', adminResult.data);
                    throw new Error('Failed to sync ClassLink and ROAR data.');
                }
            }
        });
    }
    /**
     * Checks if the given username is available for a new user registration.
     *
     * This method verifies if the given username is not already associated with
     * a user in the admin Firebase project. It returns a promise that resolves with
     * a boolean value indicating whether the username is available or not.
     *
     * @param {string} username - The username to check.
     * @returns {Promise<boolean>} - A promise that resolves with a boolean value indicating whether the username is available or not.
     * @throws {FirebaseError} - If an error occurs while checking the username availability.
     */
    isUsernameAvailable(username) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_2.isUsernameAvailable)(this.admin.auth, username);
        });
    }
    /**
     * Checks if the given email address is available for a new user registration.
     *
     * This method verifies if the given email address is not already associated with
     * a user in the admin Firebase project. It returns a promise that resolves with
     * a boolean value indicating whether the email address is available or not.
     *
     * @param {string} email - The email address to check.
     * @returns {Promise<boolean>} - A promise that resolves with a boolean value indicating whether the email address is available or not.
     * @throws {FirebaseError} - If an error occurs while checking the email availability.
     */
    isEmailAvailable(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_2.isEmailAvailable)(this.admin.auth, email);
        });
    }
    /**
     * Fetches the list of providers associated with the given user's email address.
     *
     * This method retrieves the list of providers associated with the given user's email address
     * from the admin Firebase project. The list of providers includes the authentication methods
     * that the user has used to sign in with their email address.
     *
     * @param {string} email - The email address of the user.
     * @returns {Promise<string[]>} - A promise that resolves with an array of provider IDs.
     * @throws {FirebaseError} - If an error occurs while fetching the email authentication methods.
     */
    fetchEmailAuthMethods(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_2.fetchEmailAuthMethods)(this.admin.auth, email);
        });
    }
    /**
     * Checks if the given email address belongs to a user in the ROAR authentication system.
     *
     * This method checks if the given email address is associated with a user in the admin Firebase project.
     * It returns a boolean value indicating whether the email address belongs to a ROAR user or not.
     *
     * @param {string} email - The email address to check.
     * @returns {boolean} - A boolean value indicating whether the email address belongs to a ROAR user or not.
     */
    isRoarAuthEmail(email) {
        this._verifyInit();
        return (0, auth_2.isRoarAuthEmail)(email);
    }
    /**
     * Registers a new user with the provided email and password.
     *
     * This method creates a new user in both the admin and assessment Firebase projects.
     * It first creates the user in the admin project and then in the assessment project.
     * After successful user creation, it sets the UID custom claims by calling the `_setUidCustomClaims` method.
     *
     * @param {object} params - The parameters for registering a new user.
     * @param {string} params.email - The email address of the new user.
     * @param {string} params.password - The password of the new user.
     * @returns {Promise<void>} - A promise that resolves when the user registration is complete.
     * @throws {AuthError} - If the user registration fails, the promise will be rejected with an AuthError.
     */
    registerWithEmailAndPassword({ email, password }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.createUserWithEmailAndPassword)(this.admin.auth, email, password)
                .catch((error) => {
                console.log('Error creating user', error);
                console.log(error.code);
                console.log(error.message);
                throw error;
            })
                .then(() => {
                this._identityProviderType = AuthProviderType.EMAIL;
                return (0, auth_1.createUserWithEmailAndPassword)(this.app.auth, email, password).then(() => {
                    return this._setUidCustomClaims();
                });
            });
        });
    }
    /**
     * Initiates a login process using an email and password.
     *
     * This method signs in the user with the provided email and password in both the admin and assessment Firebase projects.
     * It first signs in the user in the admin project and then in the assessment project. After successful sign-in, it sets
     * the UID custom claims by calling the `_setUidCustomClaims` method.
     *
     * @param {object} params - The parameters for initiating the login process.
     * @param {string} params.email - The email address of the user.
     * @param {string} params.password - The password of the user.
     * @returns {Promise<void>} - A promise that resolves when the login process is complete.
     * @throws {AuthError} - If the login process fails, the promise will be rejected with an AuthError.
     */
    logInWithEmailAndPassword({ email, password }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.signInWithEmailAndPassword)(this.admin.auth, email, password)
                .then((adminUserCredential) => __awaiter(this, void 0, void 0, function* () {
                this._identityProviderType = AuthProviderType.EMAIL;
                const roarProviderIds = this._getProviderIds();
                const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                const roarAdminIdToken = yield (0, auth_1.getIdToken)(adminUserCredential.user);
                const roarAdminCredential = roarAdminProvider.credential({
                    idToken: roarAdminIdToken,
                });
                return (0, auth_1.signInWithCredential)(this.app.auth, roarAdminCredential);
            }))
                .then(() => {
                return this._setUidCustomClaims();
            })
                .catch((error) => {
                console.error('Error signing in', error);
                throw error;
            });
        });
    }
    /**
     * Initiates a login process using a username and password.
     *
     * This method constructs an email address from the provided username using the
     * roarEmail() function and then calls the logInWithEmailAndPassword() method with
     * the constructed email address and the provided password.
     *
     * @param {object} params - The parameters for initiating the login process.
     * @param {string} params.username - The username to use for the login process.
     * @param {string} params.password - The password to use for the login process.
     * @returns {Promise<void>} - A promise that resolves when the login process is complete.
     */
    logInWithUsernameAndPassword({ username, password }) {
        return __awaiter(this, void 0, void 0, function* () {
            const email = (0, auth_2.roarEmail)(username);
            return this.logInWithEmailAndPassword({ email, password });
        });
    }
    /**
     * Link the current user with email and password credentials.
     *
     * This method creates a credential using the provided email and password, and then links the user's account with the current user in both the admin and app Firebase projects.
     *
     * @param {string} email - The email of the user to link.
     * @param {string} password - The password of the user to link.
     *
     * @returns {Promise<void>} - A promise that resolves when the user is successfully linked with the specified authentication provider.
     */
    linkEmailPasswordWithAuthProvider(email, password) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const emailCredential = auth_1.EmailAuthProvider.credential(email, password);
            return (0, auth_1.linkWithCredential)(this.admin.auth.currentUser, emailCredential).then(() => {
                return (0, auth_1.linkWithCredential)(this.app.auth.currentUser, emailCredential);
            });
        });
    }
    /**
     * Initiates the login process with an email link.
     *
     * This method sends a sign-in link to the specified email address. The user
     * can click on the link to sign in to their account. The sign-in process is
     * handled in a separate browser window or tab.
     *
     * @param {object} params - The parameters for initiating the login process.
     * @param {string} params.email - The email address to send the sign-in link to.
     * @param {string} params.redirectUrl - The URL to redirect the user to after they click on the sign-in link.
     * @returns {Promise<void>} - A promise that resolves when the sign-in link is sent successfully.
     */
    initiateLoginWithEmailLink({ email, redirectUrl }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            const actionCodeSettings = {
                url: redirectUrl,
                handleCodeInApp: true,
            };
            return (0, auth_1.sendSignInLinkToEmail)(this.admin.auth, email, actionCodeSettings);
        });
    }
    /**
     * Check if the given email link is a sign-in with email link.
     *
     * This method checks if the given email link is a valid sign-in with email link
     * for the admin Firebase project. It returns a promise that resolves with a boolean
     * value indicating whether the email link is valid or not.
     *
     * @param {string} emailLink - The email link to check.
     * @returns {Promise<boolean>} - A promise that resolves with a boolean value indicating whether the email link is valid or not.
     */
    isSignInWithEmailLink(emailLink) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.isSignInWithEmailLink)(this.admin.auth, emailLink);
        });
    }
    signInWithEmailLink({ email, emailLink }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.signInWithEmailLink)(this.admin.auth, email, emailLink)
                .then((userCredential) => __awaiter(this, void 0, void 0, function* () {
                this._identityProviderType = AuthProviderType.EMAIL;
                const roarProviderIds = this._getProviderIds();
                const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                const roarAdminIdToken = yield (0, auth_1.getIdToken)(userCredential.user);
                const roarAdminCredential = roarAdminProvider.credential({
                    idToken: roarAdminIdToken,
                });
                return roarAdminCredential;
            }))
                .then((credential) => {
                if (credential) {
                    return (0, auth_1.signInWithCredential)(this.app.auth, credential);
                }
            })
                .then((credential) => {
                if (credential) {
                    return this._setUidCustomClaims();
                }
            });
        });
    }
    /**
     * Handle the sign-in process in a popup window.
     *
     * This method handles the sign-in process in a popup window from from an
     * external identity provider.  It retrieves the user's credentials from the
     * popup result and authenticates the user to the admin Firebase project
     * using these credentials.
     *
     * The identity provider token is generally mean to be one-time use only.
     * Because of this, the external identity provider's credential cannot be
     * reused in the assessment project. To authenticate into the assessment
     * project, we ask the admin Firebase project itself to mint a new credential
     * for the assessment project. Thus, the external identity providers are used
     * only in the admin Firebase project. And the admin Firebase project acts as
     * an "external" identity provider for the assessment project.
     *
     * Therefore, the workflow for this method is as follows:
     * 1. Authenticate into the external provider using a popup window.
     * 2. Retrieve the external identity provider's credential from the popup result.
     * 3. Authenticate into the admin Firebase project with this credential.
     * 4. Generate a new "external" credential from the admin Firebase project.
     * 5. Authenticate into the assessment Firebase project with the admin project's "external" credential.
     * 6. Set UID custom claims by calling setUidCustomClaims().
     * 7. Sync Clever/Classlink user data by calling syncEduSSOUser().
     *
     * @param {AuthProviderType} provider - The authentication provider to use. It can be one of the following:
     * - AuthProviderType.GOOGLE
     * - AuthProviderType.CLEVER
     * - AuthProviderType.CLASSLINK
     *
     * @returns {Promise<UserCredential | null>} - A promise that resolves with the user's credential or null.
     */
    signInWithPopup(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            const allowedProviders = [AuthProviderType.GOOGLE, AuthProviderType.CLEVER, AuthProviderType.CLASSLINK];
            let authProvider;
            if (provider === AuthProviderType.GOOGLE) {
                authProvider = new auth_1.GoogleAuthProvider();
            }
            else if (provider === AuthProviderType.CLEVER) {
                const roarProviderIds = this._getProviderIds();
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLEVER);
            }
            else if (provider === AuthProviderType.CLASSLINK) {
                const roarProviderIds = this._getProviderIds();
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLASSLINK);
            }
            else {
                throw new Error(`provider must be one of ${allowedProviders.join(', ')}. Received ${provider} instead.`);
            }
            const allowedErrors = ['auth/cancelled-popup-request', 'auth/popup-closed-by-user'];
            const swallowAllowedErrors = (error) => {
                if (!allowedErrors.includes(error.code)) {
                    throw error;
                }
            };
            let oAuthAccessToken;
            return (0, auth_1.signInWithPopup)(this.admin.auth, authProvider)
                .then((adminUserCredential) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                this._identityProviderType = provider;
                const roarProviderIds = this._getProviderIds();
                if (provider === AuthProviderType.GOOGLE) {
                    const credential = auth_1.GoogleAuthProvider.credentialFromResult(adminUserCredential);
                    // This gives you a Google Access Token. You can use it to access Google APIs.
                    // TODO: Find a way to put this in the onAuthStateChanged handler
                    oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                    return credential;
                }
                else if ([AuthProviderType.CLEVER, AuthProviderType.CLASSLINK].includes(provider)) {
                    const credential = auth_1.OAuthProvider.credentialFromResult(adminUserCredential);
                    // This gives you a Clever/Classlink Access Token. You can use it to access Clever/Classlink APIs.
                    oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                    let providerId;
                    if (provider === AuthProviderType.CLEVER) {
                        providerId = roarProviderIds.CLEVER;
                    }
                    else if (provider === AuthProviderType.CLASSLINK) {
                        providerId = roarProviderIds.CLASSLINK;
                    }
                    this._identityProviderId = (_a = adminUserCredential.user.providerData.find((userInfo) => userInfo.providerId === providerId)) === null || _a === void 0 ? void 0 : _a.uid;
                    const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                    const roarAdminIdToken = yield (0, auth_1.getIdToken)(adminUserCredential.user);
                    const roarAdminCredential = roarAdminProvider.credential({
                        idToken: roarAdminIdToken,
                    });
                    return roarAdminCredential;
                }
            }))
                .catch(swallowAllowedErrors)
                .then((credential) => {
                if (credential) {
                    return (0, auth_1.signInWithCredential)(this.app.auth, credential).catch(swallowAllowedErrors);
                }
            })
                .then((credential) => {
                if (credential) {
                    const claimsParams = {
                        identityProviderId: this._identityProviderId,
                        identityProviderType: this._identityProviderType,
                    };
                    return this._setUidCustomClaims(claimsParams);
                }
            })
                .then((setClaimsResult) => {
                if (setClaimsResult) {
                    this._syncEduSSOUser(oAuthAccessToken, provider);
                }
            });
        });
    }
    /**
     * Link the current user with the specified authentication provider using a popup window.
     *
     * This method opens a popup window to allow the user to sign in with the specified authentication provider.
     * It then links the user's account with the current user in both the admin and app Firebase projects.
     *
     * @param {AuthProviderType} provider - The authentication provider to link with. It can be one of the following:
     * - AuthProviderType.GOOGLE
     * - AuthProviderType.CLEVER
     * - AuthProviderType.CLASSLINK
     *
     * @returns {Promise<void>} - A promise that resolves when the user is successfully linked with the specified authentication provider.
     *
     * @throws {Error} - If the specified provider is not one of the allowed providers, an error is thrown.
     */
    linkAuthProviderWithPopup(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const allowedProviders = [AuthProviderType.GOOGLE, AuthProviderType.CLEVER, AuthProviderType.CLASSLINK];
            const roarProviderIds = this._getProviderIds();
            let authProvider;
            if (provider === AuthProviderType.GOOGLE) {
                authProvider = new auth_1.GoogleAuthProvider();
            }
            else if (provider === AuthProviderType.CLEVER) {
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLEVER);
            }
            else if (provider === AuthProviderType.CLASSLINK) {
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLASSLINK);
            }
            else {
                throw new Error(`provider must be one of ${allowedProviders.join(', ')}. Received ${provider} instead.`);
            }
            const allowedErrors = ['auth/cancelled-popup-request', 'auth/popup-closed-by-user'];
            const swallowAllowedErrors = (error) => {
                if (!allowedErrors.includes(error.code)) {
                    throw error;
                }
            };
            let oAuthAccessToken;
            return (0, auth_1.linkWithPopup)(this.admin.auth.currentUser, authProvider)
                .then((adminUserCredential) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                this._identityProviderType = provider;
                if (provider === AuthProviderType.GOOGLE) {
                    const credential = auth_1.GoogleAuthProvider.credentialFromResult(adminUserCredential);
                    // This gives you a Google Access Token. You can use it to access Google APIs.
                    // TODO: Find a way to put this in the onAuthStateChanged handler
                    oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                    return credential;
                }
                else if ([AuthProviderType.CLEVER, AuthProviderType.CLASSLINK].includes(provider)) {
                    const credential = auth_1.OAuthProvider.credentialFromResult(adminUserCredential);
                    // This gives you a Clever/Classlink Access Token. You can use it to access Clever/Classlink APIs.
                    oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                    const roarProviderIds = this._getProviderIds();
                    let providerId;
                    if (provider === AuthProviderType.CLEVER) {
                        providerId = roarProviderIds.CLEVER;
                    }
                    else if (provider === AuthProviderType.CLASSLINK) {
                        providerId = roarProviderIds.CLASSLINK;
                    }
                    this._identityProviderId = (_a = adminUserCredential.user.providerData.find((userInfo) => userInfo.providerId === providerId)) === null || _a === void 0 ? void 0 : _a.uid;
                    const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                    const roarAdminIdToken = yield (0, auth_1.getIdToken)(adminUserCredential.user);
                    const roarAdminCredential = roarAdminProvider.credential({
                        idToken: roarAdminIdToken,
                    });
                    return roarAdminCredential;
                }
            }))
                .catch(swallowAllowedErrors)
                .then((credential) => {
                if (credential) {
                    return (0, auth_1.linkWithCredential)(this.app.auth.currentUser, credential).catch(swallowAllowedErrors);
                }
            })
                .then((credential) => {
                if (credential) {
                    const claimsParams = {
                        identityProviderId: this._identityProviderId,
                        identityProviderType: this._identityProviderType,
                    };
                    return this._setUidCustomClaims(claimsParams);
                }
            })
                .then((setClaimsResult) => {
                if (setClaimsResult) {
                    this._syncEduSSOUser(oAuthAccessToken, provider);
                }
            });
        });
    }
    /**
     * Initiates a redirect sign-in flow with the specified authentication provider.
     *
     * This method triggers a redirect to the authentication provider's sign-in page.
     * After the user successfully signs in, they will be redirected back to the application.
     *
     * If the linkToAuthenticatedUser parameter is set to true, an existing user
     * must already be authenticated and the user's account will be linked with
     * the new provider.
     *
     * @param {AuthProviderType} provider - The authentication provider to initiate the sign-in flow with.
     * It can be one of the following: AuthProviderType.GOOGLE, AuthProviderType.CLEVER, AuthProviderType.CLASSLINK.
     * @param {boolean} linkToAuthenticatedUser - Whether to link an authenticated user's account with the new provider.
     *
     * @returns {Promise<void>} - A promise that resolves when the redirect sign-in flow is initiated.
     * @throws {Error} - If the specified provider is not one of the allowed providers, an error is thrown.
     */
    initiateRedirect(provider, linkToAuthenticatedUser = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point for initiateRedirect');
            this._verifyInit();
            if (linkToAuthenticatedUser) {
                this._verifyAuthentication();
            }
            const allowedProviders = [AuthProviderType.GOOGLE, AuthProviderType.CLEVER, AuthProviderType.CLASSLINK];
            let authProvider;
            this.verboseLog('Attempting sign in with AuthProvider', provider);
            if (provider === AuthProviderType.GOOGLE) {
                authProvider = new auth_1.GoogleAuthProvider();
                this.verboseLog('Google AuthProvider object:', authProvider);
            }
            else if (provider === AuthProviderType.CLEVER) {
                const roarProviderIds = this._getProviderIds();
                this.verboseLog('Clever roarProviderIds', roarProviderIds);
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLEVER);
                this.verboseLog('Clever AuthProvider object:', authProvider);
            }
            else if (provider === AuthProviderType.CLASSLINK) {
                const roarProviderIds = this._getProviderIds();
                this.verboseLog('Classlink roarProviderIds', roarProviderIds);
                // Use the partner-initiated flow for Classlink
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLASSLINK);
                this.verboseLog('Classlink AuthProvider object:', authProvider);
            }
            else {
                throw new Error(`provider must be one of ${allowedProviders.join(', ')}. Received ${provider} instead.`);
            }
            this.verboseLog('Calling signInWithRedirect from initiateRedirect with provider', authProvider);
            if (linkToAuthenticatedUser) {
                return (0, auth_1.linkWithRedirect)(this.admin.auth.currentUser, authProvider);
            }
            return (0, auth_1.signInWithRedirect)(this.admin.auth, authProvider);
        });
    }
    /**
     * Handle the sign-in process from a redirect result.
     *
     * This method handles the sign-in process after a user has been redirected
     * from an external identity provider.  It retrieves the user's credentials
     * from the redirect result and authenticates the user to the admin Firebase
     * project using the credentials.
     *
     * The identity provider token is generally mean to be one-time use only.
     * Because of this, the external identity provider's credential cannot be
     * reused in the assessment project. To authenticate into the assessment
     * project, we ask the admin Firebase project itself to mint a new credential
     * for the assessment project. Thus, the external identity providers are used
     * only in the admin Firebase project. And the admin Firebase project acts as
     * an "external" identity provider for the assessment project.
     *
     * Therefore, the workflow for this method is as follows:
     * 1. Get the redirect result from the admin Firebase project.
     * 2. Retrieve the external identity provider's credential from the redirect result.
     * 3. Authenticate into the admin Firebase project with this credential.
     * 4. Generate a new "external" credential from the admin Firebase project.
     * 5. Authenticate into the assessment Firebase project with the admin project's "external" credential.
     * 6. Set UID custom claims by calling setUidCustomClaims().
     * 7. Sync Clever/Classlink user data by calling syncEduSSOUser().
     *
     * @param {() => void} enableCookiesCallback - A callback function to be invoked when the enable cookies error occurs.
     * @returns {Promise<{ status: 'ok' } | null>} - A promise that resolves with an object containing the status 'ok' if the sign-in is successful,
     * or resolves with null if the sign-in is not successful.
     */
    signInFromRedirectResult(enableCookiesCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            this.verboseLog('Entry point for signInFromRedirectResult');
            const catchEnableCookiesError = (error) => {
                this.verboseLog('Catching error, checking if it is the enableCookies error');
                if (error.code == 'auth/web-storage-unsupported') {
                    this.verboseLog('Error was known enableCookies error, invoking enableCookiesCallback()');
                    enableCookiesCallback();
                }
                else {
                    this.verboseLog('It was not the known enableCookies error', error);
                    throw error;
                }
            };
            let oAuthAccessToken;
            let authProvider;
            this.verboseLog('calling getRedirect result from signInFromRedirect');
            return (0, auth_1.getRedirectResult)(this.admin.auth)
                .then((adminUserCredential) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                this.verboseLog('Then block for getRedirectResult');
                if (adminUserCredential !== null) {
                    this.verboseLog('adminUserCredential is not null');
                    const providerId = adminUserCredential.providerId;
                    const roarProviderIds = this._getProviderIds();
                    this.verboseLog('providerId is', providerId);
                    this.verboseLog('roarProviderIds are', roarProviderIds);
                    if (providerId === roarProviderIds.GOOGLE) {
                        this.verboseLog('ProviderId is google, calling credentialFromResult with ', adminUserCredential);
                        const credential = auth_1.GoogleAuthProvider.credentialFromResult(adminUserCredential);
                        // This gives you a Google Access Token. You can use it to access Google APIs.
                        // TODO: Find a way to put this in the onAuthStateChanged handler
                        authProvider = AuthProviderType.GOOGLE;
                        this._identityProviderType = authProvider;
                        oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                        this.verboseLog('oAuthAccessToken = ', oAuthAccessToken);
                        this.verboseLog('returning credential from first .then() ->', credential);
                        return credential;
                    }
                    else if ([roarProviderIds.CLEVER, roarProviderIds.CLASSLINK].includes(providerId !== null && providerId !== void 0 ? providerId : 'NULL')) {
                        this.verboseLog('ProviderId is clever, calling credentialFromResult with', adminUserCredential);
                        const credential = auth_1.OAuthProvider.credentialFromResult(adminUserCredential);
                        // This gives you a Clever/Classlink Access Token. You can use it to access Clever/Classlink APIs.
                        if (providerId === roarProviderIds.CLEVER) {
                            authProvider = AuthProviderType.CLEVER;
                        }
                        else if (providerId === roarProviderIds.CLASSLINK) {
                            authProvider = AuthProviderType.CLASSLINK;
                        }
                        this._identityProviderType = authProvider;
                        this._identityProviderId = (_a = adminUserCredential.user.providerData.find((userInfo) => userInfo.providerId === providerId)) === null || _a === void 0 ? void 0 : _a.uid;
                        oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                        this.verboseLog('authProvider is', authProvider);
                        this.verboseLog('oAuthAccesToken is', oAuthAccessToken);
                        const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                        this.verboseLog('Attempting to call getIdToken with', adminUserCredential.user);
                        const roarAdminIdToken = yield (0, auth_1.getIdToken)(adminUserCredential.user);
                        this.verboseLog('updated token is', roarAdminIdToken);
                        const roarAdminCredential = roarAdminProvider.credential({
                            idToken: roarAdminIdToken,
                        });
                        this.verboseLog(`Using new idToken ${roarAdminIdToken}, created new admin credential`, roarAdminCredential);
                        return roarAdminCredential;
                    }
                }
                return null;
            }))
                .catch(catchEnableCookiesError)
                .then((credential) => {
                this.verboseLog('Attempting sign in using credential', credential);
                if (credential) {
                    this.verboseLog('Calling signInWithCredential with creds', credential);
                    return (0, auth_1.signInWithCredential)(this.app.auth, credential);
                }
                return null;
            })
                .then((credential) => {
                this.verboseLog('Attempting to set uid custom claims using credential', credential);
                if (credential) {
                    this.verboseLog('Calling setUidCustomClaims with creds', credential);
                    const claimsParams = {
                        identityProviderId: this._identityProviderId,
                        identityProviderType: this._identityProviderType,
                    };
                    return this._setUidCustomClaims(claimsParams);
                }
                return null;
            })
                .then((setClaimsResult) => {
                this.verboseLog('Claim result is', setClaimsResult);
                if (setClaimsResult) {
                    this.verboseLog('Calling syncEduSSOUser with oAuthAccessToken', oAuthAccessToken);
                    this._syncEduSSOUser(oAuthAccessToken, authProvider);
                    return { status: 'ok' };
                }
                return null;
            });
        });
    }
    /**
     * Unlinks the specified authentication provider from the current user.
     *
     * This method only unlinks the specified provider from the user in the admin Firebase project.
     * The roarProciderIds.ROAR_ADMIN_PROJECT provider is maintained in the assessment Firebase project.
     *
     * @param {AuthProviderType} provider - The authentication provider to unlink.
     * It can be one of the following: AuthProviderType.GOOGLE, AuthProviderType.CLEVER, AuthProviderType.CLASSLINK.
     * @returns {Promise<void>} - A promise that resolves when the provider is unlinked.
     * @throws {Error} - If the provided provider is not one of the allowed providers.
     */
    unlinkAuthProvider(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const allowedProviders = [
                AuthProviderType.GOOGLE,
                AuthProviderType.CLEVER,
                AuthProviderType.CLASSLINK,
                AuthProviderType.PASSWORD,
            ];
            const roarProviderIds = this._getProviderIds();
            let providerId;
            if (provider === AuthProviderType.GOOGLE) {
                providerId = roarProviderIds.GOOGLE;
            }
            else if (provider === AuthProviderType.CLEVER) {
                const roarProviderIds = this._getProviderIds();
                providerId = roarProviderIds.CLEVER;
            }
            else if (provider === AuthProviderType.CLASSLINK) {
                providerId = roarProviderIds.CLASSLINK;
            }
            else if (provider === AuthProviderType.PASSWORD) {
                providerId = AuthProviderType.PASSWORD;
            }
            else {
                throw new Error(`provider must be one of ${allowedProviders.join(', ')}. Received ${provider} instead.`);
            }
            return (0, auth_1.unlink)(this.admin.auth.currentUser, providerId);
        });
    }
    /**
     * Sign out the current user from the assessment (aka app) Firebase project.
     *
     * This method clears the authentication properties and signs out the user from the app (aka assessment) Firebase projects.
     *
     * @returns {Promise<void>} - A promise that resolves when the user is successfully signed out.
     */
    _signOutApp() {
        return __awaiter(this, void 0, void 0, function* () {
            this._scrubAuthProperties();
            yield (0, auth_1.signOut)(this.app.auth);
        });
    }
    /**
     * Sign out the current user from the admin Firebase project.
     *
     * This method clears the authentication properties and signs out the user from the admin Firebase project.
     *
     * @returns {Promise<void>} - A promise that resolves when the user is successfully signed out.
     */
    _signOutAdmin() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._adminClaimsListener)
                this._adminClaimsListener();
            if (this._adminTokenListener)
                this._adminTokenListener();
            this._scrubAuthProperties();
            yield (0, auth_1.signOut)(this.admin.auth);
        });
    }
    /**
     * Sign out the current user from both the assessment (aka app) Firebase project and the admin Firebase project.
     *
     * This method clears the authentication properties and signs out the user from both the app (aka assessment) and admin Firebase projects.
     *
     * @returns {Promise<void>} - A promise that resolves when the user is successfully signed out.
     */
    signOut() {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            yield this._signOutApp();
            yield this._signOutAdmin();
        });
    }
    //           +--------------------------------+
    // ----------|   End Authentication Methods   |----------
    //           +--------------------------------+
    //           +--------------------------------+
    // ----------| Begin Methods to Read User and |----------
    // ----------| Assignment/Administration Data |----------
    //           +--------------------------------+
    get superAdmin() {
        return this._superAdmin;
    }
    get idTokenReceived() {
        return this._idTokenReceived;
    }
    get idTokens() {
        return this._idTokens;
    }
    /**
     * Return the Firestore REST configuration for the app and admin projects.
     *
     * If the idTokens are not available yet (e.g. before authentication), return
     * undefined, unless ``allowUnauthenticated`` is set to true.
     *
     * @param {boolean} allowUnauthenticated - A boolean determining whether to return restConfig with valid Bearer tokens
     *   to be used in authenticated requests
     * @returns {RestConfig | undefined} - An object containing the REST configuration for the app and admin projects.
     */
    restConfig(allowUnauthenticated = false) {
        if (!allowUnauthenticated) {
            // N.B. We use `==` instead of `===` to catch both undefined and null values.
            if (this._idTokens.admin == undefined || this._idTokens.app == undefined) {
                return undefined;
            }
        }
        const restConfig = {
            admin: {
                baseURL: `https://firestore.googleapis.com/v1/projects/${this.roarConfig.admin.projectId}/databases/(default)/documents`,
            },
            app: {
                baseURL: `https://firestore.googleapis.com/v1/projects/${this.roarConfig.app.projectId}/databases/(default)/documents`,
            },
        };
        if (this._idTokens.admin) {
            restConfig.admin.headers = { Authorization: `Bearer ${this._idTokens.admin}` };
        }
        if (this._idTokens.app) {
            restConfig.app.headers = { Authorization: `Bearer ${this._idTokens.app}` };
        }
        return restConfig;
    }
    get adminOrgs() {
        return this._adminOrgs;
    }
    get dbRefs() {
        var _a, _b;
        if (((_a = this.admin) === null || _a === void 0 ? void 0 : _a.user) && ((_b = this.app) === null || _b === void 0 ? void 0 : _b.user)) {
            return {
                admin: {
                    user: (0, firestore_1.doc)(this.admin.db, 'users', this.roarUid),
                    assignments: (0, firestore_1.collection)(this.admin.db, 'users', this.roarUid, 'assignments'),
                },
                app: {
                    user: (0, firestore_1.doc)(this.app.db, 'users', this.roarUid),
                    runs: (0, firestore_1.collection)(this.app.db, 'users', this.roarUid, 'runs'),
                    tasks: (0, firestore_1.collection)(this.app.db, 'tasks'),
                },
            };
        }
        else {
            return undefined;
        }
    }
    getTasksDictionary() {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const taskDocs = yield (0, firestore_1.getDocs)(this.dbRefs.app.tasks);
            // Create a map with document IDs as keys and document data as values
            const taskMap = taskDocs.docs.reduce((acc, doc) => {
                acc[doc.id] = doc.data();
                return acc;
            }, {});
            return taskMap;
        });
    }
    getAdministrations({ testData = false, restrictToOpenAdministrations = false, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const getAdministrationCallable = (0, functions_1.httpsCallable)(this.admin.functions, 'getAdministrations');
            const response = (yield getAdministrationCallable({
                testData,
                restrictToOpenAdministrations,
            }));
            if ((0, get_1.default)(response.data, 'status') !== 'ok') {
                throw new Error('Failed to retrieve administration IDs.');
            }
            return (_a = response.data.data) !== null && _a !== void 0 ? _a : [];
        });
    }
    getTaskBundles() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const getTaskBundlesCallable = (0, functions_1.httpsCallable)(this.app.functions, 'getTaskBundles');
            const response = (yield getTaskBundlesCallable());
            if ((0, get_1.default)(response.data, 'status') !== 'ok') {
                throw new Error('Failed to retrieve task bundles.');
            }
            return (_a = response.data.data) !== null && _a !== void 0 ? _a : [];
        });
    }
    verifyParentRegistration() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const verifyRegistrationCallable = (0, functions_1.httpsCallable)(this.admin.functions, 'verifyParentRegistration');
            const response = (yield verifyRegistrationCallable());
            if ((0, get_1.default)(response.data, 'status') !== 'ok') {
                throw new Error('Failed to verify parent registration.');
            }
            return (_a = response.data.data) !== null && _a !== void 0 ? _a : false;
        });
    }
    _getUser(uid) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const userDocRef = (0, firestore_1.doc)(this.admin.db, 'users', uid);
            const userDocSnap = yield (0, firestore_1.getDoc)(userDocRef);
            if (userDocSnap.exists()) {
                const userData = Object.assign({ userType: interfaces_1.UserType.guest }, userDocSnap.data());
                const externalDataSnapshot = yield (0, firestore_1.getDocs)((0, firestore_1.collection)(userDocRef, 'externalData'));
                let externalData = {};
                externalDataSnapshot.forEach((doc) => {
                    // doc.data() is never undefined for query doc snapshots returned by ``getDocs``
                    externalData = Object.assign(Object.assign({}, externalData), { [doc.id]: doc.data() });
                });
                userData.externalData = externalData;
                return userData;
            }
            else {
                return {
                    userType: interfaces_1.UserType.guest,
                    districts: (0, util_1.emptyOrg)(),
                    schools: (0, util_1.emptyOrg)(),
                    classes: (0, util_1.emptyOrg)(),
                    families: (0, util_1.emptyOrg)(),
                    groups: (0, util_1.emptyOrg)(),
                    archived: false,
                    testData: false,
                    demoData: false,
                };
            }
        });
    }
    getMyData(targetUid) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point for getMyData');
            this._verifyInit();
            if (!this._isAuthenticated() || !this.roarUid) {
                return;
            }
            const roarUid = targetUid !== null && targetUid !== void 0 ? targetUid : (yield this.getRoarUid());
            this.userData = yield this._getUser(roarUid);
            if (this.userData) {
                // Create a RoarAppUserInfo for later ingestion into a RoarAppkit
                // First determine the PID. If the user has signed in through Clever, then
                // the PID has been set to the Clever ID in the firebase cloud function.
                // If the user signed in through another method, the PID **may** have been
                // set to something else. Grab it if it's there.
                // In either case, it will then be present in this.userData.
                let assessmentPid = (0, get_1.default)(this.userData, 'assessmentPid');
                // If the assessmentPid is undefined, set it to the local part of the user's email.
                if (!assessmentPid) {
                    assessmentPid = (0, nth_1.default)((_a = this.app.user.email) === null || _a === void 0 ? void 0 : _a.match(/^(.+)@/), 1);
                }
                this.roarAppUserInfo = Object.assign(Object.assign({ db: this.app.db, roarUid: roarUid, assessmentUid: this.app.user.uid, assessmentPid: assessmentPid, userType: this.userData.userType }, (this.userData.testData && { testData: true })), (this.userData.demoData && { demoData: true }));
            }
        });
    }
    getLegalDoc(docName) {
        return __awaiter(this, void 0, void 0, function* () {
            const docRef = (0, firestore_1.doc)(this.admin.db, 'legal', docName);
            const docSnap = yield (0, firestore_1.getDoc)(docRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                const gitHubUrl = `https://raw.githubusercontent.com/${(0, get_1.default)(data, 'gitHubOrg')}/${(0, get_1.default)(data, 'gitHubRepository')}/${(0, get_1.default)(data, 'currentCommit')}/${(0, get_1.default)(data, 'fileName')}`;
                try {
                    const response = yield fetch(gitHubUrl);
                    const legalText = yield response.text();
                    return {
                        text: legalText,
                        version: (0, get_1.default)(data, 'currentCommit'),
                    };
                }
                catch (e) {
                    throw new Error('Error retrieving consent document from GitHub.');
                }
            }
            else {
                return null;
            }
        });
    }
    updateConsentStatus(docName, consentVersion, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`Updating consent status for ${this.dbRefs.admin.user.path}.`);
            if (!(0, isEmpty_1.default)(params) && (0, get_1.default)(params, 'dateSigned')) {
                return yield (0, firestore_1.updateDoc)(this.dbRefs.admin.user, {
                    [`legal.${docName}.${consentVersion}`]: (0, firestore_1.arrayUnion)(params),
                });
            }
            else {
                return yield (0, firestore_1.updateDoc)(this.dbRefs.admin.user, {
                    [`legal.${docName}.${consentVersion}`]: (0, firestore_1.arrayUnion)({ dateSigned: new Date() }),
                });
            }
        });
    }
    updateVideoMetadata(administrationId, taskId, status) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            // Update this assignment's `videoWatched` timestamp
            if (status === 'started') {
                yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                    yield this._updateAssignedAssessment(administrationId, taskId, { videoStartedOn: new Date() }, transaction);
                }));
            }
            else if (status === 'completed') {
                yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                    yield this._updateAssignedAssessment(administrationId, taskId, { videoCompletedOn: new Date() }, transaction);
                }));
            }
        });
    }
    get roarUid() {
        return this._roarUid;
    }
    getRoarUid() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const userClaimsRef = (0, firestore_1.doc)(this.admin.db, 'userClaims', this.admin.user.uid);
            const userClaims = yield (0, firestore_1.getDoc)(userClaimsRef).then((doc) => {
                if (!doc.exists()) {
                    throw new Error('User claims document does not exist.');
                }
                return doc.data();
            });
            let _roarUid;
            if (!(0, isEmpty_1.default)(userClaims) && userClaims.claims.roarUid) {
                _roarUid = userClaims.claims.roarUid;
            }
            else {
                _roarUid = (_b = (_a = this.admin) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.uid;
            }
            this._roarUid = _roarUid;
            return _roarUid;
        });
    }
    startAssignment(administrationId, transaction, targetUid) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const roarUid = (_a = targetUid !== null && targetUid !== void 0 ? targetUid : this.roarUid) !== null && _a !== void 0 ? _a : (yield this.getRoarUid());
            const userAssignmentsRef = (0, firestore_1.collection)(this.admin.db, 'users', roarUid, 'assignments');
            const assignmentDocRef = (0, firestore_1.doc)(userAssignmentsRef, administrationId);
            if (transaction) {
                return transaction.update(assignmentDocRef, { started: true });
            }
            else {
                return (0, firestore_1.updateDoc)(assignmentDocRef, { started: true });
            }
        });
    }
    completeAssignment(administrationId, transaction) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const roarUid = (_a = this.roarUid) !== null && _a !== void 0 ? _a : (yield this.getRoarUid());
            const userAssignmentsRef = (0, firestore_1.collection)(this.admin.db, 'users', roarUid, 'assignments');
            const assignmentDocRef = (0, firestore_1.doc)(userAssignmentsRef, administrationId);
            if (transaction) {
                return transaction.update(assignmentDocRef, { completed: true });
            }
            else {
                return (0, firestore_1.updateDoc)(assignmentDocRef, { completed: true });
            }
        });
    }
    _updateAssignedAssessment(administrationId, taskId, updates, transaction, targetUid) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const roarUid = (_a = targetUid !== null && targetUid !== void 0 ? targetUid : this.roarUid) !== null && _a !== void 0 ? _a : (yield this.getRoarUid());
            const assignmentDocRef = (0, firestore_1.collection)(this.admin.db, 'users', roarUid, 'assignments');
            const docRef = (0, firestore_1.doc)(assignmentDocRef, administrationId);
            const docSnap = yield transaction.get(docRef);
            if (docSnap.exists()) {
                const assessments = docSnap.data().assessments;
                const assessmentIdx = assessments.findIndex((a) => a.taskId === taskId);
                const oldAssessmentInfo = assessments[assessmentIdx];
                const newAssessmentInfo = Object.assign(Object.assign({}, oldAssessmentInfo), updates);
                assessments[assessmentIdx] = newAssessmentInfo;
                return transaction.update(docRef, { assessments });
            }
            else {
                return transaction;
            }
        });
    }
    startAssessment(administrationId, taskId, taskVersion, targetUid) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const roarUid = (_a = targetUid !== null && targetUid !== void 0 ? targetUid : this.roarUid) !== null && _a !== void 0 ? _a : (yield this.getRoarUid());
            const appKit = yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                // Check the assignment to see if none of the assessments have been
                // started yet. If not, start the assignment
                const userAssignmentsRef = (0, firestore_1.collection)(this.admin.db, 'users', roarUid, 'assignments');
                const assignmentDocRef = (0, firestore_1.doc)(userAssignmentsRef, administrationId);
                const assignmentDocSnap = yield transaction.get(assignmentDocRef);
                if (assignmentDocSnap.exists()) {
                    // First grab the assessments from the assignment document
                    const assignedAssessments = assignmentDocSnap.data().assessments;
                    const assessmentUpdateData = {
                        startedOn: new Date(),
                    };
                    // Grab this assessment (task), and get the params
                    let assessmentParams = {};
                    const thisAssessment = assignedAssessments.find((a) => a.taskId === taskId);
                    if (thisAssessment) {
                        assessmentParams = thisAssessment.params;
                    }
                    else {
                        throw new Error(`Could not find assessment with taskId ${taskId} in user assignment ${administrationId} for user ${roarUid}`);
                    }
                    // Append runId to `allRunIds` for this assessment
                    // in the userId/assignments collection
                    yield this._updateAssignedAssessment(administrationId, taskId, assessmentUpdateData, transaction, targetUid);
                    if (!assignedAssessments.some((a) => Boolean(a.startedOn))) {
                        yield this.startAssignment(administrationId, transaction, targetUid);
                    }
                    if (this.roarAppUserInfo === undefined) {
                        if (targetUid) {
                            // set data to target participant while assesssment is running, effectively 'spoofing' their identity
                            yield this.getMyData(targetUid);
                        }
                        else {
                            yield this.getMyData();
                        }
                    }
                    const assigningOrgs = assignmentDocSnap.data().assigningOrgs;
                    const readOrgs = assignmentDocSnap.data().readOrgs;
                    const taskAndVariant = yield (0, query_assessment_1.getTaskAndVariant)({
                        db: this.app.db,
                        taskId,
                        variantParams: assessmentParams,
                    });
                    if (taskAndVariant.task === undefined) {
                        throw new Error(`Could not find task ${taskId}`);
                    }
                    if (taskAndVariant.variant === undefined) {
                        throw new Error(`Could not find a variant of task ${taskId} with the params: ${JSON.stringify(assessmentParams)}`);
                    }
                    const taskName = taskAndVariant.task.name;
                    const taskDescription = taskAndVariant.task.description;
                    const variantName = taskAndVariant.variant.name;
                    const variantDescription = taskAndVariant.variant.description;
                    const { testData: isAssignmentTest, demoData: isAssignmentDemo } = assignmentDocSnap.data();
                    const { testData: isUserTest, demoData: isUserDemo } = this.roarAppUserInfo;
                    const { testData: isTaskTest, demoData: isTaskDemo } = taskAndVariant.task;
                    const { testData: isVariantTest, demoData: isVariantDemo } = taskAndVariant.variant;
                    const taskInfo = {
                        db: this.app.db,
                        taskId,
                        taskName,
                        taskDescription,
                        taskVersion,
                        variantName,
                        variantDescription,
                        variantParams: assessmentParams,
                        testData: {
                            task: isTaskTest !== null && isTaskTest !== void 0 ? isTaskTest : false,
                            variant: isVariantTest !== null && isVariantTest !== void 0 ? isVariantTest : false,
                        },
                        demoData: {
                            task: isTaskDemo !== null && isTaskDemo !== void 0 ? isTaskDemo : false,
                            variant: isVariantDemo !== null && isVariantDemo !== void 0 ? isVariantDemo : false,
                        },
                    };
                    return new appkit_1.RoarAppkit({
                        firebaseProject: this.app,
                        userInfo: this.roarAppUserInfo,
                        assigningOrgs,
                        readOrgs,
                        assignmentId: administrationId,
                        taskInfo,
                        testData: {
                            user: isUserTest,
                            task: isTaskTest,
                            variant: isVariantTest,
                            run: isAssignmentTest || isUserTest || isTaskTest || isVariantTest,
                        },
                        demoData: {
                            user: isUserDemo,
                            task: isTaskDemo,
                            variant: isVariantDemo,
                            run: isAssignmentDemo || isUserDemo || isTaskDemo || isVariantDemo,
                        },
                    });
                }
                else {
                    throw new Error(`Could not find assignment for user ${roarUid} with administration id ${administrationId}`);
                }
            }));
            return appKit;
        });
    }
    completeAssessment(administrationId, taskId, targetUid) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                // Check to see if all of the assessments in this assignment have been completed,
                // If so, complete the assignment
                var _a;
                const roarUid = (_a = targetUid !== null && targetUid !== void 0 ? targetUid : this.roarUid) !== null && _a !== void 0 ? _a : (yield this.getRoarUid());
                const userAssignmentsRef = (0, firestore_1.collection)(this.admin.db, 'users', roarUid, 'assignments');
                const docRef = (0, firestore_1.doc)(userAssignmentsRef, administrationId);
                const docSnap = yield transaction.get(docRef);
                // Update this assignment's `completedOn` timestamp
                yield this._updateAssignedAssessment(administrationId, taskId, { completedOn: new Date() }, transaction);
                if (docSnap.exists()) {
                    // Now check to see if all of the assessments in this assignment have
                    // been completed.  Because we do this all in one transaction, we have
                    // to put the `.get` call before any `.update` or `.set` calls. Thus, in
                    // the `docSnap` that we are referencing below, the current assessment
                    // will not have a `completedOn` timestamp yet (we set that after we
                    // called `.get`).  We therefore check to see if all of the assessments
                    // have been completed **or** have the current taskId.
                    if (docSnap.data().assessments.every((a) => {
                        return Boolean(a.completedOn) || a.optional || a.taskId === taskId;
                    })) {
                        this.completeAssignment(administrationId, transaction);
                    }
                }
            }));
        });
    }
    updateAssessmentRewardShown(administrationId, taskId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                this._updateAssignedAssessment(administrationId, taskId, { rewardShown: true }, transaction);
            }));
        });
    }
    // These are all methods that will be important for admins, but not necessary for students
    /**
     * Create or update an administration
     *
     * @param input input object
     * @param input.name The administration name
     * @param input.assessments The list of assessments for this administration
     * @param input.dateOpen The start date for this administration
     * @param input.dateClose The end date for this administration
     * @param input.sequential Whether or not the assessments in this
     *                         administration must be taken sequentially
     * @param input.orgs The orgs assigned to this administration
     * @param input.tags Metadata tags for this administration
     * @param input.administrationId Optional ID of an existing administration. If
     *                               provided, this method will update an
     *                               existing administration.
     */
    createAdministration({ name, publicName, assessments, dateOpen, dateClose, sequential = true, orgs = (0, util_1.emptyOrgList)(), tags = [], administrationId, isTestData = false, legal, }) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if ([name, dateOpen, dateClose, assessments].some((param) => param === undefined || param === null)) {
                throw new Error('The parameters name, dateOpen, dateClose, and assessments are required');
            }
            if (dateClose < dateOpen) {
                throw new Error(`The end date cannot be before the start date: ${dateClose.toISOString()} < ${dateOpen.toISOString()}`);
            }
            // First add the administration to the database
            const administrationData = {
                name,
                publicName: publicName !== null && publicName !== void 0 ? publicName : name,
                createdBy: this.roarUid,
                groups: (_a = orgs.groups) !== null && _a !== void 0 ? _a : [],
                families: (_b = orgs.families) !== null && _b !== void 0 ? _b : [],
                classes: (_c = orgs.classes) !== null && _c !== void 0 ? _c : [],
                schools: (_d = orgs.schools) !== null && _d !== void 0 ? _d : [],
                districts: (_e = orgs.districts) !== null && _e !== void 0 ? _e : [],
                dateCreated: new Date(),
                dateOpened: dateOpen,
                dateClosed: dateClose,
                assessments: assessments,
                sequential: sequential,
                tags: tags,
                legal: legal,
                testData: isTestData !== null && isTestData !== void 0 ? isTestData : false,
            };
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                let administrationDocRef;
                if (administrationId !== undefined) {
                    // Set the doc ref to the existing administration
                    administrationDocRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
                    // Get the existing administration to make sure update is allowed.
                    const docSnap = yield transaction.get(administrationDocRef);
                    if (!docSnap.exists()) {
                        throw new Error(`Could not find administration with id ${administrationId}`);
                    }
                }
                else {
                    // Create a new administration doc ref
                    administrationDocRef = (0, firestore_1.doc)((0, firestore_1.collection)(this.admin.db, 'administrations'));
                }
                // Create the administration doc in the admin Firestore,
                transaction.set(administrationDocRef, administrationData, { merge: true });
                // Then add the ID to the admin's list of administrationsCreated
                const userDocRef = this.dbRefs.admin.user;
                transaction.update(userDocRef, {
                    'adminData.administrationsCreated': (0, firestore_1.arrayUnion)(administrationDocRef.id),
                });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            })).catch((error) => {
                console.error('Error creating administration', error.message);
                if (error === null || error === void 0 ? void 0 : error.message) {
                    throw error;
                }
                else {
                    throw new Error('Error creating administration');
                }
            });
        });
    }
    /**
     * Delete an administration
     *
     * @param administrationId The administration ID to delete
     */
    deleteAdministration(administrationId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if (!this._superAdmin) {
                throw new Error('You must be a super admin to delete an administration.');
            }
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                const administrationDocRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
                const subcollections = ['stats', 'assigningOrgs', 'readOrgs'];
                for (const subcollection of subcollections) {
                    const subcollectionRef = (0, firestore_1.collection)(this.admin.db, 'administrations', administrationId, subcollection);
                    const subcollectionSnapshot = yield (0, firestore_1.getDocs)(subcollectionRef);
                    subcollectionSnapshot.forEach((doc) => {
                        if (doc.exists()) {
                            transaction.delete(doc.ref);
                        }
                    });
                }
                const docSnap = yield transaction.get(administrationDocRef);
                if (docSnap.exists()) {
                    // Delete the administration doc
                    transaction.delete(administrationDocRef);
                }
            }));
        });
    }
    assignAdministrationToOrgs(administrationId, orgs = (0, util_1.emptyOrgList)()) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const docRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
            yield (0, firestore_1.updateDoc)(docRef, {
                districts: (0, firestore_1.arrayUnion)(...orgs.districts),
                schools: (0, firestore_1.arrayUnion)(...orgs.schools),
                classes: (0, firestore_1.arrayUnion)(...orgs.classes),
                groups: (0, firestore_1.arrayUnion)(...orgs.groups),
                families: (0, firestore_1.arrayUnion)(...orgs.families),
            });
        });
    }
    unassignAdministrationToOrgs(administrationId, orgs = (0, util_1.emptyOrgList)()) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const docRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
            yield (0, firestore_1.updateDoc)(docRef, {
                districts: (0, firestore_1.arrayRemove)(...orgs.districts),
                schools: (0, firestore_1.arrayRemove)(...orgs.schools),
                classes: (0, firestore_1.arrayRemove)(...orgs.classes),
                groups: (0, firestore_1.arrayRemove)(...orgs.groups),
                families: (0, firestore_1.arrayRemove)(...orgs.families),
            });
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateUserExternalData(uid, externalResourceId, externalData) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Method not currently implemented.');
            // this._verifyAuthentication();
            // this._verifyAdmin();
            // const docRef = doc(this.admin!.db, 'users', uid, 'externalData', externalResourceId);
            // const docSnap = await getDoc(docRef);
            // if (docSnap.exists()) {
            //   // We use the dot-object module to transform the potentially nested external data to
            //   // dot notation. This prevents overwriting extisting external data.
            //   // See the note about dot notation in https://firebase.google.com/docs/firestore/manage-data/add-data#update_fields_in_nested_objects
            //   await updateDoc(
            //     docRef,
            //     removeNull(
            //       dot.dot({
            //         [externalResourceId]: externalData,
            //       }),
            //     ),
            //   );
            // } else {
            //   await setDoc(docRef, removeNull(externalData));
            // }
        });
    }
    updateUserData(id, userData) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            // Validate data
            // Check that date is not in the future
            if ((_a = userData === null || userData === void 0 ? void 0 : userData.studentData) === null || _a === void 0 ? void 0 : _a.dob) {
                const dob = new Date(userData.studentData.dob);
                if (dob.getTime() > Date.now()) {
                    throw new Error('Date of Birth cannot be in the future.');
                }
            }
            else if (userData.userType === interfaces_1.UserType.student) {
                throw new Error('Date of Birth cannot be empty.');
            }
            // Check that grade is valid (a number, between 1 - 13, or k/prek/tk)
            if ((_b = userData === null || userData === void 0 ? void 0 : userData.studentData) === null || _b === void 0 ? void 0 : _b.grade) {
                const grade = userData.studentData.grade;
                if (!['k', 'pk', 'tk', 'kindergarten'].includes(grade.toLowerCase()) &&
                    (parseInt(grade) < 1 || parseInt(grade) > 13)) {
                    throw new Error('Grade must be a number between 1 and 13, or PK/TK/K.');
                }
            }
            else if (userData.userType === interfaces_1.UserType.student) {
                throw new Error('Grade cannot be empty.');
            }
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                if (id !== undefined) {
                    const userDocRef = (0, firestore_1.doc)(this.admin.db, 'users', id);
                    const docSnap = yield transaction.get(userDocRef);
                    if (!docSnap.exists()) {
                        throw new Error(`Could not find user with id ${id}`);
                    }
                    else {
                        transaction.set(userDocRef, userData, { merge: true });
                    }
                }
                else {
                    throw new Error('No id supplied to updateUserData.');
                }
            }));
            // Pull out fields appropriate for the assessment database.
            const appUserData = {};
            if ((_c = userData === null || userData === void 0 ? void 0 : userData.studentData) === null || _c === void 0 ? void 0 : _c.grade) {
                (0, set_1.default)(appUserData, 'grade', userData.studentData.grade);
            }
            if ((_d = userData === null || userData === void 0 ? void 0 : userData.studentData) === null || _d === void 0 ? void 0 : _d.dob) {
                (0, set_1.default)(appUserData, 'birthMonth', new Date(userData.studentData.dob).getMonth());
                (0, set_1.default)(appUserData, 'birthYear', new Date(userData.studentData.dob).getFullYear());
            }
            if (!(0, isEmpty_1.default)(appUserData)) {
                yield (0, firestore_1.runTransaction)(this.app.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                    if (id !== undefined) {
                        const userDocRef = (0, firestore_1.doc)(this.app.db, 'users', id);
                        const docSnap = yield transaction.get(userDocRef);
                        if (!docSnap.exists()) {
                            throw new Error(`Could not find user with id ${id}`);
                        }
                        else {
                            transaction.set(userDocRef, appUserData, { merge: true });
                        }
                    }
                    else {
                        throw new Error('No id supplied to updateUserData.');
                    }
                }));
            }
            // If password is supplied, update the user's password.
            if (userData === null || userData === void 0 ? void 0 : userData.password) {
                yield this.updateUserRecord(id, { password: userData.password });
            }
            return {
                status: 'ok',
            };
        });
    }
    updateUserRecord(uid, userRecord) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            // Filter out any fields that are null or undefined.
            const record = Object.fromEntries(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            Object.entries(userRecord).filter(([_, v]) => {
                return v && v !== null && v !== undefined;
            }));
            // Validate fields
            if (record.password) {
                if (record.password.length < 6) {
                    throw new Error('Password must be at least 6 characters.');
                }
            }
            console.log('Updating user record for user', uid, 'with', record);
            const cloudUpdateUserRecord = (0, functions_1.httpsCallable)(this.admin.functions, 'updateUserRecord');
            const updateResponse = (yield cloudUpdateUserRecord({ uid, userRecord }));
            if ((0, get_1.default)(updateResponse.data, 'status') !== 'ok') {
                throw new Error('Failed to update user record.');
            }
        });
    }
    /**
     * Send a password reset email to the specified user's email address.
     *
     * This will reset the password in the admin Firebase project. The assessment
     * Firebase project remains unchanged because we use the admin project's
     * credentials to authenticate into the assessment project.
     *
     * @param {string} email - The email address of the user to send the password reset email to.
     * @returns A promise that resolves when the password reset email is sent.
     */
    sendPasswordResetEmail(email) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, auth_1.sendPasswordResetEmail)(this.admin.auth, email).then(() => {
                this.verboseLog('Password reset email sent to', email);
            });
        });
    }
    createUpdateUsers(users) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const sendUsers = [];
            for (const userItem of users) {
                const userDocData = {
                    userType: interfaces_1.UserType.student,
                    studentData: {},
                    districts: (0, util_1.emptyOrg)(),
                    schools: (0, util_1.emptyOrg)(),
                    classes: (0, util_1.emptyOrg)(),
                    families: (0, util_1.emptyOrg)(),
                    groups: (0, util_1.emptyOrg)(),
                    archived: false,
                };
                const { email, password, userData } = userItem;
                // Check for PID. If not supplied, generate one.
                if ((0, get_1.default)(userData, 'pid')) {
                    (0, set_1.default)(userDocData, 'assessmentPid', userData.pid);
                }
                else {
                    // If PID was not supplied, then construct one using an eight character
                    // checksum of the email.
                    // Prefix that checksum with optional org abbreviations:
                    // 1. If the district has an abbreviation, start with that.
                    // 2. Then add the school abbreviation, if it exists.
                    // 3. If neither of those are available, use the group abbreviation.
                    // 4. Otherwise prepend nothing.
                    const emailCheckSum = (0, util_1.crc32String)(email);
                    const districtPrefix = (0, get_1.default)(userData, 'districts.abbreviation');
                    const schoolPrefix = (0, get_1.default)(userData, 'schools.abbreviation');
                    const groupPrefix = (0, get_1.default)(userData, 'groups.abbreviation');
                    const pidParts = [];
                    if (districtPrefix)
                        pidParts.push(districtPrefix);
                    if (schoolPrefix)
                        pidParts.push(schoolPrefix);
                    if (pidParts.length === 0 && groupPrefix)
                        pidParts.push(groupPrefix);
                    pidParts.push(emailCheckSum);
                    (0, set_1.default)(userDocData, 'assessmentPid', pidParts.join('-'));
                }
                // TODO: this can probably be optimized.
                if (email)
                    (0, set_1.default)(userDocData, 'email', email);
                if (password)
                    (0, set_1.default)(userDocData, 'password', password);
                if ((0, get_1.default)(userData, 'username') != undefined) {
                    (0, set_1.default)(userDocData, 'username', userData.username);
                }
                if ((0, get_1.default)(userData, 'name') != undefined) {
                    (0, set_1.default)(userDocData, 'name', userData.name);
                }
                if ((0, get_1.default)(userData, 'dob') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.dob', userData.dob);
                }
                if ((0, get_1.default)(userData, 'gender') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.gender', userData.gender);
                }
                if ((0, get_1.default)(userData, 'grade') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.grade', userData.grade);
                }
                if ((0, get_1.default)(userData, 'state_id') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.state_id', userData.state_id);
                }
                if ((0, get_1.default)(userData, 'hispanic_ethnicity') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.hispanic_ethnicity', userData.hispanic_ethnicity);
                }
                if ((0, get_1.default)(userData, 'ell_status') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.ell_status', userData.ell_status);
                }
                if ((0, get_1.default)(userData, 'iep_status') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.iep_status', userData.iep_status);
                }
                if ((0, get_1.default)(userData, 'frl_status') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.frl_status', userData.frl_status);
                }
                if ((0, get_1.default)(userData, 'race') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.race', userData.race);
                }
                if ((0, get_1.default)(userData, 'home_language') != undefined) {
                    (0, set_1.default)(userDocData, 'studentData.home_language', userData.home_language);
                }
                if ((0, get_1.default)(userData, 'unenroll') != undefined) {
                    (0, set_1.default)(userDocData, 'unenroll', userData.unenroll);
                }
                if ((0, get_1.default)(userData, 'districts') != undefined) {
                    (0, set_1.default)(userDocData, 'orgIds.districts', [userData.districts.id]);
                }
                if ((0, get_1.default)(userData, 'schools') != undefined) {
                    (0, set_1.default)(userDocData, 'orgIds.schools', [userData.schools.id]);
                }
                if ((0, get_1.default)(userData, 'classes') != undefined) {
                    (0, set_1.default)(userDocData, 'orgIds.classes', [userData.classes.id]);
                }
                if ((0, get_1.default)(userData, 'groups') != undefined) {
                    (0, set_1.default)(userDocData, 'orgIds.groups', [userData.groups.id]);
                }
                if ((0, get_1.default)(userData, 'families') != undefined) {
                    (0, set_1.default)(userDocData, 'orgIds.families', [userData.families.id]);
                }
                sendUsers.push(userDocData);
            }
            // After constructing sendUsers array, send them to the sorting function.
            const cloudImportUpdateUsers = (0, functions_1.httpsCallable)(this.admin.functions, 'batchImportUpdate');
            return yield cloudImportUpdateUsers({ users: sendUsers });
        });
    }
    createStudentWithEmailPassword(email, password, userData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if (!(0, get_1.default)(userData, 'dob')) {
                throw new Error('Student date of birth must be supplied.');
            }
            const userDocData = {
                userType: interfaces_1.UserType.student,
                studentData: {},
                districts: (0, util_1.emptyOrg)(),
                schools: (0, util_1.emptyOrg)(),
                classes: (0, util_1.emptyOrg)(),
                families: (0, util_1.emptyOrg)(),
                groups: (0, util_1.emptyOrg)(),
                archived: false,
            };
            if ((0, get_1.default)(userData, 'pid')) {
                (0, set_1.default)(userDocData, 'assessmentPid', userData.pid);
            }
            else {
                // If PID was not supplied, then construct one using an eight character
                // checksum of the email.
                // Prefix that checksum with optional org abbreviations:
                // 1. If the district has an abbreviation, start with that.
                // 2. Then add the school abbreviation, if it exists.
                // 3. If neither of those are available, use the group abbreviation.
                // 4. Otherwise prepend nothing.
                const emailCheckSum = (0, util_1.crc32String)(email);
                const districtPrefix = (0, get_1.default)(userData, 'districts.abbreviation');
                const schoolPrefix = (0, get_1.default)(userData, 'schools.abbreviation');
                const groupPrefix = (0, get_1.default)(userData, 'groups.abbreviation');
                const pidParts = [];
                if (districtPrefix)
                    pidParts.push(districtPrefix);
                if (schoolPrefix)
                    pidParts.push(schoolPrefix);
                if (pidParts.length === 0 && groupPrefix)
                    pidParts.push(groupPrefix);
                pidParts.push(emailCheckSum);
                (0, set_1.default)(userDocData, 'assessmentPid', pidParts.join('-'));
            }
            // TODO: this can probably be optimized.
            (0, set_1.default)(userDocData, 'email', email);
            if ((0, get_1.default)(userData, 'username'))
                (0, set_1.default)(userDocData, 'username', userData.username);
            if ((0, get_1.default)(userData, 'name'))
                (0, set_1.default)(userDocData, 'name', userData.name);
            if ((0, get_1.default)(userData, 'dob'))
                (0, set_1.default)(userDocData, 'studentData.dob', userData.dob);
            if ((0, get_1.default)(userData, 'gender'))
                (0, set_1.default)(userDocData, 'studentData.gender', userData.gender);
            if ((0, get_1.default)(userData, 'grade'))
                (0, set_1.default)(userDocData, 'studentData.grade', userData.grade);
            if ((0, get_1.default)(userData, 'state_id'))
                (0, set_1.default)(userDocData, 'studentData.state_id', userData.state_id);
            if ((0, get_1.default)(userData, 'hispanic_ethnicity'))
                (0, set_1.default)(userDocData, 'studentData.hispanic_ethnicity', userData.hispanic_ethnicity);
            if ((0, get_1.default)(userData, 'ell_status'))
                (0, set_1.default)(userDocData, 'studentData.ell_status', userData.ell_status);
            if ((0, get_1.default)(userData, 'iep_status'))
                (0, set_1.default)(userDocData, 'studentData.iep_status', userData.iep_status);
            if ((0, get_1.default)(userData, 'frl_status'))
                (0, set_1.default)(userDocData, 'studentData.frl_status', userData.frl_status);
            if ((0, get_1.default)(userData, 'race'))
                (0, set_1.default)(userDocData, 'studentData.race', userData.race);
            if ((0, get_1.default)(userData, 'home_language'))
                (0, set_1.default)(userDocData, 'studentData.home_language', userData.home_language);
            if ((0, get_1.default)(userData, 'districts'))
                (0, set_1.default)(userDocData, 'orgIds.districts', [userData.districts.id]);
            if ((0, get_1.default)(userData, 'schools'))
                (0, set_1.default)(userDocData, 'orgIds.schools', [userData.schools.id]);
            if ((0, get_1.default)(userData, 'classes'))
                (0, set_1.default)(userDocData, 'orgIds.classes', [userData.classes.id]);
            if ((0, get_1.default)(userData, 'groups'))
                (0, set_1.default)(userDocData, 'orgIds.groups', [userData.groups.id]);
            if ((0, get_1.default)(userData, 'families'))
                (0, set_1.default)(userDocData, 'orgIds.families', [userData.families.id]);
            const cloudCreateStudent = (0, functions_1.httpsCallable)(this.admin.functions, 'createStudentAccount');
            yield cloudCreateStudent({ email, password, userData: userDocData });
        });
    }
    createNewFamily(caretakerEmail, caretakerPassword, caretakerUserData, children, consentData, isTestData = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // Format children objects
            const formattedChildren = children.map((child) => {
                const returnChild = {
                    email: child.email,
                    password: child.password,
                };
                // Create a PID for the student.
                const emailCheckSum = (0, util_1.crc32String)(child.email);
                const pidParts = [];
                pidParts.push(emailCheckSum);
                (0, set_1.default)(returnChild, 'userData.assessmentPid', pidParts.join('-'));
                // Move attributes into the studentData object.
                (0, set_1.default)(returnChild, 'userData.username', child.email.split('@')[0]);
                if ((0, get_1.default)(child, 'userData.activationCode'))
                    (0, set_1.default)(returnChild, 'userData.activationCode', child.userData.activationCode);
                if ((0, get_1.default)(child, 'userData.name'))
                    (0, set_1.default)(returnChild, 'userData.name', child.userData.name);
                if ((0, get_1.default)(child, 'userData.gender'))
                    (0, set_1.default)(returnChild, 'userData.studentData.gender', child.userData.gender);
                if ((0, get_1.default)(child, 'userData.grade'))
                    (0, set_1.default)(returnChild, 'userData.studentData.grade', child.userData.grade);
                if ((0, get_1.default)(child, 'userData.dob'))
                    (0, set_1.default)(returnChild, 'userData.studentData.dob', child.userData.dob);
                if ((0, get_1.default)(child, 'userData.state_id'))
                    (0, set_1.default)(returnChild, 'userData.studentData.state_id', child.userData.state_id);
                if ((0, get_1.default)(child, 'userData.hispanic_ethnicity'))
                    (0, set_1.default)(returnChild, 'userData.studentData.hispanic_ethnicity', child.userData.hispanic_ethnicity);
                if ((0, get_1.default)(child, 'userData.ell_status'))
                    (0, set_1.default)(returnChild, 'userData.studentData.ell_status', child.userData.ell_status);
                if ((0, get_1.default)(child, 'userData.iep_status'))
                    (0, set_1.default)(returnChild, 'userData.studentData.iep_status', child.userData.iep_status);
                if ((0, get_1.default)(child, 'userData.frl_status'))
                    (0, set_1.default)(returnChild, 'userData.studentData.frl_status', child.userData.frl_status);
                if ((0, get_1.default)(child, 'userData.race'))
                    (0, set_1.default)(returnChild, 'userData.studentData.race', child.userData.race);
                if ((0, get_1.default)(child, 'userData.home_language'))
                    (0, set_1.default)(returnChild, 'userData.studentData.home_language', child.userData.home_language);
                return returnChild;
            });
            // Call cloud function
            const cloudCreateFamily = (0, functions_1.httpsCallable)(this.admin.functions, 'createNewFamily');
            yield cloudCreateFamily({
                caretakerEmail,
                caretakerPassword,
                caretakerUserData,
                children: formattedChildren,
                consentData,
                isTestData,
            });
        });
    }
    createStudentWithUsernamePassword(username, password, userData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const email = `${username}@roar-auth.com`;
            return this.createStudentWithEmailPassword(email, password, userData);
        });
    }
    createAdministrator(email, name, targetOrgs, targetAdminOrgs, isTestData = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const cloudCreateAdministrator = (0, functions_1.httpsCallable)(this.admin.functions, 'createAdministratorAccount');
            const adminResponse = yield cloudCreateAdministrator({
                email,
                name,
                orgs: targetOrgs,
                adminOrgs: targetAdminOrgs,
                isTestData,
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if ((0, get_1.default)(adminResponse.data, 'status') !== 'ok') {
                throw new Error('Failed to create administrator user account.');
            }
        });
    }
    /**
     * Create or update an organization.
     *
     * @param orgsCollection The type of organization to create or update.
     * @param orgData The organization data to create or update.
     * @param isTestData Whether or not this is a test org.
     * @param isDemoData Whether or not this is a demo org.
     * @param organizationId Optional ID of an existing org. If provided, this
     *                       method will update an existing org.
     * @returns The newly created or updated organization ID.
     */
    createOrg(orgsCollection, orgData, isTestData = false, isDemoData = false, organizationId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            // Check that schools have a districtId
            if (orgsCollection === 'schools' && orgData.districtId === undefined) {
                throw new Error('You must specify a districtId when creating a school.');
            }
            // Check that classes have a schoolId
            if (orgsCollection === 'classes' && orgData.schoolId === undefined) {
                throw new Error('You must specify a schoolId when creating a class.');
            }
            orgData = Object.assign({ archived: false }, orgData);
            return (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                // If org is a class, retrieve the districtId from the parent school
                if (orgsCollection === 'classes') {
                    const schoolDocRef = (0, firestore_1.doc)(this.admin.db, 'schools', orgData.schoolId);
                    const districtId = yield transaction.get(schoolDocRef).then((snapshot) => {
                        if (snapshot.exists()) {
                            return snapshot.data().districtId;
                        }
                        else {
                            throw new Error(`Could not find a school with ID ${orgData.schoolId} in the ROAR database.`);
                        }
                    });
                    orgData = Object.assign(Object.assign({}, orgData), { districtId });
                }
                if (isTestData)
                    orgData.testData = true;
                if (isDemoData)
                    orgData.demoData = true;
                if (organizationId === undefined) {
                    // If organizationId is undefined, we create a new org
                    const newOrgRef = (0, firestore_1.doc)((0, firestore_1.collection)(this.admin.db, orgsCollection));
                    const orgId = newOrgRef.id;
                    transaction.set(newOrgRef, orgData);
                    if (orgsCollection === 'schools') {
                        const districtId = orgData.districtId;
                        const adminDistrictRef = (0, firestore_1.doc)(this.admin.db, 'districts', districtId);
                        transaction.update(adminDistrictRef, { schools: (0, firestore_1.arrayUnion)(orgId) });
                    }
                    else if (orgsCollection === 'classes') {
                        const schoolId = orgData.schoolId;
                        const adminSchoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', schoolId);
                        transaction.update(adminSchoolRef, { classes: (0, firestore_1.arrayUnion)(orgId) });
                    }
                    if (orgsCollection === 'groups') {
                        if (orgData.parentOrgId && orgData.parentOrgType) {
                            const parentOrgRef = (0, firestore_1.doc)(this.admin.db, (0, util_1.pluralizeFirestoreCollection)(orgData.parentOrgType), orgData.parentOrgId);
                            transaction.update(parentOrgRef, { subGroups: (0, firestore_1.arrayUnion)(orgId) });
                        }
                        if (orgData.familyId) {
                            const familyRef = (0, firestore_1.doc)(this.admin.db, 'families', orgData.familyId);
                            transaction.update(familyRef, { subGroups: (0, firestore_1.arrayUnion)(orgId) });
                        }
                    }
                    return orgId;
                }
                else {
                    // If organizationId is defined, we update an existing org
                    const orgDocRef = (0, firestore_1.doc)(this.admin.db, orgsCollection, organizationId);
                    // Get the old parent org IDs, remove this org from their children
                    // fields on Firestore.
                    const docSnap = yield transaction.get(orgDocRef);
                    if (docSnap.exists()) {
                        const oldOrgData = docSnap.data();
                        const { schoolId = orgData.schoolId, districtId = orgData.districtId, familyId = orgData.familyId, parentOrgType = orgData.parentOrgType, parentOrgId = orgData.parentOrgId, } = oldOrgData;
                        if (orgsCollection === 'classes' && orgData.schoolId && schoolId !== orgData.schoolId) {
                            const oldSchoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', schoolId);
                            const newSchoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', orgData.schoolId);
                            transaction.update(oldSchoolRef, { classes: (0, firestore_1.arrayRemove)(organizationId) });
                            transaction.update(newSchoolRef, { classes: (0, firestore_1.arrayUnion)(organizationId) });
                        }
                        if (orgsCollection === 'schools' && orgData.districtId && districtId !== orgData.districtId) {
                            const oldDistrictRef = (0, firestore_1.doc)(this.admin.db, 'districts', districtId);
                            const newDistrictRef = (0, firestore_1.doc)(this.admin.db, 'districts', orgData.districtId);
                            transaction.update(oldDistrictRef, { schools: (0, firestore_1.arrayRemove)(organizationId) });
                            transaction.update(newDistrictRef, { schools: (0, firestore_1.arrayUnion)(organizationId) });
                        }
                        if (orgsCollection === 'groups') {
                            if (orgData.familyId && familyId !== orgData.familyId) {
                                const oldFamilyRef = (0, firestore_1.doc)(this.admin.db, 'families', familyId);
                                const newFamilyRef = (0, firestore_1.doc)(this.admin.db, 'families', orgData.familyId);
                                transaction.update(oldFamilyRef, { subGroups: (0, firestore_1.arrayRemove)(organizationId) });
                                transaction.update(newFamilyRef, { subGroups: (0, firestore_1.arrayUnion)(organizationId) });
                            }
                            if (orgData.parentOrgType &&
                                orgData.parentOrgId &&
                                (parentOrgType !== orgData.parentOrgType || parentOrgId !== orgData.parentOrgId)) {
                                const oldParentOrgRef = (0, firestore_1.doc)(this.admin.db, (0, util_1.pluralizeFirestoreCollection)(parentOrgType), parentOrgId);
                                const newParentOrgRef = (0, firestore_1.doc)(this.admin.db, (0, util_1.pluralizeFirestoreCollection)(orgData.parentOrgType), orgData.parentOrgId);
                                transaction.update(oldParentOrgRef, { subGroups: (0, firestore_1.arrayRemove)(organizationId) });
                                transaction.update(newParentOrgRef, { subGroups: (0, firestore_1.arrayUnion)(organizationId) });
                            }
                        }
                        transaction.update(orgDocRef, orgData);
                        return organizationId;
                    }
                    else {
                        throw new Error(`Could not find an organization with ID ${organizationId} in the ROAR database.`);
                    }
                }
            }));
        });
    }
    /**
     * Delete an organization.
     *
     * @param recursive
     * @param orgsCollection The type of organization to create or update.
     * @param orgId The ID of the organization to delete.
     * @param recursive if true, recursively delete all children of this org.
     *                  Default is true.
     */
    deleteOrg(orgsCollection, orgId, recursive = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if (!this._superAdmin) {
                throw new Error('You must be a super admin to delete an organization.');
            }
            // Loop over the admin and assessment databases
            (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const orgDocRef = (0, firestore_1.doc)(this.admin.db, orgsCollection, orgId);
                const docSnap = yield transaction.get(orgDocRef);
                if (docSnap.exists()) {
                    const orgData = docSnap.data();
                    // Save the dependent schools and classes for recursive deletion
                    // later. Why are we doing this here? Because all transaction reads
                    // have to take place before any writes, updates, or deletions.  We
                    // are potentially reading school docs to get all of the classes.
                    const { schools = [], classes = [], groups: subGroups = [] } = orgData;
                    if (recursive) {
                        for (const school of schools) {
                            const schoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', school);
                            const schoolDocSnap = yield transaction.get(schoolRef);
                            if (schoolDocSnap.exists()) {
                                const schoolData = schoolDocSnap.data();
                                classes.push(...((_a = schoolData.classes) !== null && _a !== void 0 ? _a : []));
                                subGroups.push(...((_b = schoolData.subGroups) !== null && _b !== void 0 ? _b : []));
                            }
                        }
                    }
                    // Remove this org from the parent's list of child orgs.
                    const { schoolId, districtId } = orgData;
                    if (schoolId !== undefined) {
                        const schoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', schoolId);
                        transaction.update(schoolRef, { classes: (0, firestore_1.arrayRemove)(orgId) });
                    }
                    else if (districtId !== undefined) {
                        const districtRef = (0, firestore_1.doc)(this.admin.db, 'districts', districtId);
                        transaction.update(districtRef, { schools: (0, firestore_1.arrayRemove)(orgId) });
                    }
                    transaction.delete(orgDocRef);
                    // Remove children orgs if recursive is true
                    if (recursive) {
                        for (const _class of classes) {
                            const classRef = (0, firestore_1.doc)(this.admin.db, 'classes', _class);
                            transaction.delete(classRef);
                        }
                        for (const school of schools) {
                            const schoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', school);
                            transaction.delete(schoolRef);
                        }
                    }
                }
                else {
                    throw new Error(`Could not find an organization with ID ${orgId} in the ROAR database.`);
                }
            }));
        });
    }
    registerTaskVariant({ taskId, taskName, taskDescription, taskImage, taskURL, gameConfig, variantName, variantDescription, variantParams = {}, registered, testData = { task: false, variant: false }, demoData = { task: false, variant: false }, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const task = new task_1.RoarTaskVariant({
                db: this.app.db,
                taskId,
                taskName,
                taskDescription,
                taskImage,
                taskURL,
                gameConfig,
                variantName,
                variantDescription,
                variantParams,
                registered,
                testData,
                demoData,
            });
            yield task.toFirestore();
            return task;
        });
    }
    updateTaskOrVariant(updateData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAdmin();
            let docRef;
            let dataType;
            const { data } = updateData;
            if (updateData.variantId) {
                docRef = (0, firestore_1.doc)(this.app.db, 'tasks', updateData.taskId, 'variants', updateData.variantId);
                dataType = 'variant';
            }
            else {
                docRef = (0, firestore_1.doc)(this.app.db, 'tasks', updateData.taskId);
                dataType = 'task';
            }
            yield (0, firestore_1.setDoc)(docRef, Object.assign({}, data)).then(() => {
                console.log(`Successfully updated ${dataType} data.`);
            });
        });
    }
    /**
     * Creates an AdobeSign agreement for the given email address and document type.
     *
     * This method invokes a cloud function to create an AdobeSign agreement with the specified
     * email address and document type. It returns a promise that resolves with the created agreement data.
     *
     * @param {string} email - The email address of the signer.
     * @param {string} documentType - The type of document for the agreement.
     * @returns {Promise<any>} - A promise that resolves with the created agreement data.
     * @throws {Error} - If an error occurs while creating the AdobeSign agreement.
     */
    createAdobeSignAgreement(email, documentType) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudCreateAdobeSignAgreement = (0, functions_1.httpsCallable)(this.admin.functions, 'createAdobeSignAgreement');
            try {
                return yield cloudCreateAdobeSignAgreement({
                    email,
                    documentType,
                }).then(({ data }) => data);
            }
            catch (error) {
                console.error('Error creating AdobeSign agreement');
                throw error;
            }
        });
    }
    /**
     * Retrieves the status of an AdobeSign agreement by its ID.
     *
     * This method invokes a cloud function to get the status of an AdobeSign agreement using the specified
     * agreement ID. It returns a promise that resolves with the agreement status data.
     *
     * @param {string} agreementId - The ID of the AdobeSign agreement.
     * @returns {Promise<any>} - A promise that resolves with the agreement status data.
     * @throws {Error} - If an error occurs while retrieving the AdobeSign agreement status.
     */
    getAdobeSignAgreementStatus(agreementId) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudGetAdobeSignAgreementStatus = (0, functions_1.httpsCallable)(this.admin.functions, 'getAdobeSignAgreementStatus');
            try {
                return yield cloudGetAdobeSignAgreementStatus({
                    agreementId,
                }).then(({ data }) => data);
            }
            catch (error) {
                console.error('Error getting AdobeSign agreement status');
                throw error;
            }
        });
    }
    /**
     * Retrieves the signing URL for an AdobeSign agreement by its ID and the signer's email address.
     *
     * This method invokes a cloud function to get the signing URL of an AdobeSign agreement using the specified
     * agreement ID and email address. It returns a promise that resolves with the signing URL data.
     *
     * @param {string} agreementId - The ID of the AdobeSign agreement.
     * @param {string} email - The email address of the signer.
     * @returns {Promise<any>} - A promise that resolves with the signing URL data.
     * @throws {Error} - If an error occurs while retrieving the AdobeSign signing URL.
     */
    getAdobeSignSigningUrl(agreementId, email) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudGetAdobeSignSigningUrl = (0, functions_1.httpsCallable)(this.admin.functions, 'getAdobeSignSigningUrl');
            try {
                return yield cloudGetAdobeSignSigningUrl({
                    agreementId,
                    email,
                }).then(({ data }) => data);
            }
            catch (error) {
                console.error('Error getting AdobeSign URL');
                throw error;
            }
        });
    }
    // LEVANTE
    createUsers(userData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const cloudCreateUsers = (0, functions_1.httpsCallable)(this.admin.functions, 'createUsers');
            const result = yield cloudCreateUsers({ userData });
            return result;
        });
    }
    saveSurveyResponses(surveyResponses) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const cloudSaveSurveyResponses = (0, functions_1.httpsCallable)(this.admin.functions, 'saveSurveyResponses');
            try {
                const result = yield cloudSaveSurveyResponses({ surveyResponses });
                return result;
            }
            catch (error) {
                console.error('Error saving survey responses in firekit', error);
                throw error;
            }
        });
    }
    createLevanteGroup(groupData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const cloudCreateLevanteGroup = (0, functions_1.httpsCallable)(this.admin.functions, 'createLevanteGroup');
            try {
                const result = yield cloudCreateLevanteGroup({ groupData });
                return result;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                console.error('Error creating Levante group in firekit', error);
                throw error;
            }
        });
    }
    linkUsers(users) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const cloudLinkUsers = (0, functions_1.httpsCallable)(this.admin.functions, 'linkUsers');
            const result = yield cloudLinkUsers({ users });
            return result;
        });
    }
}
exports.RoarFirekit = RoarFirekit;
