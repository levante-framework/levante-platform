{"version":3,"file":"orgs-C8TAQ0-m.js","sources":["../../../../node_modules/lodash/unzip.js","../../../../node_modules/lodash/zip.js","../../../../node_modules/lodash/flattenDeep.js","../../src/constants/orgTypes.ts","../../src/helpers/query/orgs.js"],"sourcesContent":["var arrayFilter = require('./_arrayFilter'),\n    arrayMap = require('./_arrayMap'),\n    baseProperty = require('./_baseProperty'),\n    baseTimes = require('./_baseTimes'),\n    isArrayLikeObject = require('./isArrayLikeObject');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.zip` except that it accepts an array of grouped\n * elements and creates an array regrouping the elements to their pre-zip\n * configuration.\n *\n * @static\n * @memberOf _\n * @since 1.2.0\n * @category Array\n * @param {Array} array The array of grouped elements to process.\n * @returns {Array} Returns the new array of regrouped elements.\n * @example\n *\n * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n * // => [['a', 1, true], ['b', 2, false]]\n *\n * _.unzip(zipped);\n * // => [['a', 'b'], [1, 2], [true, false]]\n */\nfunction unzip(array) {\n  if (!(array && array.length)) {\n    return [];\n  }\n  var length = 0;\n  array = arrayFilter(array, function(group) {\n    if (isArrayLikeObject(group)) {\n      length = nativeMax(group.length, length);\n      return true;\n    }\n  });\n  return baseTimes(length, function(index) {\n    return arrayMap(array, baseProperty(index));\n  });\n}\n\nmodule.exports = unzip;\n","var baseRest = require('./_baseRest'),\n    unzip = require('./unzip');\n\n/**\n * Creates an array of grouped elements, the first of which contains the\n * first elements of the given arrays, the second of which contains the\n * second elements of the given arrays, and so on.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to process.\n * @returns {Array} Returns the new array of grouped elements.\n * @example\n *\n * _.zip(['a', 'b'], [1, 2], [true, false]);\n * // => [['a', 1, true], ['b', 2, false]]\n */\nvar zip = baseRest(unzip);\n\nmodule.exports = zip;\n","var baseFlatten = require('./_baseFlatten');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Recursively flattens `array`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flattenDeep([1, [2, [3, [4]], 5]]);\n * // => [1, 2, 3, 4, 5]\n */\nfunction flattenDeep(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, INFINITY) : [];\n}\n\nmodule.exports = flattenDeep;\n","export const ORG_TYPES = {\n  DISTRICTS: 'districts',\n  SCHOOLS: 'schools',\n  CLASSES: 'classes',\n  GROUPS: 'groups',\n} as const;\n\nexport const SINGULAR_ORG_TYPES = {\n  DISTRICTS: 'district',\n  SCHOOLS: 'school',\n  CLASSES: 'class',\n  GROUPS: 'group',\n} as const;\n","import { toValue } from 'vue';\nimport _intersection from 'lodash/intersection';\nimport _uniq from 'lodash/uniq';\nimport _flattenDeep from 'lodash/flattenDeep';\nimport _isEmpty from 'lodash/isEmpty';\nimport _without from 'lodash/without';\nimport _zip from 'lodash/zip';\nimport {\n  batchGetDocs,\n  convertValues,\n  fetchDocById,\n  getAxiosInstance,\n  mapFields,\n  orderByDefault,\n  getBaseDocumentPath,\n} from '@/helpers/query/utils';\nimport { ORG_TYPES, SINGULAR_ORG_TYPES } from '@/constants/orgTypes';\nimport { FIRESTORE_COLLECTIONS } from '@/constants/firebase';\n\nexport const getOrgsRequestBody = ({\n  orgType,\n  orgNormalizedName,\n  parentDistrict,\n  parentSchool,\n  orderBy,\n  aggregationQuery,\n  pageLimit,\n  page,\n  paginate = true,\n  select = ['id', 'name', 'tags'],\n}) => {\n  const requestBody = {\n    structuredQuery: {\n      orderBy: orderBy ?? orderByDefault,\n    },\n  };\n\n  if (!aggregationQuery) {\n    if (paginate) {\n      requestBody.structuredQuery.limit = pageLimit;\n      requestBody.structuredQuery.offset = page * pageLimit;\n    }\n\n    requestBody.structuredQuery.select = {\n      fields: select.map((field) => ({ fieldPath: field })),\n    };\n  }\n\n  requestBody.structuredQuery.from = [\n    {\n      collectionId: orgType,\n      allDescendants: false,\n    },\n  ];\n\n  const filters = [];\n\n  if (orgNormalizedName && !(parentDistrict || parentSchool)) {\n    filters.push({\n      fieldFilter: {\n        field: { fieldPath: 'normalizedName' },\n        op: 'EQUAL',\n        value: { stringValue: orgNormalizedName },\n      },\n    });\n\n    if (parentDistrict) {\n      filters.push({\n        fieldFilter: {\n          field: { fieldPath: 'districtId' },\n          op: 'EQUAL',\n          value: { stringValue: parentDistrict },\n        },\n      });\n    }\n  } else if ((orgType === 'schools' && parentDistrict) || (orgType === 'classes' && parentDistrict && !parentSchool)) {\n    if (orgNormalizedName) {\n      filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: 'normalizedName' },\n            op: 'EQUAL',\n            value: { stringValue: orgNormalizedName },\n          },\n        },\n        {\n          fieldFilter: {\n            field: { fieldPath: 'districtId' },\n            op: 'EQUAL',\n            value: { stringValue: parentDistrict },\n          },\n        },\n      );\n    } else {\n      filters.push({\n        fieldFilter: {\n          field: { fieldPath: 'districtId' },\n          op: 'EQUAL',\n          value: { stringValue: parentDistrict },\n        },\n      });\n    }\n  } else if (orgType === 'classes' && parentSchool) {\n    if (orgNormalizedName) {\n      filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: 'normalizedName' },\n            op: 'EQUAL',\n            value: { stringValue: orgNormalizedName },\n          },\n        },\n        {\n          fieldFilter: {\n            field: { fieldPath: 'schoolId' },\n            op: 'EQUAL',\n            value: { stringValue: parentSchool },\n          },\n        },\n      );\n    } else {\n      filters.push({\n        fieldFilter: {\n          field: { fieldPath: 'schoolId' },\n          op: 'EQUAL',\n          value: { stringValue: parentSchool },\n        },\n      });\n    }\n  }\n\n  if (filters.length > 0) {\n    requestBody.structuredQuery.where = {\n      compositeFilter: {\n        op: 'AND',\n        filters,\n      },\n    };\n  }\n\n  if (aggregationQuery) {\n    return {\n      structuredAggregationQuery: {\n        ...requestBody,\n        aggregations: [\n          {\n            alias: 'count',\n            count: {},\n          },\n        ],\n      },\n    };\n  }\n\n  return requestBody;\n};\n\nexport const orgCounter = async (activeOrgType, selectedDistrict, selectedSchool, orderBy, isSuperAdmin, adminOrgs) => {\n  if (isSuperAdmin.value) {\n    const axiosInstance = getAxiosInstance();\n    const requestBody = getOrgsRequestBody({\n      orgType: activeOrgType.value,\n      parentDistrict: selectedDistrict.value,\n      parentSchool: selectedSchool.value,\n      aggregationQuery: true,\n      orderBy: orderBy.value,\n      paginate: false,\n      select: ['name', 'id'],\n    });\n    console.log(`Fetching count for ${activeOrgType.value}`);\n    return axiosInstance.post(':runAggregationQuery', requestBody).then(({ data }) => {\n      return Number(convertValues(data[0].result?.aggregateFields?.count));\n    });\n  } else {\n    console.log('Org Counter, not super admin');\n    if (['groups', 'families'].includes(activeOrgType.value)) {\n      return adminOrgs.value[activeOrgType.value]?.length ?? 0;\n    }\n\n    const { districts: districtIds = [], schools: schoolIds = [], classes: classIds = [] } = adminOrgs.value;\n\n    if (activeOrgType.value === 'districts') {\n      // Count all of the districts in the adminOrgs but also add districts from admin schools and classes\n      const schoolPromises = schoolIds.map((schoolId) => {\n        return fetchDocById('schools', schoolId, ['districtId']);\n      });\n\n      const classPromises = classIds.map((classId) => {\n        return fetchDocById('classes', classId, ['districtId']);\n      });\n\n      const schools = await Promise.all(schoolPromises);\n      const classes = await Promise.all(classPromises);\n\n      districtIds.push(...schools.map(({ districtId }) => districtId));\n      districtIds.push(...classes.map(({ districtId }) => districtId));\n      return _uniq(districtIds).length;\n    } else if (activeOrgType.value === 'schools') {\n      return fetchDocById('districts', selectedDistrict.value, ['schools']).then(async ({ schools }) => {\n        if (districtIds.includes(selectedDistrict.value)) {\n          return schools?.length ?? 0;\n        } else if (schoolIds.length > 0) {\n          return _intersection(schools ?? [], schoolIds).length ?? 0;\n        } else if (classIds.length > 0) {\n          // If we get here, there's no way that the selectedDistrict is not also the parent district of their admin class(es).\n          const classPromises = classIds.map((classId) => {\n            return fetchDocById('classes', classId, ['schoolId']);\n          });\n\n          const classes = await Promise.all(classPromises);\n          return _intersection(\n            schools,\n            classes.map(({ schoolId }) => schoolId),\n          ).length;\n        }\n\n        return 0;\n      });\n    } else if (activeOrgType.value === 'classes') {\n      if (selectedSchool.value) {\n        return fetchDocById('schools', selectedSchool.value, ['classes']).then((school) => {\n          console.log('in orgs counter', districtIds);\n          if (districtIds.includes(selectedDistrict.value) || schoolIds.includes(selectedSchool.value)) {\n            return school.classes?.length ?? 0;\n          }\n          return _intersection(school.classes ?? [], classIds).length;\n        });\n      }\n      return 0;\n    }\n  }\n};\n\nexport const fetchOrgByName = async (orgType, orgNormalizedName, selectedDistrict, selectedSchool, orderBy = null) => {\n  const axiosInstance = getAxiosInstance();\n  const requestBody = getOrgsRequestBody({\n    orgType,\n    parentDistrict: orgType === 'schools' ? selectedDistrict?.value?.id : null,\n    parentSchool: orgType === 'classes' ? selectedSchool?.value?.id : null,\n    aggregationQuery: false,\n    orgNormalizedName,\n    paginate: false,\n    select: ['id', 'name', 'normalizedName'],\n    orderBy,\n  });\n\n  return axiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(({ data }) => mapFields(data));\n};\n\nexport const orgFetcher = async (\n  orgType,\n  selectedDistrict,\n  isSuperAdmin,\n  adminOrgs,\n  select = ['name', 'id', 'tags', 'currentActivationCode'],\n) => {\n  const districtId = toValue(selectedDistrict);\n\n  if (isSuperAdmin.value) {\n    const axiosInstance = getAxiosInstance();\n    const requestBody = getOrgsRequestBody({\n      orgType: orgType,\n      parentDistrict: orgType === 'schools' ? districtId : null,\n      aggregationQuery: false,\n      paginate: false,\n      select: select,\n    });\n\n    if (orgType === 'districts') {\n      console.log(`Fetching ${orgType}`);\n    } else if (orgType === 'schools') {\n      console.log(`Fetching ${orgType} for ${districtId}`);\n    }\n\n    return axiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(({ data }) => mapFields(data));\n  } else {\n    if (['groups', 'families'].includes(orgType)) {\n      const promises = (adminOrgs.value[orgType] ?? []).map((orgId) => {\n        return fetchDocById(orgType, orgId, select);\n      });\n      return Promise.all(promises);\n    } else if (orgType === 'districts') {\n      // First grab all the districts in adminOrgs\n      const promises = (adminOrgs.value[orgType] ?? []).map((orgId) => {\n        return fetchDocById(orgType, orgId, select);\n      });\n\n      // Then add all of the district IDs listed in the docs for each school and class in adminOrgs.\n      const schoolPromises = (adminOrgs.value['schools'] ?? []).map((schoolId) => {\n        return fetchDocById('schools', schoolId, ['districtId']);\n      });\n\n      const classPromises = (adminOrgs.value['classes'] ?? []).map((classId) => {\n        return fetchDocById('classes', classId, ['districtId']);\n      });\n\n      const schools = await Promise.all(schoolPromises);\n      const classes = await Promise.all(classPromises);\n      const districtIds = schools.map((school) => school.districtId);\n      districtIds.push(...classes.map((class_) => class_.districtId));\n\n      for (const districtId of districtIds) {\n        promises.push(fetchDocById(orgType, districtId, select));\n      }\n\n      return Promise.all(promises);\n    } else if (orgType === 'schools') {\n      const districtDoc = await fetchDocById('districts', districtId, ['schools']);\n      if ((adminOrgs.value['districts'] ?? []).includes(districtId)) {\n        const promises = (districtDoc.schools ?? []).map((schoolId) => {\n          return fetchDocById('schools', schoolId, select);\n        });\n        return Promise.all(promises);\n      } else if ((adminOrgs.value['schools'] ?? []).length > 0) {\n        const schoolIds = _intersection(adminOrgs.value['schools'], districtDoc.schools);\n        const promises = (schoolIds ?? []).map((schoolId) => {\n          return fetchDocById('schools', schoolId, select);\n        });\n        return Promise.all(promises);\n      } else if ((adminOrgs.value['classes'] ?? []).length > 0) {\n        const classPromises = (adminOrgs.value['classes'] ?? []).map((classId) => {\n          return fetchDocById('classes', classId, ['schoolId']);\n        });\n        const classes = await Promise.all(classPromises);\n        const schoolIds = _intersection(\n          districtDoc.schools,\n          classes.map((class_) => class_.schoolId),\n        );\n        const promises = (schoolIds ?? []).map((schoolId) => {\n          return fetchDocById('schools', schoolId, select);\n        });\n        return Promise.all(promises);\n      }\n\n      return Promise.resolve([]);\n    }\n  }\n};\n\nexport const orgPageFetcher = async (\n  activeOrgType,\n  selectedDistrict,\n  selectedSchool,\n  orderBy,\n  pageLimit,\n  page,\n  isSuperAdmin,\n  adminOrgs,\n  select = ['id', 'name', 'tags'],\n) => {\n  const axiosInstance = getAxiosInstance();\n  const requestBody = getOrgsRequestBody({\n    orgType: activeOrgType.value,\n    parentDistrict: selectedDistrict.value,\n    parentSchool: selectedSchool.value,\n    aggregationQuery: false,\n    orderBy: orderBy.value,\n    pageLimit: pageLimit.value,\n    paginate: true,\n    page: page.value,\n    select,\n  });\n\n  if (isSuperAdmin.value) {\n    return axiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(({ data }) => mapFields(data));\n  } else {\n    if (activeOrgType.value === 'schools' && (adminOrgs.value['districts'] ?? []).includes(selectedDistrict.value)) {\n      const query = axiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(({ data }) => {\n        return mapFields(data);\n      });\n      return query;\n    } else if (\n      activeOrgType.value === 'classes' &&\n      ((adminOrgs.value['schools'] ?? []).includes(selectedSchool.value) ||\n        (adminOrgs.value['districts'] ?? []).includes(selectedDistrict.value))\n    ) {\n      return axiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(({ data }) => mapFields(data));\n    }\n\n    const orgIds = adminOrgs.value[activeOrgType.value] ?? [];\n    // @TODO: Refactor to a single query for all orgs instead of multiple parallel queries.\n    const promises = orgIds.map((orgId) => fetchDocById(activeOrgType.value, orgId, select));\n    const orderField = (orderBy?.value ?? orderByDefault)[0].field.fieldPath;\n    const orderDirection = (orderBy?.value ?? orderByDefault)[0].direction;\n    const orgs = (await Promise.all(promises)).sort((a, b) => {\n      if (orderDirection === 'ASCENDING') return 2 * +(a[orderField] > b[orderField]) - 1;\n      if (orderDirection === 'DESCENDING') return 2 * +(b[orderField] > a[orderField]) - 1;\n      return 0;\n    });\n\n    return orgs.slice(page.value * pageLimit.value, (page.value + 1) * pageLimit.value);\n  }\n};\n\nexport const orgFetchAll = async (\n  activeOrgType,\n  selectedDistrict,\n  selectedSchool,\n  orderBy,\n  isSuperAdmin,\n  adminOrgs,\n  select,\n) => {\n  const axiosInstance = getAxiosInstance();\n  const requestBody = getOrgsRequestBody({\n    orgType: activeOrgType.value,\n    parentDistrict: selectedDistrict.value,\n    parentSchool: selectedSchool.value,\n    aggregationQuery: false,\n    orderBy: orderBy.value,\n    paginate: false,\n    select,\n  });\n\n  if (isSuperAdmin.value) {\n    try {\n      return await axiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(({ data }) => {\n        return mapFields(data);\n      });\n    } catch (error) {\n      console.error('orgFetchAll: Error fetching all orgs for super admin:', error);\n      return [];\n    }\n  } else {\n    try {\n      return await orgPageFetcher(\n        activeOrgType,\n        selectedDistrict,\n        selectedSchool,\n        orderBy,\n        // Set page limit to max array length in javascript.\n        { value: 2 ** 31 - 1 },\n        { value: 0 },\n        isSuperAdmin,\n        adminOrgs,\n        select,\n      );\n    } catch (error) {\n      console.error('orgFetchAll: Error fetching all orgs for non-super admin:', error);\n      return [];\n    }\n  }\n};\n\n/**\n * Fetches Districts Schools Groups Families (DSGF) Org data for a given administration.\n *\n * @param {String} administrationId – The ID of the administration to fetch DSGF orgs data for.\n * @param {Object} assignedOrgs – The orgs assigned to the administration being processed.\n * @returns {Promise<Array<Object>>} A promise that resolves to an array of org objects.\n */\nexport const fetchTreeOrgs = async (administrationId, assignedOrgs) => {\n  const orgTypes = [ORG_TYPES.DISTRICTS, ORG_TYPES.SCHOOLS, ORG_TYPES.GROUPS, ORG_TYPES.FAMILIES];\n\n  const orgPaths = _flattenDeep(\n    orgTypes.map((orgType) => (assignedOrgs[orgType] ?? []).map((orgId) => `${orgType}/${orgId}`) ?? []),\n  );\n\n  const statsPaths = _flattenDeep(\n    orgTypes.map(\n      (orgType) =>\n        (assignedOrgs[orgType] ?? []).map((orgId) => `administrations/${administrationId}/stats/${orgId}`) ?? [],\n    ),\n  );\n\n  const promises = [\n    batchGetDocs(orgPaths, ['name', 'schools', 'classes', 'archivedSchools', 'archivedClasses', 'districtId']),\n    batchGetDocs(statsPaths),\n  ];\n\n  const [orgDocs, statsDocs] = await Promise.all(promises);\n\n  const dsgfOrgs = _without(\n    _zip(orgDocs, statsDocs).map(([orgDoc, stats], index) => {\n      if (!orgDoc || _isEmpty(orgDoc)) {\n        return undefined;\n      }\n      const { classes, schools, archivedSchools, archivedClasses, collection, ...nodeData } = orgDoc;\n      const node = {\n        key: String(index),\n        data: {\n          orgType: SINGULAR_ORG_TYPES[collection.toUpperCase()],\n          schools,\n          classes,\n          archivedSchools,\n          archivedClasses,\n          stats,\n          ...nodeData,\n        },\n      };\n      if (classes || archivedClasses)\n        node.children = [...(classes ?? []), ...(archivedClasses ?? [])].map((classId) => {\n          return {\n            key: `${node.key}-${classId}`,\n            data: {\n              orgType: SINGULAR_ORG_TYPES.CLASSES,\n              id: classId,\n            },\n          };\n        });\n      return node;\n    }),\n    undefined,\n  );\n\n  const districtIds = dsgfOrgs\n    .filter((node) => node.data.orgType === SINGULAR_ORG_TYPES.DISTRICTS)\n    .map((node) => node.data.id);\n\n  const dependentSchoolIds = _flattenDeep(\n    dsgfOrgs.map((node) => [...(node.data.schools ?? []), ...(node.data.archivedSchools ?? [])]),\n  );\n  const independentSchoolIds =\n    dsgfOrgs.length > 0 ? _without(assignedOrgs.schools, ...dependentSchoolIds) : assignedOrgs.schools;\n  const dependentClassIds = _flattenDeep(\n    dsgfOrgs.map((node) => [...(node.data.classes ?? []), ...(node.data.archivedClasses ?? [])]),\n  );\n  const independentClassIds =\n    dsgfOrgs.length > 0 ? _without(assignedOrgs.classes, ...dependentClassIds) : assignedOrgs.classes;\n\n  const independentSchools = (dsgfOrgs ?? []).filter((node) => {\n    return node.data.orgType === SINGULAR_ORG_TYPES.SCHOOLS && independentSchoolIds.includes(node.data.id);\n  });\n\n  const dependentSchools = (dsgfOrgs ?? []).filter((node) => {\n    return node.data.orgType === SINGULAR_ORG_TYPES.SCHOOLS && !independentSchoolIds.includes(node.data.id);\n  });\n\n  const independentClassPaths = independentClassIds.map((classId) => `classes/${classId}`);\n  const independentClassStatPaths = independentClassIds.map(\n    (classId) => `administrations/${administrationId}/stats/${classId}`,\n  );\n\n  const classPromises = [\n    batchGetDocs(independentClassPaths, ['name', 'schoolId', 'districtId']),\n    batchGetDocs(independentClassStatPaths),\n  ];\n\n  const [classDocs, classStats] = await Promise.all(classPromises);\n\n  let independentClasses = _without(\n    _zip(classDocs, classStats).map(([orgDoc, stats], index) => {\n      const { collection = FIRESTORE_COLLECTIONS.CLASSES, ...nodeData } = orgDoc ?? {};\n\n      if (_isEmpty(nodeData)) return undefined;\n\n      const node = {\n        key: String(dsgfOrgs.length + index),\n        data: {\n          orgType: SINGULAR_ORG_TYPES[collection.toUpperCase()],\n          ...(stats && { stats }),\n          ...nodeData,\n        },\n      };\n      return node;\n    }),\n    undefined,\n  );\n\n  // These are classes that are directly under a district, without a school\n  // They were eroneously categorized as independent classes but now we need\n  // to remove them from the independent classes array\n  const directReportClasses = independentClasses.filter((node) => districtIds.includes(node.data.districtId));\n  independentClasses = independentClasses.filter((node) => !districtIds.includes(node.data.districtId));\n\n  const treeTableOrgs = dsgfOrgs.filter((node) => node.data.orgType === SINGULAR_ORG_TYPES.DISTRICTS);\n  treeTableOrgs.push(...independentSchools);\n\n  for (const school of dependentSchools) {\n    const districtId = school.data.districtId;\n    const districtIndex = treeTableOrgs.findIndex((node) => node.data.id === districtId);\n    if (districtIndex !== -1) {\n      if (treeTableOrgs[districtIndex].children === undefined) {\n        treeTableOrgs[districtIndex].children = [\n          {\n            ...school,\n            key: `${treeTableOrgs[districtIndex].key}-${school.key}`,\n          },\n        ];\n      } else {\n        treeTableOrgs[districtIndex].children.push(school);\n      }\n    } else {\n      treeTableOrgs.push(school);\n    }\n  }\n\n  for (const _class of directReportClasses) {\n    const districtId = _class.data.districtId;\n    const districtIndex = treeTableOrgs.findIndex((node) => node.data.id === districtId);\n    if (districtIndex !== -1) {\n      const directReportSchoolKey = `${treeTableOrgs[districtIndex].key}-9999`;\n      const directReportSchool = {\n        key: directReportSchoolKey,\n        data: {\n          orgType: SINGULAR_ORG_TYPES.SCHOOLS,\n          orgId: '9999',\n          name: 'Direct Report Classes',\n        },\n        children: [\n          {\n            ..._class,\n            key: `${directReportSchoolKey}-${_class.key}`,\n          },\n        ],\n      };\n      if (treeTableOrgs[districtIndex].children === undefined) {\n        treeTableOrgs[districtIndex].children = [directReportSchool];\n      } else {\n        const schoolIndex = treeTableOrgs[districtIndex].children.findIndex(\n          (node) => node.key === directReportSchoolKey,\n        );\n        if (schoolIndex === -1) {\n          treeTableOrgs[districtIndex].children.push(directReportSchool);\n        } else {\n          treeTableOrgs[districtIndex].children[schoolIndex].children.push(_class);\n        }\n      }\n    } else {\n      treeTableOrgs.push(_class);\n    }\n  }\n\n  treeTableOrgs.push(...(independentClasses ?? []));\n  treeTableOrgs.push(...dsgfOrgs.filter((node) => node.data.orgType === SINGULAR_ORG_TYPES.GROUPS));\n  treeTableOrgs.push(...dsgfOrgs.filter((node) => node.data.orgType === SINGULAR_ORG_TYPES.FAMILIES));\n\n  (treeTableOrgs ?? []).forEach((node) => {\n    // Sort the schools by existance of stats then alphabetically\n    if (node.children) {\n      node.children.sort((a, b) => {\n        if (!a.data.stats) return 1;\n        if (!b.data.stats) return -1;\n        return a.data.name.localeCompare(b.data.name);\n      });\n    }\n  });\n\n  return treeTableOrgs;\n};\n"],"names":["arrayFilter","require$$0","arrayMap","require$$1","baseProperty","require$$2","baseTimes","require$$3","isArrayLikeObject","require$$4","nativeMax","unzip","array","length","group","index","unzip_1","baseRest","zip","zip_1","baseFlatten","INFINITY","flattenDeep","flattenDeep_1","ORG_TYPES","SINGULAR_ORG_TYPES","getOrgsRequestBody","orgType","orgNormalizedName","parentDistrict","parentSchool","orderBy","aggregationQuery","pageLimit","page","paginate","select","requestBody","orderByDefault","field","filters","fetchOrgByName","selectedDistrict","selectedSchool","axiosInstance","getAxiosInstance","_a","_b","getBaseDocumentPath","data","mapFields","orgFetcher","isSuperAdmin","adminOrgs","districtId","toValue","promises","orgId","fetchDocById","schoolPromises","schoolId","classPromises","classId","schools","classes","districtIds","school","class_","districtDoc","_intersection","orgPageFetcher","activeOrgType","orderField","orderDirection","a","orgFetchAll","error","fetchTreeOrgs","administrationId","assignedOrgs","orgTypes","orgPaths","_flattenDeep","statsPaths","batchGetDocs","orgDocs","statsDocs","dsgfOrgs","_without","_zip","orgDoc","stats","_isEmpty","archivedSchools","archivedClasses","collection","nodeData","node","dependentSchoolIds","independentSchoolIds","dependentClassIds","independentClassIds","independentSchools","dependentSchools","independentClassPaths","independentClassStatPaths","classDocs","classStats","independentClasses","FIRESTORE_COLLECTIONS","directReportClasses","treeTableOrgs","districtIndex","_class","directReportSchoolKey","directReportSchool","schoolIndex","b"],"mappings":"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","x_google_ignoreList":[0,1,2]}