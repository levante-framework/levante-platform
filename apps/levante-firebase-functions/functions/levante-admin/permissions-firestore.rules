rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ============ CORE AUTH FUNCTIONS ============
    // Basic authentication check
    function loggedIn() {
      return request.auth != null;
    }

    // Get the user ID from the auth token
    function getUid() {
      return request.auth.uid;
    }

    // Fetch user claims from the userClaims collection
    // We use the userClaims collection to store refresh timestamps to propagate
    // custom user claims back to the client
    function getUserClaims() {
      return get(/databases/$(database)/documents/userClaims/$(request.auth.uid)).data.get("claims", {});
    }

    // Check if user is a super_admin or admin
    // Allow super_admins and admins to do everything (for now)
    function isSuperAdminOrAdmin() {
      let claims = getUserClaims();
      return claims.get("super_admin", false) || claims.get("admin", false);
    }

    // ============ NEW PERMISSION SERVICE (SHADOW MODE) ============
    // These functions implement the new permission system but DO NOT affect actual access
    // They only log discrepancies for monitoring

    // Get user's role from the new permission system
    function getUserRole() {
      let userData = get(/databases/$(database)/documents/users/$(getUid())).data;
      return userData.get('role', 'participant');
    }

    // Get user's site-specific roles
    function getUserSiteRoles() {
      let userData = get(/databases/$(database)/documents/users/$(getUid())).data;
      return userData.get('siteRoles', []);
    }

    // Check if user has a specific role for a site
    function hasRoleForSite(siteId, requiredRole) {
      let siteRoles = getUserSiteRoles();
      let roleHierarchy = ['participant', 'research_assistant', 'admin', 'site_admin', 'super_admin'];
      let requiredLevel = roleHierarchy.indexOf(requiredRole);

      // Check global super_admin first
      if (getUserRole() == 'super_admin') {
        return true;
      }

      // Check site-specific roles
      return siteRoles.exists(function(sr) {
        return sr.siteId == siteId &&
               roleHierarchy.indexOf(sr.role) >= requiredLevel;
      });
    }

    // Get permission matrix from system collection
    function getPermissionMatrix() {
      return get(/databases/$(database)/documents/system/permissions).data;
    }

    // Check if a role has permission for a resource and action
    function roleHasPermission(role, resource, action) {
      let matrix = getPermissionMatrix();
      let rolePerms = matrix.get(['permissions', role], {});
      let resourcePerms = rolePerms.get(resource, []);
      return action in resourcePerms;
    }

    // Shadow check for new permission system
    // Returns true if the new system would allow the action
    function shadowPermissionCheck(resource, action, siteId) {
      let userRole = getUserRole();

      // Global super_admin can do everything
      if (userRole == 'super_admin') {
        return true;
      }

      // Check site-specific permissions if siteId is provided
      if (siteId != null) {
        let siteRoles = getUserSiteRoles();
        return siteRoles.exists(function(sr) {
          return sr.siteId == siteId &&
                 roleHasPermission(sr.role, resource, action);
        });
      }

      // Check global role permissions
      return roleHasPermission(userRole, resource, action);
    }

    // Log permission check discrepancy
    // This is a placeholder - in production, you'd use a cloud function to actually log
    function logPermissionDiscrepancy(resource, action, oldResult, newResult, context) {
      // In shadow mode, we always return the old result
      // The discrepancy is noted but doesn't affect access
      return oldResult;
    }

    // Wrapper function to perform both old and new permission checks
    function checkPermissionWithShadow(oldCheck, resource, action, siteId) {
      let oldResult = oldCheck;
      let newResult = shadowPermissionCheck(resource, action, siteId);

      // If results differ, log it (in production, this would trigger a cloud function)
      if (oldResult != newResult) {
        return logPermissionDiscrepancy(resource, action, oldResult, newResult, {
          'uid': getUid(),
          'resource': resource,
          'action': action,
          'siteId': siteId,
          'timestamp': request.time
        });
      }

      return oldResult;
    }

    // Super admins and admins can access everything
    match /{document=**} {
      allow read, write: if isSuperAdminOrAdmin();
    }

    // ============ ORG ADMIN FUNCTIONS ============
    // The auth token has a custom claim for the organizations that the user is
    // an admin for. The expected data structure is:
    // token.adminOrgs = {
    //   districts?: string[],
    //   schools?: string[],
    //   classes?: string[],
    //   groups?: string[],
    // }
    function getAdminOrgs() {
      return getUserClaims().get('adminOrgs', {});
    }

    // Check if user is admin for specific org IDs of a given type
    function isAdminForOrgType(orgType, orgIds) {
      return orgIds.size() > 0 && getAdminOrgs().get(orgType, []).hasAny(orgIds);
    }

    // Check if user is admin for any organization in the provided org data
    function isAdminForAnyOrgType(orgData) {
      return isAdminForOrgType('districts', orgData.get('districts', []))
        || isAdminForOrgType('schools', orgData.get('schools', []))
        || isAdminForOrgType('classes', orgData.get('classes', []))
        || isAdminForOrgType('groups', orgData.get('groups', []))
    }

    // ============ KEY VALIDATION FUNCTIONS ============
    // Ensure specified keys are not being updated
    function keysNotUpdated(keys) {
      return !request.resource.data.diff(resource.data).affectedKeys().hasAny(keys);
    }

    // Ensure only specified keys are being updated
    function onlyTheseKeysUpdated(keys) {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(keys);
    }

    // ============ USER CLAIMS ============
    // We use the userClaims collection to store refresh timestamps to propagate
    // custom user claims back to the client
    match /userClaims/{uid} {
      // Users can only read their own claims
      allow read: if loggedIn() && uid == request.auth.uid;
      // Only cloud functions using admin SDK can write
      allow write: if false;
    }

    // ============ SYSTEM COLLECTION (Permission Matrix) ============
    // Store the permission matrix for the new permission system
    match /system/{document} {
      allow read: if loggedIn();
      allow write: if isSuperAdminOrAdmin();
    }

    // ============ LEGAL DOCS ============
    // Allow all users to read the legal docs
    // Allow no users to write the legal docs
    match /legal/{form} {
      allow read: if true;
      allow write: if false;
    }

    // ============ USERS COLLECTION ============
    match /users/{uid} {
      // Check if the user is accessing their own data
      function myData() {
        return uid == request.auth.uid;
      }

      // Allow parents to read their child's data (needed for surveys)
      function isParentOfUser() {
        let parentUser = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
        return parentUser.userType == 'parent' && resource.data.parentIds.hasAny([request.auth.uid]);
      }

      // Check if the requester is an admin for any of the user's current organizations
      function isUserAdmin() {
        return isAdminForAnyOrgType({
          'districts': resource.data.get(['districts', 'current'], []),
          'schools': resource.data.get(['schools', 'current'], []),
          'classes': resource.data.get(['classes', 'current'], []),
          'groups': resource.data.get(['groups', 'current'], [])
        });
      }

      // Extract site ID from user's organizations
      function getUserSiteId() {
        // Priority: district > school > class > group
        let districts = resource.data.get(['districts', 'current'], []);
        let schools = resource.data.get(['schools', 'current'], []);
        let classes = resource.data.get(['classes', 'current'], []);
        let groups = resource.data.get(['groups', 'current'], []);

        return districts.size() > 0 ? districts[0] :
               schools.size() > 0 ? schools[0] :
               classes.size() > 0 ? classes[0] :
               groups.size() > 0 ? groups[0] : null;
      }

      // Allow users to read their own data
      // Also allow admins to read data for their users
      // Allow parents to read their child's data
      allow read: if checkPermissionWithShadow(
        myData() || isUserAdmin() || isParentOfUser(),
        'users',
        'read',
        getUserSiteId()
      );

      // User creation validation functions
      // Ensure at most one district and school in request
      function hasValidOrgStructure() {
        let data = request.resource.data;
        return data.get(['districts', 'current'], []).size() <= 1
          && data.get(['schools', 'current'], []).size() <= 1;
      }

      // Validate that the admin has permission for the org type and only allowed keys are present
      function isValidAdminAction(orgType, allowedKeys) {
        return isAdminForOrgType(orgType, request.resource.data.get([orgType, 'current'], []))
          && request.resource.data.keys().hasOnly(allowedKeys);
      }

      // Extract site ID from request data for new users
      function getRequestSiteId() {
        let data = request.resource.data;
        let districts = data.get(['districts', 'current'], []);
        let schools = data.get(['schools', 'current'], []);
        let classes = data.get(['classes', 'current'], []);
        let groups = data.get(['groups', 'current'], []);

        return districts.size() > 0 ? districts[0] :
               schools.size() > 0 ? schools[0] :
               classes.size() > 0 ? classes[0] :
               groups.size() > 0 ? groups[0] : null;
      }

      // Creating a new user:
      // The requestor must be an admin for the target user's organization
      // Different org types have different allowed fields
      allow create: if checkPermissionWithShadow(
        loggedIn() && hasValidOrgStructure() && (
          // District admin creating user
          isValidAdminAction('districts', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'districts', 'schools', 'classes', 'assessmentUid'])
          // School admin creating user
          || isValidAdminAction('schools', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'districts', 'schools', 'classes', 'assessmentUid'])
          // Class admin creating user
          || isValidAdminAction('classes', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'districts', 'schools', 'classes', 'assessmentUid'])
          // Group admin creating user (no educational orgs can be set)
          || isValidAdminAction('groups', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'groups', 'assessmentUid'])
        ),
        'users',
        'create',
        getRequestSiteId()
      );

      // Updating an existing user:
      // Users can update their own data
      // Admins can update users in their organizations
      // Cannot update archived or assessmentUid fields
      allow update: if checkPermissionWithShadow(
        (myData() || isUserAdmin()) && keysNotUpdated(['archived', 'assessmentUid']),
        'users',
        'update',
        getUserSiteId()
      );

      // Users can read and write their own survey responses
      match /surveyResponses/{responseId} {
        allow read, write: if myData();
      }

      // External data is read-only for users and their admins
      // Writes only through cloud functions with admin SDK
      match /externalData/{externalDataId} {
        allow read: if loggedIn() && (myData() || isUserAdmin());
        allow write: if false;
      }

      // Users should be able to read and write to their own assignments
      // Admins should be able to read (not write) assignments if they are an admin for one of the assigning orgs
      // N.B. This assumes that the assigningOrgs are exhaustively listed
      match /assignments/{administrationId} {
        function canReadAssignment() {
          return loggedIn() && (myData() || isAdminForAnyOrgType(resource.data.get('assigningOrgs', {})));
        }

        function getAssignmentSiteId() {
          let assigningOrgs = resource.data.get('assigningOrgs', {});
          let districts = assigningOrgs.get('districts', []);
          let schools = assigningOrgs.get('schools', []);
          let classes = assigningOrgs.get('classes', []);
          let groups = assigningOrgs.get('groups', []);

          return districts.size() > 0 ? districts[0] :
                 schools.size() > 0 ? schools[0] :
                 classes.size() > 0 ? classes[0] :
                 groups.size() > 0 ? groups[0] : null;
        }

        allow read: if checkPermissionWithShadow(
          canReadAssignment(),
          'assignments',
          'read',
          getAssignmentSiteId()
        );
        // Only allow assignment creation in cloud functions using the admin SDK
        allow create: if false;
        // Users can update their own assignments but cannot change assigningOrgs or the number of assessments
        allow update: if checkPermissionWithShadow(
          myData() && keysNotUpdated(['assigningOrgs'])
            && request.resource.data.get('assessments', []).size() == resource.data.get('assessments', []).size(),
          'assignments',
          'update',
          getAssignmentSiteId()
        );
      }

      // Runs represent assessment sessions
      match /runs/{runId} {
        function canReadRun() {
          return loggedIn() && (myData()
            || isAdminForAnyOrgType(resource.data.get('assigningOrgs', {}))
            || isAdminForAnyOrgType(resource.data.get('readOrgs', {})));
        }

        allow read: if canReadRun();
        allow create: if myData();
        allow update: if myData();

        // Trials represent individual assessment attempts within a run
        // N.B. This assumes that the assigningOrgs are exhaustively listed
        match /trials/{trialId} {
          function canReadTrial() {
            // Must read parent run document to check assigningOrgs
            let runData = get(/databases/$(database)/documents/users/$(uid)/runs/$(runId)).data;
            return loggedIn() && (myData()
              || isAdminForAnyOrgType(runData.get('assigningOrgs', {}))
              || isAdminForAnyOrgType(runData.get('readOrgs', {})));
          }

          allow read: if canReadTrial();
          allow write: if myData();
        }
      }
    }

    // ============ GROUP ASSIGNMENTS ============
    // Security rules for collection GROUP assignments
    // Admins can read assignments for organizations they administer
    match /{path=**}/assignments/{assignmentId} {
      function getPathAssignmentSiteId() {
        let assigningOrgs = resource.data.get('assigningOrgs', {});
        let districts = assigningOrgs.get('districts', []);
        let schools = assigningOrgs.get('schools', []);
        let classes = assigningOrgs.get('classes', []);
        let groups = assigningOrgs.get('groups', []);

        return districts.size() > 0 ? districts[0] :
               schools.size() > 0 ? schools[0] :
               classes.size() > 0 ? classes[0] :
               groups.size() > 0 ? groups[0] : null;
      }

      allow read: if checkPermissionWithShadow(
        loggedIn() && isAdminForAnyOrgType(resource.data.get('assigningOrgs', {})),
        'assignments',
        'read',
        getPathAssignmentSiteId()
      );
    }

    // ============ ADMINISTRATIONS ============
    // Allow users to read any administration that:
    // - they created
    // - they are assigned to
    // - they are an admin for any of the assigned organizations
    // N.B. This assumes that the assigningOrgs are exhaustively listed
    match /administrations/{administrationId} {
      // Check if user is assigned to this administration through their organizations
      function userAssignedToAdministration() {
        let userData = get(/databases/$(database)/documents/users/$(getUid())).data;
        return userData.get(['districts', 'current'], []).hasAny(resource.data.districts)
          || userData.get(['schools', 'current'], []).hasAny(resource.data.schools)
          || userData.get(['classes', 'current'], []).hasAny(resource.data.classes)
          || userData.get(['groups', 'current'], []).hasAny(resource.data.groups)
      }

      // Check if user created this administration
      function userCreatedAdministration() {
        return getUid() == resource.data.get('createdBy', 'nullId');
      }

      function getAdministrationSiteId() {
        let districts = resource.data.get('districts', []);
        let schools = resource.data.get('schools', []);
        let classes = resource.data.get('classes', []);
        let groups = resource.data.get('groups', []);

        return districts.size() > 0 ? districts[0] :
               schools.size() > 0 ? schools[0] :
               classes.size() > 0 ? classes[0] :
               groups.size() > 0 ? groups[0] : null;
      }

      allow read: if checkPermissionWithShadow(
        loggedIn() && (userAssignedToAdministration() || userCreatedAdministration() || isAdminForAnyOrgType(resource.data)),
        'admins',
        'read',
        getAdministrationSiteId()
      );
      // Only allow creation if user is recorded as creator and is admin for assigned orgs
      allow create: if checkPermissionWithShadow(
        loggedIn() && getUid() == request.resource.data.createdBy && isAdminForAnyOrgType(request.resource.data),
        'admins',
        'create',
        getAdministrationSiteId()
      );
      // Allow updates from creator or admins, but prohibit modification of createdBy field
      allow update: if checkPermissionWithShadow(
        loggedIn() && (userCreatedAdministration() || isAdminForAnyOrgType(resource.data)) && keysNotUpdated(['createdBy']),
        'admins',
        'update',
        getAdministrationSiteId()
      );
      // Prohibit deletion by anyone except super_admins (handled by catch-all rule above)
      allow delete: if false;

      // Administration statistics subcollection
      match /stats/completion {
        allow read: if loggedIn() && (userCreatedAdministration() ||
          isAdminForAnyOrgType(get(/databases/$(database)/documents/administrations/$(administrationId)).data));
        allow write: if false;
      }
    }

    // ============ ORG COLLECTIONS (Districts, Schools, Classes, Groups) ============
    // Helper function to get user's current organizations
    function getUserOrgs(orgType) {
      return get(/databases/$(database)/documents/users/$(getUid())).data.get([orgType, 'current'], []);
    }

    // Anyone in a district can read that district's info
    // Only super_admins can write districts
    match /districts/{districtId} {
      allow read: if checkPermissionWithShadow(
        loggedIn() && (districtId in getUserOrgs('districts') || isAdminForOrgType('districts', [districtId])),
        'groups',
        'read',
        districtId
      );
      allow write: if false;
    }

    // Anyone in a school can read that school's info
    // Only district level admins can write to schools if the school is in their district
    match /schools/{schoolId} {
      allow read: if checkPermissionWithShadow(
        schoolId in getUserOrgs('schools') || isAdminForOrgType('schools', [schoolId]) ||
          isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')]),
        'groups',
        'read',
        schoolId
      );
      allow create: if checkPermissionWithShadow(
        isAdminForOrgType('districts', [request.resource.data.get('districtId', 'nullId')]),
        'groups',
        'create',
        request.resource.data.get('districtId', 'nullId')
      );
      allow update, delete: if checkPermissionWithShadow(
        isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')]),
        'groups',
        resource.type == 'delete' ? 'delete' : 'update',
        resource.data.get('districtId', 'nullId')
      );
    }

    // Anyone in a class can read that class's info
    // Only school or district level admins can write to classes if the class is in their school or district
    match /classes/{classId} {
      allow read: if checkPermissionWithShadow(
        classId in getUserOrgs('classes') || isAdminForOrgType('classes', [classId])
          || isAdminForOrgType('schools', [resource.data.get('schoolId', 'nullId')])
          || isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')]),
        'groups',
        'read',
        classId
      );
      allow create: if checkPermissionWithShadow(
        isAdminForOrgType('districts', [request.resource.data.get('districtId', 'nullId')])
          || isAdminForOrgType('schools', [request.resource.data.get('schoolId', 'nullId')]),
        'groups',
        'create',
        request.resource.data.get('districtId', 'nullId')
      );
      allow update, delete: if checkPermissionWithShadow(
        isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')])
          || isAdminForOrgType('schools', [resource.data.get('schoolId', 'nullId')]),
        'groups',
        resource.type == 'delete' ? 'delete' : 'update',
        resource.data.get('districtId', 'nullId')
      );
    }

    // Anyone in a group can read that group's info
    // Anyone who is an admin for this group can write to it
    match /groups/{groupId} {
      allow read: if checkPermissionWithShadow(
        loggedIn() && (groupId in getUserOrgs('groups') || isAdminForOrgType('groups', [groupId])),
        'groups',
        'read',
        groupId
      );
      allow write: if checkPermissionWithShadow(
        isAdminForOrgType('groups', [groupId]),
        'groups',
        resource.type == 'delete' ? 'delete' : (resource.type == 'create' ? 'create' : 'update'),
        groupId
      );
    }

    // ============ GUESTS ============
    // We allow anonymous guest access so that people can try an individual
    // task without having to create a dashboard account.
    // Use cases:
    // - Users may want to try out LEVANTE before creating an account
    // - App developers may want to pilot new apps or features without deploying to the dashboard
    // - External lab partners may want to use LEVANTE tasks without the dashboard -- TODO: Remove
    //
    // We restrict all read access to guest documents. Only super_admins and the admin SDK can read them.
    // We will rely on cloud functions using the admin SDK to export this data to the labs.
    match /guests/{guestUid} {
      function isGuest() {
        return loggedIn() && request.auth.uid == guestUid;
      }

      allow read: if isGuest();
      allow create: if isGuest() && request.resource.data.get('userType', 'nullType') == 'guest';
      allow update: if isGuest() && keysNotUpdated(['userType']);
      allow delete: if false;

      match /runs/{runId} {
        // Guest runs are write-only for privacy
        allow read: if false;
        allow create, update: if isGuest();
        allow delete: if false;

        match /trials/{trialId} {
          // Guest trials are write-only for privacy
          allow read: if false;
          allow create, update: if isGuest();
          allow delete: if false;
        }
      }
    }

    // ============ TASKS ============
    // Tasks and variants are free for any authenticated user to read and create
    // Updates are only allowed for certain fields
    // Only super_admins can update the `registered` field
    match /tasks/{taskId} {
      function canUpdateTask() {
        let newParams = request.resource.data.get("params", {});
        let oldParams = resource.data.get("params", {});
        // Ensure no params are added or removed, only values can be updated
        return loggedIn()
          && keysNotUpdated(['registered'])
          && onlyTheseKeysUpdated(['description', 'lastUpdated', 'params', "createdAt", "updatedAt"])
          && newParams.diff(oldParams).addedKeys().size() == 0
          && newParams.diff(oldParams).removedKeys().size() == 0;
      }

      allow read: if checkPermissionWithShadow(
        loggedIn(),
        'tasks',
        'read',
        null
      );
      // Cannot create with 'registered' field - that's admin only
      allow create: if checkPermissionWithShadow(
        loggedIn() && !request.resource.data.keys().hasAny(['registered']),
        'tasks',
        'create',
        null
      );
      allow update: if checkPermissionWithShadow(
        canUpdateTask(),
        'tasks',
        'update',
        null
      );

      match /variants/{variantId} {
        allow read: if checkPermissionWithShadow(
          loggedIn(),
          'tasks',
          'read',
          null
        );
        allow create: if checkPermissionWithShadow(
          loggedIn() && !request.resource.data.keys().hasAny(['registered']),
          'tasks',
          'create',
          null
        );
        allow update: if checkPermissionWithShadow(
          canUpdateTask(),
          'tasks',
          'update',
          null
        );
      }
    }

    // ============ PERMISSION LOGS (For Shadow Mode Monitoring) ============
    // This collection will store discrepancies between old and new permission systems
    // Only cloud functions can write to this collection
    match /permissionLogs/{logId} {
      allow read: if isSuperAdminOrAdmin();
      allow write: if false; // Only cloud functions can write
    }
  }
}
