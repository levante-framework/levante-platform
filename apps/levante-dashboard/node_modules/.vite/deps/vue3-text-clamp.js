import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import "./chunk-SKPULAU2.js";
import {
  computed,
  createBaseVNode,
  createElementBlock,
  defineComponent,
  nextTick,
  normalizeStyle,
  onMounted,
  onUnmounted,
  openBlock,
  reactive,
  ref,
  renderSlot,
  unref,
  watch
} from "./chunk-GBYMHZRU.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-QX3VWGKS.js";

// ../../node_modules/vue3-text-clamp/lib/text-clamp.esm.js
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());

// ../../node_modules/resize-detector/esm/index.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var raf = null;
function requestAnimationFrame(callback) {
  if (!raf) {
    raf = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback2) {
      return setTimeout(callback2, 16);
    }).bind(window);
  }
  return raf(callback);
}
var caf = null;
function cancelAnimationFrame(id) {
  if (!caf) {
    caf = (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id2) {
      clearTimeout(id2);
    }).bind(window);
  }
  caf(id);
}
function createStyles(styleText) {
  var style2 = document.createElement("style");
  if (style2.styleSheet) {
    style2.styleSheet.cssText = styleText;
  } else {
    style2.appendChild(document.createTextNode(styleText));
  }
  (document.querySelector("head") || document.body).appendChild(style2);
  return style2;
}
function createElement(tagName, props) {
  if (props === void 0) props = {};
  var elem = document.createElement(tagName);
  Object.keys(props).forEach(function(key) {
    elem[key] = props[key];
  });
  return elem;
}
function getComputedStyle(elem, prop, pseudo) {
  var computedStyle = window.getComputedStyle(elem, pseudo || null) || {
    display: "none"
  };
  return computedStyle[prop];
}
function getRenderInfo(elem) {
  if (!document.documentElement.contains(elem)) {
    return {
      detached: true,
      rendered: false
    };
  }
  var current = elem;
  while (current !== document) {
    if (getComputedStyle(current, "display") === "none") {
      return {
        detached: false,
        rendered: false
      };
    }
    current = current.parentNode;
  }
  return {
    detached: false,
    rendered: true
  };
}
var css_248z = '.resize-triggers{visibility:hidden;opacity:0;pointer-events:none}.resize-contract-trigger,.resize-contract-trigger:before,.resize-expand-trigger,.resize-triggers{content:"";position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden}.resize-contract-trigger,.resize-expand-trigger{background:#eee;overflow:auto}.resize-contract-trigger:before{width:200%;height:200%}';
var total = 0;
var style = null;
function addListener(elem, callback) {
  if (!elem.__resize_mutation_handler__) {
    elem.__resize_mutation_handler__ = handleMutation.bind(elem);
  }
  var listeners = elem.__resize_listeners__;
  if (!listeners) {
    elem.__resize_listeners__ = [];
    if (window.ResizeObserver) {
      var offsetWidth = elem.offsetWidth;
      var offsetHeight = elem.offsetHeight;
      var ro = new ResizeObserver(function() {
        if (!elem.__resize_observer_triggered__) {
          elem.__resize_observer_triggered__ = true;
          if (elem.offsetWidth === offsetWidth && elem.offsetHeight === offsetHeight) {
            return;
          }
        }
        runCallbacks(elem);
      });
      var ref2 = getRenderInfo(elem);
      var detached = ref2.detached;
      var rendered = ref2.rendered;
      elem.__resize_observer_triggered__ = detached === false && rendered === false;
      elem.__resize_observer__ = ro;
      ro.observe(elem);
    } else if (elem.attachEvent && elem.addEventListener) {
      elem.__resize_legacy_resize_handler__ = function handleLegacyResize() {
        runCallbacks(elem);
      };
      elem.attachEvent("onresize", elem.__resize_legacy_resize_handler__);
      document.addEventListener("DOMSubtreeModified", elem.__resize_mutation_handler__);
    } else {
      if (!total) {
        style = createStyles(css_248z);
      }
      initTriggers(elem);
      elem.__resize_rendered__ = getRenderInfo(elem).rendered;
      if (window.MutationObserver) {
        var mo = new MutationObserver(elem.__resize_mutation_handler__);
        mo.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
        elem.__resize_mutation_observer__ = mo;
      }
    }
  }
  elem.__resize_listeners__.push(callback);
  total++;
}
function removeListener(elem, callback) {
  var listeners = elem.__resize_listeners__;
  if (!listeners) {
    return;
  }
  if (callback) {
    listeners.splice(listeners.indexOf(callback), 1);
  }
  if (!listeners.length || !callback) {
    if (elem.detachEvent && elem.removeEventListener) {
      elem.detachEvent("onresize", elem.__resize_legacy_resize_handler__);
      document.removeEventListener("DOMSubtreeModified", elem.__resize_mutation_handler__);
      return;
    }
    if (elem.__resize_observer__) {
      elem.__resize_observer__.unobserve(elem);
      elem.__resize_observer__.disconnect();
      elem.__resize_observer__ = null;
    } else {
      if (elem.__resize_mutation_observer__) {
        elem.__resize_mutation_observer__.disconnect();
        elem.__resize_mutation_observer__ = null;
      }
      elem.removeEventListener("scroll", handleScroll);
      elem.removeChild(elem.__resize_triggers__.triggers);
      elem.__resize_triggers__ = null;
    }
    elem.__resize_listeners__ = null;
  }
  if (!--total && style) {
    style.parentNode.removeChild(style);
  }
}
function getUpdatedSize(elem) {
  var ref2 = elem.__resize_last__;
  var width = ref2.width;
  var height = ref2.height;
  var offsetWidth = elem.offsetWidth;
  var offsetHeight = elem.offsetHeight;
  if (offsetWidth !== width || offsetHeight !== height) {
    return {
      width: offsetWidth,
      height: offsetHeight
    };
  }
  return null;
}
function handleMutation() {
  var ref2 = getRenderInfo(this);
  var rendered = ref2.rendered;
  var detached = ref2.detached;
  if (rendered !== this.__resize_rendered__) {
    if (!detached && this.__resize_triggers__) {
      resetTriggers(this);
      this.addEventListener("scroll", handleScroll, true);
    }
    this.__resize_rendered__ = rendered;
    runCallbacks(this);
  }
}
function handleScroll() {
  var this$1 = this;
  resetTriggers(this);
  if (this.__resize_raf__) {
    cancelAnimationFrame(this.__resize_raf__);
  }
  this.__resize_raf__ = requestAnimationFrame(function() {
    var updated = getUpdatedSize(this$1);
    if (updated) {
      this$1.__resize_last__ = updated;
      runCallbacks(this$1);
    }
  });
}
function runCallbacks(elem) {
  if (!elem || !elem.__resize_listeners__) {
    return;
  }
  elem.__resize_listeners__.forEach(function(callback) {
    callback.call(elem, elem);
  });
}
function initTriggers(elem) {
  var position = getComputedStyle(elem, "position");
  if (!position || position === "static") {
    elem.style.position = "relative";
  }
  elem.__resize_old_position__ = position;
  elem.__resize_last__ = {};
  var triggers = createElement("div", {
    className: "resize-triggers"
  });
  var expand = createElement("div", {
    className: "resize-expand-trigger"
  });
  var expandChild = createElement("div");
  var contract = createElement("div", {
    className: "resize-contract-trigger"
  });
  expand.appendChild(expandChild);
  triggers.appendChild(expand);
  triggers.appendChild(contract);
  elem.appendChild(triggers);
  elem.__resize_triggers__ = {
    triggers,
    expand,
    expandChild,
    contract
  };
  resetTriggers(elem);
  elem.addEventListener("scroll", handleScroll, true);
  elem.__resize_last__ = {
    width: elem.offsetWidth,
    height: elem.offsetHeight
  };
}
function resetTriggers(elem) {
  var ref2 = elem.__resize_triggers__;
  var expand = ref2.expand;
  var expandChild = ref2.expandChild;
  var contract = ref2.contract;
  var csw = contract.scrollWidth;
  var csh = contract.scrollHeight;
  var eow = expand.offsetWidth;
  var eoh = expand.offsetHeight;
  var esw = expand.scrollWidth;
  var esh = expand.scrollHeight;
  contract.scrollLeft = csw;
  contract.scrollTop = csh;
  expandChild.style.width = eow + 1 + "px";
  expandChild.style.height = eoh + 1 + "px";
  expand.scrollLeft = esw;
  expand.scrollTop = esh;
}

// ../../node_modules/vue3-text-clamp/lib/text-clamp.esm.js
var g = ["aria-label"];
var v = defineComponent({ __name: "text-clamp", props: { text: { type: String, required: true }, maxHeight: { type: [String, Number], required: false }, maxLines: { type: Number, required: false }, expanded: { type: Boolean, required: false, default: false }, location: { type: String, required: false, default: "end" }, ellipsis: { type: String, required: false, default: "â€¦" }, autoResize: { type: Boolean, required: false, default: false } }, emits: ["clamp-change", "update:expanded"], setup(e, { emit: v2 }) {
  const h2 = e, y2 = ref(null), b = ref(null), E = ref(null), H = reactive({ offset: 0, localExpanded: !!h2.expanded, unregisterResizeCallback: null }), R = computed(() => {
    if (!H.localExpanded && h2.maxHeight) return "number" == typeof (h2 == null ? void 0 : h2.maxHeight) ? `${h2 == null ? void 0 : h2.maxHeight}px` : h2 == null ? void 0 : h2.maxHeight;
  }), _ = () => {
    E.value && (E.value.textContent = A.value);
  }, k = () => {
    H.localExpanded || (_(), (C() || w.value) && $());
  }, q = () => {
    h2.text && (H.offset = h2.text.length, z(), h2.autoResize && y2.value && (addListener(y2.value, k), H.unregisterResizeCallback = () => {
      y2.value && removeListener(y2.value, k);
    }), k());
  }, z = () => {
    var _a;
    (_a = H.unregisterResizeCallback) == null ? void 0 : _a.call(H);
  }, C = () => !(!h2.maxLines && !h2.maxHeight) && (!!y2.value && (!!(h2.maxLines && L() > h2.maxLines) || !!(h2.maxHeight && y2.value.scrollHeight > y2.value.offsetHeight))), L = () => b.value ? Object.keys(Array.prototype.slice.call(b.value.getClientRects()).reduce((e2, { top: t, bottom: a }) => {
    const l = `${t}/${a}`;
    return e2[l] || (e2[l] = true), e2;
  }, {})).length : 0, $ = (...e2) => {
    const [t = 0, a = H.offset] = e2;
    if (a - t <= 3) return void j();
    const l = Math.floor((a + t) / 2);
    S(l), C() ? $(t, l) : $(l, a);
  }, S = (e2) => {
    H.offset = e2, _();
  }, j = () => {
    B(), M();
  }, B = () => {
    for (; (!C() || L() < 2) && H.offset < h2.text.length; ) N(1);
  }, M = () => {
    for (; C() && L() > 1 && H.offset > 0; ) N(-1);
  }, N = (e2) => {
    S(H.offset + e2);
  }, w = computed(() => !!h2.text && H.offset !== h2.text.length);
  watch(() => w.value, (e2) => {
    setTimeout(() => {
      v2("clamp-change", e2);
    }, 0);
  }, { immediate: true });
  const A = computed(() => w.value ? O.value : h2.text), O = computed(() => {
    if ("start" === h2.location) return h2.ellipsis + (h2.text.slice(-H.offset) || "").trim();
    if ("middle" === h2.location) {
      const e2 = Math.floor(H.offset / 2);
      return (h2.text.slice(0, e2) || "").trim() + h2.ellipsis + (h2.text.slice(-e2) || "").trim();
    }
    return (h2.text.slice(0, H.offset) || "").trim() + h2.ellipsis;
  }), T = () => {
    H.localExpanded = true;
  }, D = () => {
    H.localExpanded = false;
  }, F = () => {
    H.localExpanded = !H.localExpanded;
  };
  return watch(() => h2.expanded, (e2) => {
    H.localExpanded = e2;
  }), watch(() => H.localExpanded, (e2) => {
    e2 ? S(h2.text.length) : k(), h2.expanded !== e2 && v2("update:expanded", e2);
  }), watch(() => [h2.maxLines, h2.maxHeight, h2.ellipsis, h2.location, w.value].join(), () => {
    nextTick(() => {
      k();
    });
  }), watch(() => [h2.text, h2.autoResize].join(), () => {
    nextTick(() => {
      q();
    });
  }), onUnmounted(() => {
    z();
  }), onMounted(() => {
    q();
  }), (t, a) => (openBlock(), createElementBlock("div", { ref_key: "textClampRef", ref: y2, class: "text-clamp", style: normalizeStyle({ overflow: "hidden", maxHeight: unref(R) }) }, [createBaseVNode("span", { ref_key: "contentRef", ref: b }, [renderSlot(t.$slots, "before", { expand: T, collapse: D, toggle: F, clamped: unref(w), expanded: H.localExpanded }), createBaseVNode("span", { ref_key: "textRef", ref: E, "aria-label": e.text }, null, 8, g), renderSlot(t.$slots, "after", { expand: T, collapse: D, toggle: F, clamped: unref(w), expanded: H.localExpanded })], 512)], 4));
} });
v.__file = "package/text-clamp.vue";
var h = (e) => (e.install = function(t) {
  t.component(e.__name, e);
}, e);
var y = h(v);
export {
  y as default,
  h as withInstall
};
//# sourceMappingURL=vue3-text-clamp.js.map
