rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ============ CORE AUTH FUNCTIONS ============
    // Basic authentication check
    function loggedIn() {
      return request.auth != null;
    }

    // Get the user ID from the auth token
    function getUid() {
      return request.auth.uid;
    }

    // Fetch user claims from the userClaims collection
    // We use the userClaims collection to store refresh timestamps to propagate
    // custom user claims back to the client
    function getUserClaims() {
      return get(/databases/$(database)/documents/userClaims/$(request.auth.uid)).data.get("claims", {});
    }

    // Check if user is a super_admin or admin
    // Allow super_admins and admins to do everything (for now)
    function isSuperAdminOrAdmin() {
      let claims = getUserClaims();
      return claims.get("super_admin", false) || claims.get("admin", false);
    }

    // Super admins and admins can access everything
    match /{document=**} {
      allow read, write: if isSuperAdminOrAdmin();
    }

    // ============ ORG ADMIN FUNCTIONS ============
    // The auth token has a custom claim for the organizations that the user is
    // an admin for. The expected data structure is:
    // token.adminOrgs = {
    //   districts?: string[],
    //   schools?: string[],
    //   classes?: string[],
    //   groups?: string[],
    // }
    function getAdminOrgs() {
      return getUserClaims().get('adminOrgs', {});
    }

    // Check if user is admin for specific org IDs of a given type
    function isAdminForOrgType(orgType, orgIds) {
      return orgIds.size() > 0 && getAdminOrgs().get(orgType, []).hasAny(orgIds);
    }

    // Check if user is admin for any organization in the provided org data
    function isAdminForAnyOrgType(orgData) {
      return isAdminForOrgType('districts', orgData.get('districts', []))
        || isAdminForOrgType('schools', orgData.get('schools', []))
        || isAdminForOrgType('classes', orgData.get('classes', []))
        || isAdminForOrgType('groups', orgData.get('groups', []))
    }

    // ============ KEY VALIDATION FUNCTIONS ============
    // Ensure specified keys are not being updated
    function keysNotUpdated(keys) {
      return !request.resource.data.diff(resource.data).affectedKeys().hasAny(keys);
    }

    // Ensure only specified keys are being updated
    function onlyTheseKeysUpdated(keys) {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(keys);
    }

    // ============ USER CLAIMS ============
    // We use the userClaims collection to store refresh timestamps to propagate
    // custom user claims back to the client
    match /userClaims/{uid} {
      // Users can only read their own claims
      allow read: if loggedIn() && uid == request.auth.uid;
      // Only cloud functions using admin SDK can write
      allow write: if false;
    }

    // ============ LEGAL DOCS ============
    // Allow all users to read the legal docs
    // Allow no users to write the legal docs
    match /legal/{form} {
      allow read: if true;
      allow write: if false;
    }

    // ============ USERS COLLECTION ============
    match /users/{uid} {
      // Check if the user is accessing their own data
      function myData() {
        return uid == request.auth.uid;
      }

      // Allow parents to read their child's data (needed for surveys)
      function isParentOfUser() {
        let parentUser = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
        return parentUser.userType == 'parent' && resource.data.parentIds.hasAny([request.auth.uid]);
      }

      // Check if the requester is an admin for any of the user's current organizations
      function isUserAdmin() {
        return isAdminForAnyOrgType({
          'districts': resource.data.get(['districts', 'current'], []),
          'schools': resource.data.get(['schools', 'current'], []),
          'classes': resource.data.get(['classes', 'current'], []),
          'groups': resource.data.get(['groups', 'current'], [])
        });
      }

      // Allow users to read their own data
      // Also allow admins to read data for their users
      // Allow parents to read their child's data
      allow read: if myData() || isUserAdmin() || isParentOfUser();

      // User creation validation functions
      // Ensure at most one district and school in request
      function hasValidOrgStructure() {
        let data = request.resource.data;
        return data.get(['districts', 'current'], []).size() <= 1
          && data.get(['schools', 'current'], []).size() <= 1;
      }

      // Validate that the admin has permission for the org type and only allowed keys are present
      function isValidAdminAction(orgType, allowedKeys) {
        return isAdminForOrgType(orgType, request.resource.data.get([orgType, 'current'], []))
          && request.resource.data.keys().hasOnly(allowedKeys);
      }

      // Creating a new user:
      // The requestor must be an admin for the target user's organization
      // Different org types have different allowed fields
      allow create: if loggedIn() && hasValidOrgStructure() && (
        // District admin creating user
        isValidAdminAction('districts', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'districts', 'schools', 'classes', 'assessmentUid'])
        // School admin creating user
        || isValidAdminAction('schools', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'districts', 'schools', 'classes', 'assessmentUid'])
        // Class admin creating user
        || isValidAdminAction('classes', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'districts', 'schools', 'classes', 'assessmentUid'])
        // Group admin creating user (no educational orgs can be set)
        || isValidAdminAction('groups', ['userType', 'name', 'assessmentPid', 'studentData', 'educatorData', 'caregiverData', 'adminData',
'groups', 'assessmentUid'])
      );

      // Updating an existing user:
      // Users can update their own data
      // Admins can update users in their organizations
      // Cannot update archived or assessmentUid fields
      allow update: if (myData() || isUserAdmin()) && keysNotUpdated(['archived', 'assessmentUid']);

      // Users can read and write their own survey responses
      match /surveyResponses/{responseId} {
        allow read, write: if myData();
      }

      // External data is read-only for users and their admins
      // Writes only through cloud functions with admin SDK
      match /externalData/{externalDataId} {
        allow read: if loggedIn() && (myData() || isUserAdmin());
        allow write: if false;
      }

      // Users should be able to read and write to their own assignments
      // Admins should be able to read (not write) assignments if they are an admin for one of the assigning orgs
      // N.B. This assumes that the assigningOrgs are exhaustively listed
      match /assignments/{administrationId} {
        function canReadAssignment() {
          return loggedIn() && (myData() || isAdminForAnyOrgType(resource.data.get('assigningOrgs', {})));
        }

        allow read: if canReadAssignment();
        // Only allow assignment creation in cloud functions using the admin SDK
        allow create: if false;
        // Users can update their own assignments but cannot change assigningOrgs or the number of assessments
        allow update: if myData() && keysNotUpdated(['assigningOrgs'])
          && request.resource.data.get('assessments', []).size() == resource.data.get('assessments', []).size();
      }

      // Runs represent assessment sessions
      match /runs/{runId} {
        function canReadRun() {
          return loggedIn() && (myData()
            || isAdminForAnyOrgType(resource.data.get('assigningOrgs', {}))
            || isAdminForAnyOrgType(resource.data.get('readOrgs', {})));
        }

        allow read: if canReadRun();
        allow create: if myData();
        allow update: if myData();

        // Trials represent individual assessment attempts within a run
        // N.B. This assumes that the assigningOrgs are exhaustively listed
        match /trials/{trialId} {
          function canReadTrial() {
            // Must read parent run document to check assigningOrgs
            let runData = get(/databases/$(database)/documents/users/$(uid)/runs/$(runId)).data;
            return loggedIn() && (myData()
              || isAdminForAnyOrgType(runData.get('assigningOrgs', {}))
              || isAdminForAnyOrgType(runData.get('readOrgs', {})));
          }

          allow read: if canReadTrial();
          allow write: if myData();
        }
      }
    }

    // ============ GROUP ASSIGNMENTS ============
    // Security rules for collection GROUP assignments
    // Admins can read assignments for organizations they administer
    match /{path=**}/assignments/{assignmentId} {
      allow read: if loggedIn() && isAdminForAnyOrgType(resource.data.get('assigningOrgs', {}));
    }

    // ============ ADMINISTRATIONS ============
    // Allow users to read any administration that:
    // - they created
    // - they are assigned to
    // - they are an admin for any of the assigned organizations
    // N.B. This assumes that the assigningOrgs are exhaustively listed
    match /administrations/{administrationId} {
      // Check if user is assigned to this administration through their organizations
      function userAssignedToAdministration() {
        let userData = get(/databases/$(database)/documents/users/$(getUid())).data;
        return userData.get(['districts', 'current'], []).hasAny(resource.data.districts)
          || userData.get(['schools', 'current'], []).hasAny(resource.data.schools)
          || userData.get(['classes', 'current'], []).hasAny(resource.data.classes)
          || userData.get(['groups', 'current'], []).hasAny(resource.data.groups)
      }

      // Check if user created this administration
      function userCreatedAdministration() {
        return getUid() == resource.data.get('createdBy', 'nullId');
      }

      allow read: if loggedIn() && (userAssignedToAdministration() || userCreatedAdministration() || isAdminForAnyOrgType(resource.data));
      // Only allow creation if user is recorded as creator and is admin for assigned orgs
      allow create: if loggedIn() && getUid() == request.resource.data.createdBy && isAdminForAnyOrgType(request.resource.data);
      // Allow updates from creator or admins, but prohibit modification of createdBy field
      allow update: if loggedIn() && (userCreatedAdministration() || isAdminForAnyOrgType(resource.data)) && keysNotUpdated(['createdBy']);
      // Prohibit deletion by anyone except super_admins (handled by catch-all rule above)
      allow delete: if false;

      // Administration statistics subcollection
      match /stats/completion {
        allow read: if loggedIn() && (userCreatedAdministration() ||
          isAdminForAnyOrgType(get(/databases/$(database)/documents/administrations/$(administrationId)).data));
        allow write: if false;
      }
    }

    // ============ ORG COLLECTIONS (Districts, Schools, Classes, Groups) ============
    // Helper function to get user's current organizations
    function getUserOrgs(orgType) {
      return get(/databases/$(database)/documents/users/$(getUid())).data.get([orgType, 'current'], []);
    }

    // Anyone in a district can read that district's info
    // Only super_admins can write districts
    match /districts/{districtId} {
      allow read: if loggedIn() && (districtId in getUserOrgs('districts') || isAdminForOrgType('districts', [districtId]));
      allow write: if false;
    }

    // Anyone in a school can read that school's info
    // Only district level admins can write to schools if the school is in their district
    match /schools/{schoolId} {
      allow read: if schoolId in getUserOrgs('schools') || isAdminForOrgType('schools', [schoolId]) ||
        isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')]);
      allow create: if isAdminForOrgType('districts', [request.resource.data.get('districtId', 'nullId')]);
      allow update, delete: if isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')]);
    }

    // Anyone in a class can read that class's info
    // Only school or district level admins can write to classes if the class is in their school or district
    match /classes/{classId} {
      allow read: if classId in getUserOrgs('classes') || isAdminForOrgType('classes', [classId])
        || isAdminForOrgType('schools', [resource.data.get('schoolId', 'nullId')])
        || isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')]);
      allow create: if isAdminForOrgType('districts', [request.resource.data.get('districtId', 'nullId')])
        || isAdminForOrgType('schools', [request.resource.data.get('schoolId', 'nullId')]);
      allow update, delete: if isAdminForOrgType('districts', [resource.data.get('districtId', 'nullId')])
        || isAdminForOrgType('schools', [resource.data.get('schoolId', 'nullId')]);
    }

    // Anyone in a group can read that group's info
    // Anyone who is an admin for this group can write to it
    match /groups/{groupId} {
      allow read: if loggedIn() && (groupId in getUserOrgs('groups') || isAdminForOrgType('groups', [groupId]));
      allow write: if isAdminForOrgType('groups', [groupId]);
    }

    // ============ GUESTS ============
    // We allow anonymous guest access so that people can try an individual
    // task without having to create a dashboard account.
    // Use cases:
    // - Users may want to try out LEVANTE before creating an account
    // - App developers may want to pilot new apps or features without deploying to the dashboard
    // - External lab partners may want to use LEVANTE tasks without the dashboard -- TODO: Remove
    //
    // We restrict all read access to guest documents. Only super_admins and the admin SDK can read them.
    // We will rely on cloud functions using the admin SDK to export this data to the labs.
    match /guests/{guestUid} {
      function isGuest() {
        return loggedIn() && request.auth.uid == guestUid;
      }

      allow read: if isGuest();
      allow create: if isGuest() && request.resource.data.get('userType', 'nullType') == 'guest';
      allow update: if isGuest() && keysNotUpdated(['userType']);
      allow delete: if false;

      match /runs/{runId} {
        // Guest runs are write-only for privacy
        allow read: if false;
        allow create, update: if isGuest();
        allow delete: if false;

        match /trials/{trialId} {
          // Guest trials are write-only for privacy
          allow read: if false;
          allow create, update: if isGuest();
          allow delete: if false;
        }
      }
    }

    // ============ TASKS ============
    // Tasks and variants are free for any authenticated user to read and create
    // Updates are only allowed for certain fields
    // Only super_admins can update the `registered` field
    match /tasks/{taskId} {
      function canUpdateTask() {
        let newParams = request.resource.data.get("params", {});
        let oldParams = resource.data.get("params", {});
        // Ensure no params are added or removed, only values can be updated
        return loggedIn()
          && keysNotUpdated(['registered'])
          && onlyTheseKeysUpdated(['description', 'lastUpdated', 'params', "createdAt", "updatedAt"])
          && newParams.diff(oldParams).addedKeys().size() == 0
          && newParams.diff(oldParams).removedKeys().size() == 0;
      }

      allow read: if loggedIn();
      // Cannot create with 'registered' field - that's admin only
      allow create: if loggedIn() && !request.resource.data.keys().hasAny(['registered']);
      allow update: if canUpdateTask();

      match /variants/{variantId} {
        allow read: if loggedIn();
        allow create: if loggedIn() && !request.resource.data.keys().hasAny(['registered']);
        allow update: if canUpdateTask();
      }
    }
  }
}
