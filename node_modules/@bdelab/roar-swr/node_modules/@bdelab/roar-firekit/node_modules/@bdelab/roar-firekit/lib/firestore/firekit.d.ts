import { DocumentData, DocumentReference, Transaction } from 'firebase/firestore';
import { AuthPersistence, MarkRawConfig } from './util';
import { Assessment, ExternalUserData, FirebaseProject, Name, RoarOrg, OrgLists, RoarConfig, UserDataInAdminDb, OrgCollectionName } from './interfaces';
import { UserInput } from './app/user';
import { RoarAppkit } from './app/appkit';
import { TaskVariantInfo, RoarTaskVariant } from './app/task';
declare enum AuthProviderType {
    CLEVER = "clever",
    CLASSLINK = "classlink",
    GOOGLE = "google",
    EMAIL = "email",
    USERNAME = "username"
}
interface CreateUserInput {
    dob: string;
    grade: string;
    pid?: string;
    ell_status?: boolean;
    iep_status?: boolean;
    frl_status?: boolean;
    state_id?: string;
    gender?: string;
    hispanic_ethnicity?: string;
    race?: string[];
    home_language?: string[];
    name?: {
        first?: string;
        middle?: string;
        last?: string;
    };
    username?: string;
    school: {
        id: string;
        abbreviation?: string;
    } | null;
    district: {
        id: string;
        abbreviation?: string;
    } | null;
    class: {
        id: string;
        abbreviation?: string;
    } | null;
    family: {
        id: string;
        abbreviation?: string;
    } | null;
    group: {
        id: string;
        abbreviation?: string;
    } | null;
}
interface CreateParentInput {
    name: {
        first: string;
        last: string;
    };
}
export interface ChildData {
    email: string;
    password: string;
    userData: CreateUserInput;
    familyId: string;
    orgCode: string;
}
interface CurrentAssignments {
    assigned: string[];
    started: string[];
    completed: string[];
}
export interface RequestConfig {
    headers: {
        Authorization: string;
    };
    baseURL: string;
}
interface LevanteUserData {
    id: string;
    userType: string;
    childId: string;
    parentId: string;
    teacherId: string;
    month: string;
    year: string;
    group: string[];
}
interface LevanteSurveyResponses {
    [key: string]: string;
}
export declare class RoarFirekit {
    admin?: FirebaseProject;
    app?: FirebaseProject;
    currentAssignments?: CurrentAssignments;
    oAuthAccessToken?: string;
    roarAppUserInfo?: UserInput;
    roarConfig: RoarConfig;
    userData?: UserDataInAdminDb;
    listenerUpdateCallback: (...args: unknown[]) => void;
    private _idTokenReceived?;
    private _idTokens;
    private _adminOrgs?;
    private _authPersistence;
    private _initialized;
    private _markRawConfig;
    private _superAdmin?;
    private _verboseLogging?;
    private _adminTokenListener?;
    private _appTokenListener?;
    private _adminClaimsListener?;
    /**
     * Create a RoarFirekit. This expects an object with keys `roarConfig`,
     * where `roarConfig` is a [[RoarConfig]] object.
     * @param {{roarConfig: RoarConfig }=} destructuredParam
     *     roarConfig: The ROAR firebase config object
     */
    constructor({ roarConfig, verboseLogging, authPersistence, markRawConfig, listenerUpdateCallback, }: {
        roarConfig: RoarConfig;
        dbPersistence: boolean;
        authPersistence?: AuthPersistence;
        markRawConfig?: MarkRawConfig;
        verboseLogging: boolean;
        listenerUpdateCallback?: (...args: unknown[]) => void;
    });
    private _getProviderIds;
    private _scrubAuthProperties;
    init(): Promise<this>;
    private verboseLog;
    get initialized(): boolean;
    private _verifyInit;
    private _isAuthenticated;
    isAdmin(): boolean;
    private _verifyAuthentication;
    private _verifyAdmin;
    private _listenToClaims;
    private _listenToTokenChange;
    private _setUidCustomClaims;
    private _syncEduSSOUser;
    isUsernameAvailable(username: string): Promise<boolean>;
    isEmailAvailable(email: string): Promise<boolean>;
    fetchEmailAuthMethods(email: string): Promise<string[]>;
    isRoarAuthEmail(email: string): boolean;
    registerWithEmailAndPassword({ email, password }: {
        email: string;
        password: string;
    }): Promise<import("@firebase/functions").HttpsCallableResult<unknown>>;
    logInWithEmailAndPassword({ email, password }: {
        email: string;
        password: string;
    }): Promise<import("@firebase/functions").HttpsCallableResult<unknown>>;
    logInWithUsernameAndPassword({ username, password }: {
        username: string;
        password: string;
    }): Promise<import("@firebase/functions").HttpsCallableResult<unknown>>;
    initiateLoginWithEmailLink({ email, redirectUrl }: {
        email: string;
        redirectUrl: string;
    }): Promise<void>;
    isSignInWithEmailLink(emailLink: string): Promise<boolean>;
    signInWithEmailLink({ email, emailLink }: {
        email: string;
        emailLink: string;
    }): Promise<import("@firebase/functions").HttpsCallableResult<unknown> | undefined>;
    signInWithPopup(provider: AuthProviderType): Promise<void>;
    initiateRedirect(provider: AuthProviderType): Promise<never>;
    signInFromRedirectResult(enableCookiesCallback: () => void): Promise<{
        status: string;
    } | null>;
    private _signOutApp;
    private _signOutAdmin;
    signOut(): Promise<void>;
    get superAdmin(): boolean | undefined;
    get idTokenReceived(): boolean | undefined;
    get idTokens(): {
        admin?: string | undefined;
        app?: string | undefined;
    };
    restConfig(): {
        admin: {
            headers: {
                Authorization: string;
            };
            baseURL: string;
        };
        app: {
            headers: {
                Authorization: string;
            };
            baseURL: string;
        };
    };
    get adminOrgs(): Record<string, string[]> | undefined;
    get dbRefs(): {
        admin: {
            user: DocumentReference<DocumentData>;
            assignments: import("@firebase/firestore").CollectionReference<DocumentData>;
        };
        app: {
            user: DocumentReference<DocumentData>;
            runs: import("@firebase/firestore").CollectionReference<DocumentData>;
            tasks: import("@firebase/firestore").CollectionReference<DocumentData>;
        };
    } | undefined;
    private _getUser;
    getMyData(): Promise<void>;
    getLegalDoc(docName: string): Promise<{
        text: string;
        version: any;
    } | null>;
    updateConsentStatus(docName: string, consentVersion: string): Promise<void>;
    updateVideoMetadata(administrationId: string, taskId: string, status: string): Promise<void>;
    get roarUid(): string | undefined;
    startAssignment(administrationId: string, transaction?: Transaction): Promise<void | Transaction>;
    completeAssignment(administrationId: string, transaction?: Transaction): Promise<void | Transaction>;
    private _updateAssignedAssessment;
    startAssessment(administrationId: string, taskId: string, taskVersion: string): Promise<RoarAppkit>;
    completeAssessment(administrationId: string, taskId: string): Promise<void>;
    updateAssessmentRewardShown(administrationId: string, taskId: string): Promise<void>;
    /**
     * Create or update an administration
     *
     * @param input input object
     * @param input.name The administration name
     * @param input.assessments The list of assessments for this administration
     * @param input.dateOpen The start date for this administration
     * @param input.dateClose The end date for this administration
     * @param input.sequential Whether or not the assessments in this
     *                         administration must be taken sequentially
     * @param input.orgs The orgs assigned to this administration
     * @param input.tags Metadata tags for this administration
     * @param input.administrationId Optional ID of an existing administration. If
     *                               provided, this method will update an
     *                               existing administration.
     */
    createAdministration({ name, publicName, assessments, dateOpen, dateClose, sequential, orgs, tags, administrationId, isTestData, }: {
        name: string;
        publicName?: string;
        assessments: Assessment[];
        dateOpen: Date;
        dateClose: Date;
        sequential: boolean;
        orgs: OrgLists;
        tags: string[];
        administrationId?: string;
        isTestData: boolean;
    }): Promise<void>;
    /**
     * Delete an administration
     *
     * @param administrationId The administration ID to delete
     */
    deleteAdministration(administrationId: string): Promise<void>;
    assignAdministrationToOrgs(administrationId: string, orgs?: OrgLists): Promise<void>;
    unassignAdministrationToOrgs(administrationId: string, orgs?: OrgLists): Promise<void>;
    updateUserExternalData(uid: string, externalResourceId: string, externalData: ExternalUserData): Promise<void>;
    createStudentWithEmailPassword(email: string, password: string, userData: CreateUserInput): Promise<void>;
    createNewFamily(caretakerEmail: string, caretakerPassword: string, caretakerUserData: CreateParentInput, children: ChildData[], isTestData?: boolean): Promise<void>;
    createStudentWithUsernamePassword(username: string, password: string, userData: CreateUserInput): Promise<void>;
    createAdministrator(email: string, name: Name, targetOrgs: OrgLists, targetAdminOrgs: OrgLists, isTestData?: boolean): Promise<void>;
    syncCleverOrgs(shallow?: boolean): Promise<void>;
    /**
     * Create or update an organization.
     *
     * @param orgsCollection The type of organization to create or update.
     * @param orgData The organization data to create or update.
     * @param isTestData Whether or not this is a test org.
     * @param isDemoData Whether or not this is a demo org.
     * @param organizationId Optional ID of an existing org. If provided, this
     *                       method will update an existing org.
     * @returns The newly created or updated organization ID.
     */
    createOrg(orgsCollection: OrgCollectionName, orgData: RoarOrg, isTestData?: boolean, isDemoData?: boolean, organizationId?: string): Promise<string>;
    /**
     * Delete an organization.
     *
     * @param recursive
     * @param orgsCollection The type of organization to create or update.
     * @param orgId The ID of the organization to delete.
     * @param recursive if true, recursively delete all children of this org.
     *                  Default is true.
     */
    deleteOrg(orgsCollection: OrgCollectionName, orgId: string, recursive?: boolean): Promise<void>;
    registerTaskVariant({ taskId, taskName, taskDescription, taskImage, taskURL, variantName, variantDescription, variantParams, testData, demoData, }: TaskVariantInfo): Promise<RoarTaskVariant>;
    createLevanteUsersWithEmailPassword(userData: LevanteUserData): Promise<import("@firebase/functions").HttpsCallableResult<unknown>>;
    saveSurveyResponses(surveyResponses: LevanteSurveyResponses): Promise<import("@firebase/functions").HttpsCallableResult<unknown>>;
    createLevanteGroup(groupData: RoarOrg): Promise<import("@firebase/functions").HttpsCallableResult<unknown>>;
}
export {};
