"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoarFirekit = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const get_1 = __importDefault(require("lodash/get"));
const set_1 = __importDefault(require("lodash/set"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const nth_1 = __importDefault(require("lodash/nth"));
const union_1 = __importDefault(require("lodash/union"));
const auth_1 = require("firebase/auth");
const firestore_1 = require("firebase/firestore");
const functions_1 = require("firebase/functions");
const auth_2 = require("../auth");
const util_1 = require("./util");
const interfaces_1 = require("./interfaces");
const appkit_1 = require("./app/appkit");
const query_assessment_1 = require("./query-assessment");
const task_1 = require("./app/task");
var AuthProviderType;
(function (AuthProviderType) {
    AuthProviderType["CLEVER"] = "clever";
    AuthProviderType["CLASSLINK"] = "classlink";
    AuthProviderType["GOOGLE"] = "google";
    AuthProviderType["EMAIL"] = "email";
    AuthProviderType["USERNAME"] = "username";
})(AuthProviderType || (AuthProviderType = {}));
class RoarFirekit {
    /**
     * Create a RoarFirekit. This expects an object with keys `roarConfig`,
     * where `roarConfig` is a [[RoarConfig]] object.
     * @param {{roarConfig: RoarConfig }=} destructuredParam
     *     roarConfig: The ROAR firebase config object
     */
    constructor({ roarConfig, verboseLogging = false, authPersistence = util_1.AuthPersistence.session, markRawConfig = {}, listenerUpdateCallback, }) {
        this.roarConfig = roarConfig;
        this._verboseLogging = verboseLogging;
        this._authPersistence = authPersistence;
        this._markRawConfig = markRawConfig;
        this._initialized = false;
        this._idTokens = {};
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.listenerUpdateCallback = listenerUpdateCallback !== null && listenerUpdateCallback !== void 0 ? listenerUpdateCallback : (() => { });
    }
    _getProviderIds() {
        return Object.assign(Object.assign({}, auth_1.ProviderId), { CLEVER: 'oidc.clever', CLASSLINK: 'oidc.classlink', ROAR_ADMIN_PROJECT: `oidc.${this.roarConfig.admin.projectId}` });
    }
    _scrubAuthProperties() {
        this.userData = undefined;
        this.roarAppUserInfo = undefined;
        this._adminOrgs = undefined;
        this._superAdmin = undefined;
        this.currentAssignments = undefined;
        this.oAuthAccessToken = undefined;
        this._adminClaimsListener = undefined;
        this._adminTokenListener = undefined;
        this._appTokenListener = undefined;
        this._idTokens = {};
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.app = yield (0, util_1.initializeFirebaseProject)(this.roarConfig.app, 'app', this._authPersistence, this._markRawConfig);
            this.admin = yield (0, util_1.initializeFirebaseProject)(this.roarConfig.admin, 'admin', this._authPersistence, this._markRawConfig);
            this._initialized = true;
            (0, auth_1.onAuthStateChanged)(this.admin.auth, (user) => {
                this.verboseLog('onAuthStateChanged triggered for admin auth');
                if (this.admin) {
                    if (user) {
                        this.verboseLog('admin firebase instance and user are defined');
                        this.admin.user = user;
                        this._adminClaimsListener = this._listenToClaims(this.admin);
                        this.verboseLog('adminClaimsListener instance set up using listenToClaims');
                        this._adminTokenListener = this._listenToTokenChange(this.admin, 'admin');
                        this.verboseLog('adminTokenListener instance set up using listenToClaims');
                        this.verboseLog('[admin] Attempting to fire user.getIdToken(), existing token is', this._idTokens.admin);
                        user.getIdToken().then((idToken) => {
                            this.verboseLog('in .then() for user.getIdToken() with new token', idToken);
                            this._idTokens.admin = idToken;
                            this.verboseLog(`Updated internal admin token to ${idToken}`);
                        });
                    }
                    else {
                        this.verboseLog('User for admin is undefined.');
                        this.admin.user = undefined;
                    }
                }
                this.verboseLog('[admin] Call this.listenerUpdateCallback()');
                this.listenerUpdateCallback();
            });
            (0, auth_1.onAuthStateChanged)(this.app.auth, (user) => {
                this.verboseLog('onAuthStateChanged triggered for assessment auth');
                if (this.app) {
                    if (user) {
                        this.verboseLog('assessment firebase instance and user are defiend');
                        this.app.user = user;
                        this._appTokenListener = this._listenToTokenChange(this.app, 'app');
                        this.verboseLog('appTokenListener instance set up using listenToTokenChange');
                        this.verboseLog('[app] Attempting to fire user.getIdToken() from app , existing token is', this._idTokens.app);
                        user.getIdToken().then((idToken) => {
                            this.verboseLog('in .then() for user.getItToken() with new token', idToken);
                            this._idTokens.app = idToken;
                            this.verboseLog('Updated internal app token to', idToken);
                        });
                    }
                    else {
                        this.verboseLog('User for app is undefined');
                        this.app.user = undefined;
                    }
                }
                this.verboseLog('[app] Call this.listenerUpdateCallback()');
                this.listenerUpdateCallback();
            });
            return this;
        });
    }
    verboseLog(...logStatement) {
        if (this._verboseLogging) {
            console.log('[RoarFirekit] ', ...logStatement);
        }
        else
            return;
    }
    //           +--------------------------------+
    // ----------|  Begin Authentication Methods  |----------
    //           +--------------------------------+
    get initialized() {
        return this._initialized;
    }
    _verifyInit() {
        if (!this._initialized) {
            throw new Error('RoarFirekit has not been initialized. Use the `init` method.');
        }
    }
    _isAuthenticated() {
        this._verifyInit();
        return !(this.admin.user === undefined || this.app.user === undefined);
    }
    isAdmin() {
        if (this.superAdmin)
            return true;
        if (this._adminOrgs === undefined)
            return false;
        if ((0, isEmpty_1.default)((0, union_1.default)(...Object.values(this._adminOrgs))))
            return false;
        return true;
    }
    _verifyAuthentication() {
        this._verifyInit();
        if (!this._isAuthenticated()) {
            throw new Error('User is not authenticated.');
        }
    }
    _verifyAdmin() {
        this._verifyAuthentication();
        if (!this.isAdmin()) {
            throw new Error('User is not an administrator.');
        }
    }
    _listenToClaims(firekit) {
        this.verboseLog('entry point to listenToClaims');
        this._verifyInit();
        if (firekit.user) {
            this.verboseLog('firekit.user is defined');
            let unsubscribe;
            this.verboseLog('About to try setting up the claims listener');
            try {
                this.verboseLog('Beginning onSnapshot definition');
                unsubscribe = (0, firestore_1.onSnapshot)((0, firestore_1.doc)(firekit.db, 'userClaims', firekit.user.uid), (doc) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    this.verboseLog('In onSnapshot call for listenToClaims');
                    const data = doc.data();
                    this._adminOrgs = (_a = data === null || data === void 0 ? void 0 : data.claims) === null || _a === void 0 ? void 0 : _a.adminOrgs;
                    this._superAdmin = (_b = data === null || data === void 0 ? void 0 : data.claims) === null || _b === void 0 ? void 0 : _b.super_admin;
                    this.verboseLog('data, adminOrgs, superAdmin are retrieved from doc.data()');
                    this.verboseLog('about to check for existance of data.lastUpdated');
                    if (data === null || data === void 0 ? void 0 : data.lastUpdated) {
                        this.verboseLog('lastUpdate exists.');
                        const lastUpdated = new Date(data.lastUpdated);
                        this.verboseLog('Checking for firekit.claimsLastUpdated existance or outdated (< lastUpdated from retrieved data)');
                        if (!firekit.claimsLastUpdated || lastUpdated > firekit.claimsLastUpdated) {
                            this.verboseLog("Firekit's last updated either does not exist or is outdated. Await getIdToken and update firekit's claimsLastUpdated field.");
                            // Update the user's ID token and refresh claimsLastUpdated.
                            yield (0, auth_1.getIdToken)(firekit.user, true);
                            firekit.claimsLastUpdated = lastUpdated;
                        }
                    }
                    this.verboseLog('Call listenerUpdateCallback from listenToClaims');
                    this.listenerUpdateCallback();
                }), (error) => {
                    throw error;
                });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            catch (error) {
                this.verboseLog('Attempt to set up claims listener failed. Error is', error);
                if (error.code !== 'permission-denied') {
                    throw error;
                }
            }
            return unsubscribe;
        }
    }
    _listenToTokenChange(firekit, _type) {
        this.verboseLog('Entry point for listenToTokenChange, called with', _type);
        this._verifyInit();
        this.verboseLog('Checking for existance of tokenListener with type', _type);
        if ((!this._adminTokenListener && _type === 'admin') || (!this._appTokenListener && _type === 'app')) {
            this.verboseLog('Token listener does not exist, create now.');
            return (0, auth_1.onIdTokenChanged)(firekit.auth, (user) => __awaiter(this, void 0, void 0, function* () {
                this.verboseLog('onIdTokenChanged body');
                if (user) {
                    this.verboseLog('user exists, await user.getIdTokenResult(false)');
                    const idTokenResult = yield user.getIdTokenResult(false);
                    this.verboseLog('Returned with token', idTokenResult);
                    if (_type === 'admin') {
                        this.verboseLog('Type is admin, set idTokenRecieved flag');
                        this._idTokenReceived = true;
                    }
                    this.verboseLog(`Setting idTokens.${_type} to token`, idTokenResult.token);
                    this._idTokens[_type] = idTokenResult.token;
                }
                this.verboseLog('Calling listenerUpdateCallback from listenToTokenChange', _type);
                this.listenerUpdateCallback();
            }));
        }
        else if (_type === 'admin') {
            this.verboseLog('Type is admin, invoking _adminTokenListener');
            return this._adminTokenListener;
        }
        this.verboseLog('Type is app, invoking _appTokenListener');
        return this._appTokenListener;
    }
    _setUidCustomClaims() {
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point to setUidCustomClaims');
            this._verifyAuthentication();
            this.verboseLog('Calling cloud function for setAdminUidClaims');
            const setAdminUidClaims = (0, functions_1.httpsCallable)(this.admin.functions, 'setuidclaims');
            const adminResult = yield setAdminUidClaims({ assessmentUid: this.app.user.uid });
            this.verboseLog('setAdminUidClaims returned with result', adminResult);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if ((0, get_1.default)(adminResult.data, 'status') !== 'ok') {
                this.verboseLog('Error in calling setAdminUidClaims cloud function', adminResult.data);
                throw new Error('Failed to associate admin and assessment UIDs in the admin Firebase project.');
            }
            this.verboseLog('Calling cloud function for setAppUidClaims');
            const setAppUidClaims = (0, functions_1.httpsCallable)(this.app.functions, 'setuidclaims');
            const appResult = yield setAppUidClaims({ adminUid: this.admin.user.uid, roarUid: this.roarUid });
            this.verboseLog('setAppUidCustomClaims returned with results', appResult);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if ((0, get_1.default)(appResult.data, 'status') !== 'ok') {
                this.verboseLog('Error in calling setAppUidClaims cloud function', appResult.data);
                throw new Error('Failed to associate admin and assessment UIDs in the app Firebase project.');
            }
            this.verboseLog('Returning appResult from setUidCustomClaims', appResult);
            return appResult;
        });
    }
    _syncEduSSOUser(oAuthAccessToken, authProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point for syncEduSSOUser');
            if (authProvider === AuthProviderType.CLEVER) {
                if (oAuthAccessToken === undefined) {
                    this.verboseLog('Not OAuth token provided.');
                    throw new Error('No OAuth access token provided.');
                }
                this._verifyAuthentication();
                this.verboseLog('Calling syncEduSSOUser cloud function [Clever]');
                const syncCleverUser = (0, functions_1.httpsCallable)(this.admin.functions, 'syncCleverUser');
                const adminResult = yield syncCleverUser({
                    assessmentUid: this.app.user.uid,
                    accessToken: oAuthAccessToken,
                });
                this.verboseLog('syncCleverUser cloud function returned with result', adminResult);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if ((0, get_1.default)(adminResult.data, 'status') !== 'ok') {
                    this.verboseLog('There was an error with the cloud function syncCleverUser cloud function', adminResult.data);
                    throw new Error('Failed to sync Clever and ROAR data.');
                }
            }
            else if (authProvider === AuthProviderType.CLASSLINK) {
                this.verboseLog('Calling syncEduSSOUser cloud function [ClassLink]');
                if (oAuthAccessToken === undefined) {
                    this.verboseLog('Not OAuth token provided.');
                    throw new Error('No OAuth access token provided.');
                }
                this._verifyAuthentication();
                this.verboseLog('Calling syncClassLinkUser cloud function');
                const syncClassLinkUser = (0, functions_1.httpsCallable)(this.admin.functions, 'syncClassLinkUser');
                const adminResult = yield syncClassLinkUser({
                    assessmentUid: this.app.user.uid,
                    accessToken: oAuthAccessToken,
                });
                this.verboseLog('syncClassLinkUser cloud function returned with result', adminResult);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if ((0, get_1.default)(adminResult.data, 'status') !== 'ok') {
                    this.verboseLog('There was an error with the cloud function syncClassLinkUser cloud function', adminResult.data);
                    throw new Error('Failed to sync ClassLink and ROAR data.');
                }
            }
        });
    }
    isUsernameAvailable(username) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_2.isUsernameAvailable)(this.admin.auth, username);
        });
    }
    isEmailAvailable(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_2.isEmailAvailable)(this.admin.auth, email);
        });
    }
    fetchEmailAuthMethods(email) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_2.fetchEmailAuthMethods)(this.admin.auth, email);
        });
    }
    isRoarAuthEmail(email) {
        this._verifyInit();
        return (0, auth_2.isRoarAuthEmail)(email);
    }
    registerWithEmailAndPassword({ email, password }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.createUserWithEmailAndPassword)(this.admin.auth, email, password)
                .catch((error) => {
                console.log('Error creating user', error);
                console.log(error.code);
                console.log(error.message);
                throw error;
            })
                .then(() => {
                return (0, auth_1.createUserWithEmailAndPassword)(this.app.auth, email, password).then(this._setUidCustomClaims.bind(this));
            });
        });
    }
    logInWithEmailAndPassword({ email, password }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.signInWithEmailAndPassword)(this.admin.auth, email, password)
                .then(() => {
                return (0, auth_1.signInWithEmailAndPassword)(this.app.auth, email, password)
                    .then(this._setUidCustomClaims.bind(this))
                    .catch((error) => {
                    console.error('(Inside) Error signing in', error);
                    throw error;
                });
            })
                .catch((error) => {
                console.error('(Outside) Error signing in', error);
                throw error;
            });
        });
    }
    logInWithUsernameAndPassword({ username, password }) {
        return __awaiter(this, void 0, void 0, function* () {
            const email = (0, auth_2.roarEmail)(username);
            return this.logInWithEmailAndPassword({ email, password });
        });
    }
    initiateLoginWithEmailLink({ email, redirectUrl }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            const actionCodeSettings = {
                url: redirectUrl,
                handleCodeInApp: true,
            };
            return (0, auth_1.sendSignInLinkToEmail)(this.admin.auth, email, actionCodeSettings);
        });
    }
    isSignInWithEmailLink(emailLink) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.isSignInWithEmailLink)(this.admin.auth, emailLink);
        });
    }
    signInWithEmailLink({ email, emailLink }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            return (0, auth_1.signInWithEmailLink)(this.admin.auth, email, emailLink)
                .then((userCredential) => __awaiter(this, void 0, void 0, function* () {
                const roarProviderIds = this._getProviderIds();
                const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                const roarAdminIdToken = yield (0, auth_1.getIdToken)(userCredential.user);
                const roarAdminCredential = roarAdminProvider.credential({
                    idToken: roarAdminIdToken,
                });
                return roarAdminCredential;
            }))
                .then((credential) => {
                if (credential) {
                    return (0, auth_1.signInWithCredential)(this.app.auth, credential);
                }
            })
                .then((credential) => {
                if (credential) {
                    return this._setUidCustomClaims();
                }
            });
        });
    }
    signInWithPopup(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            const allowedProviders = [AuthProviderType.GOOGLE, AuthProviderType.CLEVER, AuthProviderType.CLASSLINK];
            let authProvider;
            if (provider === AuthProviderType.GOOGLE) {
                authProvider = new auth_1.GoogleAuthProvider();
            }
            else if (provider === AuthProviderType.CLEVER) {
                const roarProviderIds = this._getProviderIds();
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLEVER);
            }
            else if (provider === AuthProviderType.CLASSLINK) {
                const roarProviderIds = this._getProviderIds();
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLASSLINK);
            }
            else {
                throw new Error(`provider must be one of ${allowedProviders.join(', ')}. Received ${provider} instead.`);
            }
            const allowedErrors = ['auth/cancelled-popup-request', 'auth/popup-closed-by-user'];
            const swallowAllowedErrors = (error) => {
                if (!allowedErrors.includes(error.code)) {
                    throw error;
                }
            };
            let oAuthAccessToken;
            return (0, auth_1.signInWithPopup)(this.admin.auth, authProvider)
                .then((adminUserCredential) => __awaiter(this, void 0, void 0, function* () {
                if (provider === AuthProviderType.GOOGLE) {
                    const credential = auth_1.GoogleAuthProvider.credentialFromResult(adminUserCredential);
                    // This gives you a Google Access Token. You can use it to access Google APIs.
                    // TODO: Find a way to put this in the onAuthStateChanged handler
                    oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                    return credential;
                }
                else if ([AuthProviderType.CLEVER, AuthProviderType.CLASSLINK].includes(provider)) {
                    const credential = auth_1.OAuthProvider.credentialFromResult(adminUserCredential);
                    // This gives you a Clever/Classlink Access Token. You can use it to access Clever/Classlink APIs.
                    oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                    const roarProviderIds = this._getProviderIds();
                    const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                    const roarAdminIdToken = yield (0, auth_1.getIdToken)(adminUserCredential.user);
                    const roarAdminCredential = roarAdminProvider.credential({
                        idToken: roarAdminIdToken,
                    });
                    return roarAdminCredential;
                }
            }))
                .catch(swallowAllowedErrors)
                .then((credential) => {
                if (credential) {
                    return (0, auth_1.signInWithCredential)(this.app.auth, credential).catch(swallowAllowedErrors);
                }
            })
                .then((credential) => {
                if (credential) {
                    return this._setUidCustomClaims();
                }
            })
                .then((setClaimsResult) => {
                if (setClaimsResult) {
                    this._syncEduSSOUser(oAuthAccessToken, provider);
                }
            });
        });
    }
    initiateRedirect(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verboseLog('Entry point for initiateRedirect');
            this._verifyInit();
            const allowedProviders = [AuthProviderType.GOOGLE, AuthProviderType.CLEVER, AuthProviderType.CLASSLINK];
            let authProvider;
            this.verboseLog('Attempting sign in with AuthProvider', provider);
            if (provider === AuthProviderType.GOOGLE) {
                authProvider = new auth_1.GoogleAuthProvider();
                this.verboseLog('Google AuthProvider object:', authProvider);
            }
            else if (provider === AuthProviderType.CLEVER) {
                const roarProviderIds = this._getProviderIds();
                this.verboseLog('Clever roarProviderIds', roarProviderIds);
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLEVER);
                this.verboseLog('Clever AuthProvider object:', authProvider);
            }
            else if (provider === AuthProviderType.CLASSLINK) {
                const roarProviderIds = this._getProviderIds();
                this.verboseLog('Classlink roarProviderIds', roarProviderIds);
                // Use the partner-initiated flow for Classlink
                authProvider = new auth_1.OAuthProvider(roarProviderIds.CLASSLINK);
                this.verboseLog('Classlink AuthProvider object:', authProvider);
            }
            else {
                throw new Error(`provider must be one of ${allowedProviders.join(', ')}. Received ${provider} instead.`);
            }
            this.verboseLog('Calling signInWithRedirect from initiateRedirect with provider', authProvider);
            return (0, auth_1.signInWithRedirect)(this.admin.auth, authProvider);
        });
    }
    signInFromRedirectResult(enableCookiesCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            this.verboseLog('Entry point for signInFromRedirectResult');
            const catchEnableCookiesError = (error) => {
                this.verboseLog('Catching error, checking if it is the enableCookies error');
                if (error.code == 'auth/web-storage-unsupported') {
                    this.verboseLog('Error was known enableCookies error, invoking enableCookiesCallback()');
                    enableCookiesCallback();
                }
                else {
                    this.verboseLog('It was not the known enableCookies error', error);
                    throw error;
                }
            };
            let oAuthAccessToken;
            let authProvider;
            this.verboseLog('calling getRedirect result from signInFromRedirect');
            return (0, auth_1.getRedirectResult)(this.admin.auth)
                .then((adminUserCredential) => __awaiter(this, void 0, void 0, function* () {
                this.verboseLog('Then block for getRedirectResult');
                if (adminUserCredential !== null) {
                    this.verboseLog('adminUserCredential is not null');
                    const providerId = adminUserCredential.providerId;
                    const roarProviderIds = this._getProviderIds();
                    this.verboseLog('providerId is', providerId);
                    this.verboseLog('roarProviderIds are', roarProviderIds);
                    if (providerId === roarProviderIds.GOOGLE) {
                        this.verboseLog('ProviderId is google, calling credentialFromResult with ', adminUserCredential);
                        const credential = auth_1.GoogleAuthProvider.credentialFromResult(adminUserCredential);
                        // This gives you a Google Access Token. You can use it to access Google APIs.
                        // TODO: Find a way to put this in the onAuthStateChanged handler
                        authProvider = AuthProviderType.GOOGLE;
                        oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                        this.verboseLog('oAuthAccessToken = ', oAuthAccessToken);
                        this.verboseLog('returning credential from first .then() ->', credential);
                        return credential;
                    }
                    else if ([roarProviderIds.CLEVER, roarProviderIds.CLASSLINK].includes(providerId !== null && providerId !== void 0 ? providerId : 'NULL')) {
                        this.verboseLog('ProviderId is clever, calling credentialFromResult with', adminUserCredential);
                        const credential = auth_1.OAuthProvider.credentialFromResult(adminUserCredential);
                        // This gives you a Clever/Classlink Access Token. You can use it to access Clever/Classlink APIs.
                        if (providerId === roarProviderIds.CLEVER) {
                            authProvider = AuthProviderType.CLEVER;
                        }
                        else if (providerId === roarProviderIds.CLASSLINK) {
                            authProvider = AuthProviderType.CLASSLINK;
                        }
                        oAuthAccessToken = credential === null || credential === void 0 ? void 0 : credential.accessToken;
                        this.verboseLog('authProvider is', authProvider);
                        this.verboseLog('oAuthAccesToken is', oAuthAccessToken);
                        const roarAdminProvider = new auth_1.OAuthProvider(roarProviderIds.ROAR_ADMIN_PROJECT);
                        this.verboseLog('Attempting to call getIdToken with', adminUserCredential.user);
                        const roarAdminIdToken = yield (0, auth_1.getIdToken)(adminUserCredential.user);
                        this.verboseLog('updated token is', roarAdminIdToken);
                        const roarAdminCredential = roarAdminProvider.credential({
                            idToken: roarAdminIdToken,
                        });
                        this.verboseLog(`Using new idToken ${roarAdminIdToken}, created new admin credential`, roarAdminCredential);
                        return roarAdminCredential;
                    }
                }
                return null;
            }))
                .catch(catchEnableCookiesError)
                .then((credential) => {
                this.verboseLog('Attempting sign in using credential', credential);
                if (credential) {
                    this.verboseLog('Calling signInWithCredential with creds', credential);
                    return (0, auth_1.signInWithCredential)(this.app.auth, credential);
                }
                return null;
            })
                .then((credential) => {
                this.verboseLog('Attempting to set uid custom claims using credential', credential);
                if (credential) {
                    this.verboseLog('Calling setUidCustomClaims with creds', credential);
                    return this._setUidCustomClaims();
                }
                return null;
            })
                .then((setClaimsResult) => {
                this.verboseLog('Claim result is', setClaimsResult);
                if (setClaimsResult) {
                    this.verboseLog('Calling syncEduSSOUser with oAuthAccessToken', oAuthAccessToken);
                    this._syncEduSSOUser(oAuthAccessToken, authProvider);
                    return { status: 'ok' };
                }
                return null;
            });
        });
    }
    _signOutApp() {
        return __awaiter(this, void 0, void 0, function* () {
            this._scrubAuthProperties();
            yield (0, auth_1.signOut)(this.app.auth);
        });
    }
    _signOutAdmin() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._adminClaimsListener)
                this._adminClaimsListener();
            if (this._adminTokenListener)
                this._adminTokenListener();
            this._scrubAuthProperties();
            yield (0, auth_1.signOut)(this.admin.auth);
        });
    }
    signOut() {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            yield this._signOutApp();
            yield this._signOutAdmin();
        });
    }
    //           +--------------------------------+
    // ----------|   End Authentication Methods   |----------
    //           +--------------------------------+
    //           +--------------------------------+
    // ----------| Begin Methods to Read User and |----------
    // ----------| Assignment/Administration Data |----------
    //           +--------------------------------+
    get superAdmin() {
        return this._superAdmin;
    }
    get idTokenReceived() {
        return this._idTokenReceived;
    }
    get idTokens() {
        return this._idTokens;
    }
    restConfig() {
        return {
            admin: {
                headers: { Authorization: `Bearer ${this._idTokens.admin}` },
                baseURL: `https://firestore.googleapis.com/v1/projects/${this.roarConfig.admin.projectId}/databases/(default)/documents`,
            },
            app: {
                headers: { Authorization: `Bearer ${this._idTokens.app}` },
                baseURL: `https://firestore.googleapis.com/v1/projects/${this.roarConfig.app.projectId}/databases/(default)/documents`,
            },
        };
    }
    get adminOrgs() {
        return this._adminOrgs;
    }
    get dbRefs() {
        var _a, _b;
        if (((_a = this.admin) === null || _a === void 0 ? void 0 : _a.user) && ((_b = this.app) === null || _b === void 0 ? void 0 : _b.user)) {
            return {
                admin: {
                    user: (0, firestore_1.doc)(this.admin.db, 'users', this.roarUid),
                    assignments: (0, firestore_1.collection)(this.admin.db, 'users', this.roarUid, 'assignments'),
                },
                app: {
                    user: (0, firestore_1.doc)(this.app.db, 'users', this.roarUid),
                    runs: (0, firestore_1.collection)(this.app.db, 'users', this.roarUid, 'runs'),
                    tasks: (0, firestore_1.collection)(this.app.db, 'tasks'),
                },
            };
        }
        else {
            return undefined;
        }
    }
    _getUser(uid) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const userDocRef = (0, firestore_1.doc)(this.admin.db, 'users', uid);
            const userDocSnap = yield (0, firestore_1.getDoc)(userDocRef);
            if (userDocSnap.exists()) {
                const userData = Object.assign({ userType: interfaces_1.UserType.guest }, userDocSnap.data());
                const externalDataSnapshot = yield (0, firestore_1.getDocs)((0, firestore_1.collection)(userDocRef, 'externalData'));
                let externalData = {};
                externalDataSnapshot.forEach((doc) => {
                    // doc.data() is never undefined for query doc snapshots returned by ``getDocs``
                    externalData = Object.assign(Object.assign({}, externalData), { [doc.id]: doc.data() });
                });
                userData.externalData = externalData;
                return userData;
            }
            else {
                return {
                    userType: interfaces_1.UserType.guest,
                    districts: (0, util_1.emptyOrg)(),
                    schools: (0, util_1.emptyOrg)(),
                    classes: (0, util_1.emptyOrg)(),
                    families: (0, util_1.emptyOrg)(),
                    groups: (0, util_1.emptyOrg)(),
                    archived: false,
                    testData: false,
                    demoData: false,
                };
            }
        });
    }
    getMyData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyInit();
            if (!this._isAuthenticated() || !this.roarUid) {
                return;
            }
            this.userData = yield this._getUser(this.roarUid);
            if (this.userData) {
                // Create a RoarAppUserInfo for later ingestion into a RoarAppkit
                // First determine the PID. If the user has signed in through Clever, then
                // the PID has been set to the Clever ID in the firebase cloud function.
                // If the user signed in through another method, the PID **may** have been
                // set to something else. Grab it if it's there.
                // In either case, it will then be present in this.userData.
                let assessmentPid = (0, get_1.default)(this.userData, 'assessmentPid');
                // If the assessmentPid is undefined, set it to the local part of the user's email.
                if (!assessmentPid) {
                    assessmentPid = (0, nth_1.default)((_a = this.app.user.email) === null || _a === void 0 ? void 0 : _a.match(/^(.+)@/), 1);
                }
                this.roarAppUserInfo = Object.assign(Object.assign({ db: this.app.db, roarUid: this.roarUid, assessmentUid: this.app.user.uid, assessmentPid: assessmentPid, userType: this.userData.userType }, (this.userData.testData && { testData: true })), (this.userData.demoData && { demoData: true }));
            }
        });
    }
    getLegalDoc(docName) {
        return __awaiter(this, void 0, void 0, function* () {
            const docRef = (0, firestore_1.doc)(this.admin.db, 'legal', docName);
            const docSnap = yield (0, firestore_1.getDoc)(docRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                const gitHubUrl = `https://raw.githubusercontent.com/${(0, get_1.default)(data, 'gitHubOrg')}/${(0, get_1.default)(data, 'gitHubRepository')}/${(0, get_1.default)(data, 'currentCommit')}/${(0, get_1.default)(data, 'fileName')}`;
                try {
                    const response = yield fetch(gitHubUrl);
                    const legalText = yield response.text();
                    return {
                        text: legalText,
                        version: (0, get_1.default)(data, 'currentCommit'),
                    };
                }
                catch (e) {
                    throw new Error('Error retrieving consent document from GitHub.');
                }
            }
            else {
                return null;
            }
        });
    }
    updateConsentStatus(docName, consentVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, firestore_1.updateDoc)(this.dbRefs.admin.user, {
                [`legal.${docName}.${consentVersion}`]: new Date(),
            });
        });
    }
    updateVideoMetadata(administrationId, taskId, status) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            // Update this assignment's `videoWatched` timestamp
            if (status === 'started') {
                yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                    yield this._updateAssignedAssessment(administrationId, taskId, { videoStartedOn: new Date() }, transaction);
                }));
            }
            else if (status === 'completed') {
                yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                    yield this._updateAssignedAssessment(administrationId, taskId, { videoCompletedOn: new Date() }, transaction);
                }));
            }
        });
    }
    get roarUid() {
        var _a, _b;
        return (_b = (_a = this.admin) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.uid;
    }
    startAssignment(administrationId, transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const assignmentDocRef = (0, firestore_1.doc)(this.dbRefs.admin.assignments, administrationId);
            if (transaction) {
                return transaction.update(assignmentDocRef, { started: true });
            }
            else {
                return (0, firestore_1.updateDoc)(assignmentDocRef, { started: true });
            }
        });
    }
    completeAssignment(administrationId, transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const assignmentDocRef = (0, firestore_1.doc)(this.dbRefs.admin.assignments, administrationId);
            if (transaction) {
                return transaction.update(assignmentDocRef, { completed: true });
            }
            else {
                return (0, firestore_1.updateDoc)(assignmentDocRef, { completed: true });
            }
        });
    }
    _updateAssignedAssessment(administrationId, taskId, updates, transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const docRef = (0, firestore_1.doc)(this.dbRefs.admin.assignments, administrationId);
            const docSnap = yield transaction.get(docRef);
            if (docSnap.exists()) {
                const assessments = docSnap.data().assessments;
                const assessmentIdx = assessments.findIndex((a) => a.taskId === taskId);
                const oldAssessmentInfo = assessments[assessmentIdx];
                const newAssessmentInfo = Object.assign(Object.assign({}, oldAssessmentInfo), updates);
                assessments[assessmentIdx] = newAssessmentInfo;
                return transaction.update(docRef, { assessments });
            }
            else {
                return transaction;
            }
        });
    }
    startAssessment(administrationId, taskId, taskVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const appKit = yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                // First grab data about the administration
                const administrationDocRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
                const administrationDocSnap = yield transaction.get(administrationDocRef);
                if (administrationDocSnap.exists()) {
                    let assessmentParams = {};
                    const assessments = administrationDocSnap.data().assessments;
                    const thisAssessment = assessments.find((a) => a.taskId === taskId);
                    if (thisAssessment) {
                        assessmentParams = thisAssessment.params;
                    }
                    else {
                        throw new Error(`Could not find assessment with taskId ${taskId} in administration ${administrationId}`);
                    }
                    // Check the assignment to see if none of the assessments have been
                    // started yet. If not, start the assignment
                    const assignmentDocRef = (0, firestore_1.doc)(this.dbRefs.admin.assignments, administrationId);
                    const assignmentDocSnap = yield transaction.get(assignmentDocRef);
                    if (assignmentDocSnap.exists()) {
                        const assignedAssessments = assignmentDocSnap.data().assessments;
                        const assessmentUpdateData = {
                            startedOn: new Date(),
                        };
                        // Append runId to `allRunIds` for this assessment
                        // in the userId/assignments collection
                        yield this._updateAssignedAssessment(administrationId, taskId, assessmentUpdateData, transaction);
                        if (!assignedAssessments.some((a) => Boolean(a.startedOn))) {
                            yield this.startAssignment(administrationId, transaction);
                        }
                        if (this.roarAppUserInfo === undefined) {
                            yield this.getMyData();
                        }
                        const assigningOrgs = assignmentDocSnap.data().assigningOrgs;
                        const readOrgs = assignmentDocSnap.data().readOrgs;
                        const taskAndVariant = yield (0, query_assessment_1.getTaskAndVariant)({
                            db: this.app.db,
                            taskId,
                            variantParams: assessmentParams,
                        });
                        if (taskAndVariant.task === undefined) {
                            throw new Error(`Could not find task ${taskId}`);
                        }
                        if (taskAndVariant.variant === undefined) {
                            throw new Error(`Could not find a variant of task ${taskId} with the params: ${JSON.stringify(assessmentParams)}`);
                        }
                        const taskName = taskAndVariant.task.name;
                        const taskDescription = taskAndVariant.task.description;
                        const variantName = taskAndVariant.variant.name;
                        const variantDescription = taskAndVariant.variant.description;
                        const { testData: isAssignmentTest, demoData: isAssignmentDemo } = assignmentDocSnap.data();
                        const { testData: isUserTest, demoData: isUserDemo } = this.roarAppUserInfo;
                        const { testData: isTaskTest, demoData: isTaskDemo } = taskAndVariant.task;
                        const { testData: isVariantTest, demoData: isVariantDemo } = taskAndVariant.variant;
                        const taskInfo = {
                            db: this.app.db,
                            taskId,
                            taskName,
                            taskDescription,
                            taskVersion,
                            variantName,
                            variantDescription,
                            variantParams: assessmentParams,
                            testData: {
                                task: isTaskTest !== null && isTaskTest !== void 0 ? isTaskTest : false,
                                variant: isVariantTest !== null && isVariantTest !== void 0 ? isVariantTest : false,
                            },
                            demoData: {
                                task: isTaskDemo !== null && isTaskDemo !== void 0 ? isTaskDemo : false,
                                variant: isVariantDemo !== null && isVariantDemo !== void 0 ? isVariantDemo : false,
                            },
                        };
                        return new appkit_1.RoarAppkit({
                            firebaseProject: this.app,
                            userInfo: this.roarAppUserInfo,
                            assigningOrgs,
                            readOrgs,
                            assignmentId: administrationId,
                            taskInfo,
                            testData: {
                                user: isUserTest,
                                task: isTaskTest,
                                variant: isVariantTest,
                                run: isAssignmentTest || isUserTest || isTaskTest || isVariantTest,
                            },
                            demoData: {
                                user: isUserDemo,
                                task: isTaskDemo,
                                variant: isVariantDemo,
                                run: isAssignmentDemo || isUserDemo || isTaskDemo || isVariantDemo,
                            },
                        });
                    }
                    else {
                        throw new Error(`Could not find assignment for user ${this.roarUid} with administration id ${administrationId}`);
                    }
                }
                else {
                    throw new Error(`Could not find administration with id ${administrationId}`);
                }
            }));
            return appKit;
        });
    }
    completeAssessment(administrationId, taskId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                // Check to see if all of the assessments in this assignment have been completed,
                // If so, complete the assignment
                const docRef = (0, firestore_1.doc)(this.dbRefs.admin.assignments, administrationId);
                const docSnap = yield transaction.get(docRef);
                // Update this assignment's `completedOn` timestamp
                yield this._updateAssignedAssessment(administrationId, taskId, { completedOn: new Date() }, transaction);
                if (docSnap.exists()) {
                    // Now check to see if all of the assessments in this assignment have
                    // been completed.  Because we do this all in one transaction, we have
                    // to put the `.get` call before any `.update` or `.set` calls. Thus, in
                    // the `docSnap` that we are referencing below, the current assessment
                    // will not have a `completedOn` timestamp yet (we set that after we
                    // called `.get`).  We therefore check to see if all of the assessments
                    // have been completed **or** have the current taskId.
                    if (docSnap.data().assessments.every((a) => {
                        return Boolean(a.completedOn) || a.optional || a.taskId === taskId;
                    })) {
                        this.completeAssignment(administrationId, transaction);
                    }
                }
            }));
        });
    }
    updateAssessmentRewardShown(administrationId, taskId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                this._updateAssignedAssessment(administrationId, taskId, { rewardShown: true }, transaction);
            }));
        });
    }
    // These are all methods that will be important for admins, but not necessary for students
    /**
     * Create or update an administration
     *
     * @param input input object
     * @param input.name The administration name
     * @param input.assessments The list of assessments for this administration
     * @param input.dateOpen The start date for this administration
     * @param input.dateClose The end date for this administration
     * @param input.sequential Whether or not the assessments in this
     *                         administration must be taken sequentially
     * @param input.orgs The orgs assigned to this administration
     * @param input.tags Metadata tags for this administration
     * @param input.administrationId Optional ID of an existing administration. If
     *                               provided, this method will update an
     *                               existing administration.
     */
    createAdministration({ name, publicName, assessments, dateOpen, dateClose, sequential = true, orgs = (0, util_1.emptyOrgList)(), tags = [], administrationId, isTestData = false, }) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if ([name, dateOpen, dateClose, assessments].some((param) => param === undefined || param === null)) {
                throw new Error('The parameters name, dateOpen, dateClose, and assessments are required');
            }
            if (dateClose < dateOpen) {
                throw new Error(`The end date cannot be before the start date: ${dateClose.toISOString()} < ${dateOpen.toISOString()}`);
            }
            // First add the administration to the database
            const administrationData = {
                name,
                publicName: publicName !== null && publicName !== void 0 ? publicName : name,
                createdBy: this.roarUid,
                groups: (_a = orgs.groups) !== null && _a !== void 0 ? _a : [],
                families: (_b = orgs.families) !== null && _b !== void 0 ? _b : [],
                classes: (_c = orgs.classes) !== null && _c !== void 0 ? _c : [],
                schools: (_d = orgs.schools) !== null && _d !== void 0 ? _d : [],
                districts: (_e = orgs.districts) !== null && _e !== void 0 ? _e : [],
                dateCreated: new Date(),
                dateOpened: dateOpen,
                dateClosed: dateClose,
                assessments: assessments,
                sequential: sequential,
                tags: tags,
            };
            if (isTestData)
                administrationData.testData = true;
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                let administrationDocRef;
                if (administrationId !== undefined) {
                    // Set the doc ref to the existing administration
                    administrationDocRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
                    // Get the existing administration to make sure update is allowed.
                    const docSnap = yield transaction.get(administrationDocRef);
                    if (!docSnap.exists()) {
                        throw new Error(`Could not find administration with id ${administrationId}`);
                    }
                }
                else {
                    // Create a new administration doc ref
                    administrationDocRef = (0, firestore_1.doc)((0, firestore_1.collection)(this.admin.db, 'administrations'));
                }
                // Create the administration doc in the admin Firestore,
                transaction.set(administrationDocRef, administrationData, { merge: true });
                // Then add the ID to the admin's list of administrationsCreated
                const userDocRef = this.dbRefs.admin.user;
                transaction.update(userDocRef, {
                    'adminData.administrationsCreated': (0, firestore_1.arrayUnion)(administrationDocRef.id),
                });
            }));
        });
    }
    /**
     * Delete an administration
     *
     * @param administrationId The administration ID to delete
     */
    deleteAdministration(administrationId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if (!this._superAdmin) {
                throw new Error('You must be a super admin to delete an administration.');
            }
            yield (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                const administrationDocRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
                const statsDocRef = (0, firestore_1.doc)(administrationDocRef, 'stats', 'completion');
                const docSnap = yield transaction.get(administrationDocRef);
                if (docSnap.exists()) {
                    // Delete the stats/completion doc if it exists
                    const statsDocSnap = yield transaction.get(statsDocRef);
                    if (statsDocSnap.exists()) {
                        transaction.delete(statsDocRef);
                    }
                    // Delete the administration doc
                    transaction.delete(administrationDocRef);
                }
            }));
        });
    }
    assignAdministrationToOrgs(administrationId, orgs = (0, util_1.emptyOrgList)()) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const docRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
            yield (0, firestore_1.updateDoc)(docRef, {
                districts: (0, firestore_1.arrayUnion)(...orgs.districts),
                schools: (0, firestore_1.arrayUnion)(...orgs.schools),
                classes: (0, firestore_1.arrayUnion)(...orgs.classes),
                groups: (0, firestore_1.arrayUnion)(...orgs.groups),
                families: (0, firestore_1.arrayUnion)(...orgs.families),
            });
        });
    }
    unassignAdministrationToOrgs(administrationId, orgs = (0, util_1.emptyOrgList)()) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const docRef = (0, firestore_1.doc)(this.admin.db, 'administrations', administrationId);
            yield (0, firestore_1.updateDoc)(docRef, {
                districts: (0, firestore_1.arrayRemove)(...orgs.districts),
                schools: (0, firestore_1.arrayRemove)(...orgs.schools),
                classes: (0, firestore_1.arrayRemove)(...orgs.classes),
                groups: (0, firestore_1.arrayRemove)(...orgs.groups),
                families: (0, firestore_1.arrayRemove)(...orgs.families),
            });
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateUserExternalData(uid, externalResourceId, externalData) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Method not currently implemented.');
            // this._verifyAuthentication();
            // this._verifyAdmin();
            // const docRef = doc(this.admin!.db, 'users', uid, 'externalData', externalResourceId);
            // const docSnap = await getDoc(docRef);
            // if (docSnap.exists()) {
            //   // We use the dot-object module to transform the potentially nested external data to
            //   // dot notation. This prevents overwriting extisting external data.
            //   // See the note about dot notation in https://firebase.google.com/docs/firestore/manage-data/add-data#update_fields_in_nested_objects
            //   await updateDoc(
            //     docRef,
            //     removeNull(
            //       dot.dot({
            //         [externalResourceId]: externalData,
            //       }),
            //     ),
            //   );
            // } else {
            //   await setDoc(docRef, removeNull(externalData));
            // }
        });
    }
    createStudentWithEmailPassword(email, password, userData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if (!(0, get_1.default)(userData, 'dob')) {
                throw new Error('Student date of birth must be supplied.');
            }
            const userDocData = {
                userType: interfaces_1.UserType.student,
                studentData: {},
                districts: (0, util_1.emptyOrg)(),
                schools: (0, util_1.emptyOrg)(),
                classes: (0, util_1.emptyOrg)(),
                families: (0, util_1.emptyOrg)(),
                groups: (0, util_1.emptyOrg)(),
                archived: false,
            };
            if ((0, get_1.default)(userData, 'pid')) {
                (0, set_1.default)(userDocData, 'assessmentPid', userData.pid);
            }
            else {
                // If PID was not supplied, then construct one using an eight character
                // checksum of the email.
                // Prefix that checksum with optional org abbreviations:
                // 1. If the district has an abbreviation, start with that.
                // 2. Then add the school abbreviation, if it exists.
                // 3. If neither of those are available, use the group abbreviation.
                // 4. Otherwise prepend nothing.
                const emailCheckSum = (0, util_1.crc32String)(email);
                const districtPrefix = (0, get_1.default)(userData, 'district.abbreviation');
                const schoolPrefix = (0, get_1.default)(userData, 'school.abbreviation');
                const groupPrefix = (0, get_1.default)(userData, 'group.abbreviation');
                const pidParts = [];
                if (districtPrefix)
                    pidParts.push(districtPrefix);
                if (schoolPrefix)
                    pidParts.push(schoolPrefix);
                if (pidParts.length === 0 && groupPrefix)
                    pidParts.push(groupPrefix);
                pidParts.push(emailCheckSum);
                (0, set_1.default)(userDocData, 'assessmentPid', pidParts.join('-'));
            }
            // TODO: this can probably be optimized.
            (0, set_1.default)(userDocData, 'email', email);
            if ((0, get_1.default)(userData, 'username'))
                (0, set_1.default)(userDocData, 'username', userData.username);
            if ((0, get_1.default)(userData, 'name'))
                (0, set_1.default)(userDocData, 'name', userData.name);
            if ((0, get_1.default)(userData, 'dob'))
                (0, set_1.default)(userDocData, 'studentData.dob', userData.dob);
            if ((0, get_1.default)(userData, 'gender'))
                (0, set_1.default)(userDocData, 'studentData.gender', userData.gender);
            if ((0, get_1.default)(userData, 'grade'))
                (0, set_1.default)(userDocData, 'studentData.grade', userData.grade);
            if ((0, get_1.default)(userData, 'state_id'))
                (0, set_1.default)(userDocData, 'studentData.state_id', userData.state_id);
            if ((0, get_1.default)(userData, 'hispanic_ethnicity'))
                (0, set_1.default)(userDocData, 'studentData.hispanic_ethnicity', userData.hispanic_ethnicity);
            if ((0, get_1.default)(userData, 'ell_status'))
                (0, set_1.default)(userDocData, 'studentData.ell_status', userData.ell_status);
            if ((0, get_1.default)(userData, 'iep_status'))
                (0, set_1.default)(userDocData, 'studentData.iep_status', userData.iep_status);
            if ((0, get_1.default)(userData, 'frl_status'))
                (0, set_1.default)(userDocData, 'studentData.frl_status', userData.frl_status);
            if ((0, get_1.default)(userData, 'race'))
                (0, set_1.default)(userDocData, 'studentData.race', userData.race);
            if ((0, get_1.default)(userData, 'home_language'))
                (0, set_1.default)(userDocData, 'studentData.home_language', userData.home_language);
            if ((0, get_1.default)(userData, 'district'))
                (0, set_1.default)(userDocData, 'orgIds.district', userData.district.id);
            if ((0, get_1.default)(userData, 'school'))
                (0, set_1.default)(userDocData, 'orgIds.school', userData.school.id);
            if ((0, get_1.default)(userData, 'class'))
                (0, set_1.default)(userDocData, 'orgIds.class', userData.class.id);
            if ((0, get_1.default)(userData, 'group'))
                (0, set_1.default)(userDocData, 'orgIds.group', userData.group.id);
            if ((0, get_1.default)(userData, 'family'))
                (0, set_1.default)(userDocData, 'orgIds.family', userData.family.id);
            const cloudCreateStudent = (0, functions_1.httpsCallable)(this.admin.functions, 'createstudentaccount');
            yield cloudCreateStudent({ email, password, userData: userDocData });
        });
    }
    createNewFamily(caretakerEmail, caretakerPassword, caretakerUserData, children, isTestData = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // Format children objects
            const formattedChildren = children.map((child) => {
                const returnChild = {
                    email: child.email,
                    password: child.password,
                };
                // Create a PID for the student.
                const emailCheckSum = (0, util_1.crc32String)(child.email);
                const pidParts = [];
                pidParts.push(emailCheckSum);
                (0, set_1.default)(returnChild, 'userData.assessmentPid', pidParts.join('-'));
                // Move attributes into the studentData object.
                (0, set_1.default)(returnChild, 'userData.username', child.email.split('@')[0]);
                if ((0, get_1.default)(child, 'userData.name'))
                    (0, set_1.default)(returnChild, 'userData.name', child.userData.name);
                if ((0, get_1.default)(child, 'userData.gender'))
                    (0, set_1.default)(returnChild, 'userData.studentData.gender', child.userData.gender);
                if ((0, get_1.default)(child, 'userData.grade'))
                    (0, set_1.default)(returnChild, 'userData.studentData.grade', child.userData.grade);
                if ((0, get_1.default)(child, 'userData.dob'))
                    (0, set_1.default)(returnChild, 'userData.studentData.dob', child.userData.dob);
                if ((0, get_1.default)(child, 'userData.state_id'))
                    (0, set_1.default)(returnChild, 'userData.studentData.state_id', child.userData.state_id);
                if ((0, get_1.default)(child, 'userData.hispanic_ethnicity'))
                    (0, set_1.default)(returnChild, 'userData.studentData.hispanic_ethnicity', child.userData.hispanic_ethnicity);
                if ((0, get_1.default)(child, 'userData.ell_status'))
                    (0, set_1.default)(returnChild, 'userData.studentData.ell_status', child.userData.ell_status);
                if ((0, get_1.default)(child, 'userData.iep_status'))
                    (0, set_1.default)(returnChild, 'userData.studentData.iep_status', child.userData.iep_status);
                if ((0, get_1.default)(child, 'userData.frl_status'))
                    (0, set_1.default)(returnChild, 'userData.studentData.frl_status', child.userData.frl_status);
                if ((0, get_1.default)(child, 'userData.race'))
                    (0, set_1.default)(returnChild, 'userData.studentData.race', child.userData.race);
                if ((0, get_1.default)(child, 'userData.home_language'))
                    (0, set_1.default)(returnChild, 'userData.studentData.home_language', child.userData.home_language);
                return returnChild;
            });
            // Call cloud function
            const cloudCreateFamily = (0, functions_1.httpsCallable)(this.admin.functions, 'createnewfamily');
            yield cloudCreateFamily({
                caretakerEmail,
                caretakerPassword,
                caretakerUserData,
                children: formattedChildren,
                isTestData,
            });
        });
    }
    createStudentWithUsernamePassword(username, password, userData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const email = `${username}@roar-auth.com`;
            return this.createStudentWithEmailPassword(email, password, userData);
        });
    }
    createAdministrator(email, name, targetOrgs, targetAdminOrgs, isTestData = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const cloudCreateAdministrator = (0, functions_1.httpsCallable)(this.admin.functions, 'createAdministratorAccount');
            const adminResponse = yield cloudCreateAdministrator({
                email,
                name,
                orgs: targetOrgs,
                adminOrgs: targetAdminOrgs,
                isTestData,
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if ((0, get_1.default)(adminResponse.data, 'status') !== 'ok') {
                throw new Error('Failed to create administrator user account.');
            }
        });
    }
    syncCleverOrgs(shallow = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            if (!this._superAdmin) {
                throw new Error('You must be a super admin to sync Clever organizations.');
            }
            const syncCleverOrgs = (0, functions_1.httpsCallable)(this.admin.functions, 'syncCleverOrgs', { timeout: 300000 });
            const result = yield syncCleverOrgs({ shallow });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if ((0, get_1.default)(result.data, 'status') !== 'ok') {
                throw new Error('Failed to sync Clever orgs.');
            }
        });
    }
    /**
     * Create or update an organization.
     *
     * @param orgsCollection The type of organization to create or update.
     * @param orgData The organization data to create or update.
     * @param isTestData Whether or not this is a test org.
     * @param isDemoData Whether or not this is a demo org.
     * @param organizationId Optional ID of an existing org. If provided, this
     *                       method will update an existing org.
     * @returns The newly created or updated organization ID.
     */
    createOrg(orgsCollection, orgData, isTestData = false, isDemoData = false, organizationId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            // Check that schools have a districtId
            if (orgsCollection === 'schools' && orgData.districtId === undefined) {
                throw new Error('You must specify a districtId when creating a school.');
            }
            // Check that classes have a schoolId
            if (orgsCollection === 'classes' && orgData.schoolId === undefined) {
                throw new Error('You must specify a schoolId when creating a class.');
            }
            return (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                // If org is a class, retrieve the districtId from the parent school
                if (orgsCollection === 'classes') {
                    const schoolDocRef = (0, firestore_1.doc)(this.admin.db, 'schools', orgData.schoolId);
                    const districtId = yield transaction.get(schoolDocRef).then((snapshot) => {
                        if (snapshot.exists()) {
                            return snapshot.data().districtId;
                        }
                        else {
                            throw new Error(`Could not find a school with ID ${orgData.schoolId} in the ROAR database.`);
                        }
                    });
                    orgData = Object.assign(Object.assign({}, orgData), { districtId });
                }
                if (isTestData)
                    orgData.testData = true;
                if (isDemoData)
                    orgData.demoData = true;
                if (organizationId === undefined) {
                    // If organizationId is undefined, we create a new org
                    const newOrgRef = (0, firestore_1.doc)((0, firestore_1.collection)(this.admin.db, orgsCollection));
                    const orgId = newOrgRef.id;
                    transaction.set(newOrgRef, orgData);
                    if (orgsCollection === 'schools') {
                        const districtId = orgData.districtId;
                        const adminDistrictRef = (0, firestore_1.doc)(this.admin.db, 'districts', districtId);
                        transaction.update(adminDistrictRef, { schools: (0, firestore_1.arrayUnion)(orgId) });
                    }
                    else if (orgsCollection === 'classes') {
                        const schoolId = orgData.schoolId;
                        const adminSchoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', schoolId);
                        transaction.update(adminSchoolRef, { classes: (0, firestore_1.arrayUnion)(orgId) });
                    }
                    if (orgsCollection === 'groups') {
                        if (orgData.parentOrgId && orgData.parentOrgType) {
                            const parentOrgRef = (0, firestore_1.doc)(this.admin.db, (0, util_1.pluralizeFirestoreCollection)(orgData.parentOrgType), orgData.parentOrgId);
                            transaction.update(parentOrgRef, { subGroups: (0, firestore_1.arrayUnion)(orgId) });
                        }
                        if (orgData.familyId) {
                            const familyRef = (0, firestore_1.doc)(this.admin.db, 'families', orgData.familyId);
                            transaction.update(familyRef, { subGroups: (0, firestore_1.arrayUnion)(orgId) });
                        }
                    }
                    return orgId;
                }
                else {
                    // If organizationId is defined, we update an existing org
                    const orgDocRef = (0, firestore_1.doc)(this.admin.db, orgsCollection, organizationId);
                    // Get the old parent org IDs, remove this org from their children
                    // fields on Firestore.
                    const docSnap = yield transaction.get(orgDocRef);
                    if (docSnap.exists()) {
                        const oldOrgData = docSnap.data();
                        const { schoolId = orgData.schoolId, districtId = orgData.districtId, familyId = orgData.familyId, parentOrgType = orgData.parentOrgType, parentOrgId = orgData.parentOrgId, } = oldOrgData;
                        if (orgsCollection === 'classes' && orgData.schoolId && schoolId !== orgData.schoolId) {
                            const oldSchoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', schoolId);
                            const newSchoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', orgData.schoolId);
                            transaction.update(oldSchoolRef, { classes: (0, firestore_1.arrayRemove)(organizationId) });
                            transaction.update(newSchoolRef, { classes: (0, firestore_1.arrayUnion)(organizationId) });
                        }
                        if (orgsCollection === 'schools' && orgData.districtId && districtId !== orgData.districtId) {
                            const oldDistrictRef = (0, firestore_1.doc)(this.admin.db, 'districts', districtId);
                            const newDistrictRef = (0, firestore_1.doc)(this.admin.db, 'districts', orgData.districtId);
                            transaction.update(oldDistrictRef, { schools: (0, firestore_1.arrayRemove)(organizationId) });
                            transaction.update(newDistrictRef, { schools: (0, firestore_1.arrayUnion)(organizationId) });
                        }
                        if (orgsCollection === 'groups') {
                            if (orgData.familyId && familyId !== orgData.familyId) {
                                const oldFamilyRef = (0, firestore_1.doc)(this.admin.db, 'families', familyId);
                                const newFamilyRef = (0, firestore_1.doc)(this.admin.db, 'families', orgData.familyId);
                                transaction.update(oldFamilyRef, { subGroups: (0, firestore_1.arrayRemove)(organizationId) });
                                transaction.update(newFamilyRef, { subGroups: (0, firestore_1.arrayUnion)(organizationId) });
                            }
                            if (orgData.parentOrgType &&
                                orgData.parentOrgId &&
                                (parentOrgType !== orgData.parentOrgType || parentOrgId !== orgData.parentOrgId)) {
                                const oldParentOrgRef = (0, firestore_1.doc)(this.admin.db, (0, util_1.pluralizeFirestoreCollection)(parentOrgType), parentOrgId);
                                const newParentOrgRef = (0, firestore_1.doc)(this.admin.db, (0, util_1.pluralizeFirestoreCollection)(orgData.parentOrgType), orgData.parentOrgId);
                                transaction.update(oldParentOrgRef, { subGroups: (0, firestore_1.arrayRemove)(organizationId) });
                                transaction.update(newParentOrgRef, { subGroups: (0, firestore_1.arrayUnion)(organizationId) });
                            }
                        }
                        transaction.update(orgDocRef, orgData);
                        return organizationId;
                    }
                    else {
                        throw new Error(`Could not find an organization with ID ${organizationId} in the ROAR database.`);
                    }
                }
            }));
        });
    }
    /**
     * Delete an organization.
     *
     * @param recursive
     * @param orgsCollection The type of organization to create or update.
     * @param orgId The ID of the organization to delete.
     * @param recursive if true, recursively delete all children of this org.
     *                  Default is true.
     */
    deleteOrg(orgsCollection, orgId, recursive = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            if (!this._superAdmin) {
                throw new Error('You must be a super admin to delete an organization.');
            }
            // Loop over the admin and assessment databases
            (0, firestore_1.runTransaction)(this.admin.db, (transaction) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const orgDocRef = (0, firestore_1.doc)(this.admin.db, orgsCollection, orgId);
                const docSnap = yield transaction.get(orgDocRef);
                if (docSnap.exists()) {
                    const orgData = docSnap.data();
                    // Save the dependent schools and classes for recursive deletion
                    // later. Why are we doing this here? Because all transaction reads
                    // have to take place before any writes, updates, or deletions.  We
                    // are potentially reading school docs to get all of the classes.
                    const { schools = [], classes = [], groups: subGroups = [] } = orgData;
                    if (recursive) {
                        for (const school of schools) {
                            const schoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', school);
                            const schoolDocSnap = yield transaction.get(schoolRef);
                            if (schoolDocSnap.exists()) {
                                const schoolData = schoolDocSnap.data();
                                classes.push(...((_a = schoolData.classes) !== null && _a !== void 0 ? _a : []));
                                subGroups.push(...((_b = schoolData.subGroups) !== null && _b !== void 0 ? _b : []));
                            }
                        }
                    }
                    // Remove this org from the parent's list of child orgs.
                    const { schoolId, districtId } = orgData;
                    if (schoolId !== undefined) {
                        const schoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', schoolId);
                        transaction.update(schoolRef, { classes: (0, firestore_1.arrayRemove)(orgId) });
                    }
                    else if (districtId !== undefined) {
                        const districtRef = (0, firestore_1.doc)(this.admin.db, 'districts', districtId);
                        transaction.update(districtRef, { schools: (0, firestore_1.arrayRemove)(orgId) });
                    }
                    transaction.delete(orgDocRef);
                    // Remove children orgs if recursive is true
                    if (recursive) {
                        for (const _class of classes) {
                            const classRef = (0, firestore_1.doc)(this.admin.db, 'classes', _class);
                            transaction.delete(classRef);
                        }
                        for (const school of schools) {
                            const schoolRef = (0, firestore_1.doc)(this.admin.db, 'schools', school);
                            transaction.delete(schoolRef);
                        }
                    }
                }
                else {
                    throw new Error(`Could not find an organization with ID ${orgId} in the ROAR database.`);
                }
            }));
        });
    }
    registerTaskVariant({ taskId, taskName, taskDescription, taskImage, taskURL, variantName, variantDescription, variantParams = {}, testData = { task: false, variant: false }, demoData = { task: false, variant: false }, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const task = new task_1.RoarTaskVariant({
                db: this.app.db,
                taskId,
                taskName,
                taskDescription,
                taskImage,
                taskURL,
                variantName,
                variantDescription,
                variantParams,
                testData,
                demoData,
            });
            yield task.toFirestore();
            return task;
        });
    }
    // LEVANTE
    createLevanteUsersWithEmailPassword(userData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const cloudCreateLevanteUsers = (0, functions_1.httpsCallable)(this.admin.functions, 'createLevanteUsers');
            return yield cloudCreateLevanteUsers({ userData });
        });
    }
    saveSurveyResponses(surveyResponses) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            const cloudSaveSurveyResponses = (0, functions_1.httpsCallable)(this.admin.functions, 'saveSurveyResponses');
            return yield cloudSaveSurveyResponses({ surveyResponses });
        });
    }
    createLevanteGroup(groupData) {
        return __awaiter(this, void 0, void 0, function* () {
            this._verifyAuthentication();
            this._verifyAdmin();
            const cloudCreateLevanteGroup = (0, functions_1.httpsCallable)(this.admin.functions, 'createLevanteGroup');
            return yield cloudCreateLevanteGroup({ groupData });
        });
    }
}
exports.RoarFirekit = RoarFirekit;
