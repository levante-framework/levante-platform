"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchEmailAuthMethods = exports.isUsernameAvailable = exports.isEmailAvailable = exports.isRoarAuthEmail = exports.roarEmail = void 0;
const auth_1 = require("firebase/auth");
/**
 * Return a unique and reproducible email address for the user.
 *
 * @function
 * @param {string} roarPid - The ROAR user PID
 * @returns {string} - The email address
 */
const roarEmail = (roarPid) => {
    return `${roarPid}@roar-auth.com`;
};
exports.roarEmail = roarEmail;
const isRoarAuthEmail = (email) => {
    return email.split('@')[1] === 'roar-auth.com';
};
exports.isRoarAuthEmail = isRoarAuthEmail;
const isEmailAvailable = (auth, email) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, auth_1.fetchSignInMethodsForEmail)(auth, email).then((signInMethods) => {
        return signInMethods.length === 0;
    });
});
exports.isEmailAvailable = isEmailAvailable;
const isUsernameAvailable = (auth, username) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, exports.isEmailAvailable)(auth, (0, exports.roarEmail)(username));
});
exports.isUsernameAvailable = isUsernameAvailable;
const fetchEmailAuthMethods = (auth, email) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, auth_1.fetchSignInMethodsForEmail)(auth, email).then((signInMethods) => {
        const methods = [];
        if (signInMethods.indexOf(auth_1.EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD) != -1) {
            // User can sign in with email/password.
            methods.push('password');
        }
        if (signInMethods.indexOf(auth_1.EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD) != -1) {
            // User can sign in with email/link.
            methods.push('link');
        }
        return methods;
    });
});
exports.fetchEmailAuthMethods = fetchEmailAuthMethods;
