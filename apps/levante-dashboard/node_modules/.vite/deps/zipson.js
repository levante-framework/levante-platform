import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-QX3VWGKS.js";

// ../../node_modules/zipson/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/zipson/lib/constants.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FLOAT_COMPRESSION_PRECISION = 1e3;
    exports.DATE_LOW_PRECISION = 1e5;
    exports.FLOAT_FULL_PRECISION_DELIMITER = ",";
    exports.FLOAT_REDUCED_PRECISION_DELIMITER = ".";
    exports.INTEGER_TOKEN = "¢";
    exports.FLOAT_TOKEN = "£";
    exports.STRING_TOKEN = "¨";
    exports.DATE_TOKEN = "ø";
    exports.LP_DATE_TOKEN = "±";
    exports.UNREFERENCED_INTEGER_TOKEN = "¤";
    exports.UNREFERENCED_FLOAT_TOKEN = "¥";
    exports.UNREFERENCED_STRING_TOKEN = "´";
    exports.UNREFERENCED_DATE_TOKEN = "¿";
    exports.UNREFERENCED_LP_DATE_TOKEN = "ÿ";
    exports.REF_INTEGER_TOKEN = "º";
    exports.REF_FLOAT_TOKEN = "Ý";
    exports.REF_STRING_TOKEN = "ß";
    exports.REF_DATE_TOKEN = "×";
    exports.REF_LP_DATE_TOKEN = "ü";
    exports.NULL_TOKEN = "§";
    exports.UNDEFINED_TOKEN = "µ";
    exports.BOOLEAN_TRUE_TOKEN = "»";
    exports.BOOLEAN_FALSE_TOKEN = "«";
    exports.ESCAPE_CHARACTER = "\\";
    exports.ESCAPED_STRING_TOKEN = "" + exports.ESCAPE_CHARACTER + exports.STRING_TOKEN;
    exports.ESCAPED_UNREFERENCED_STRING_TOKEN = "" + exports.ESCAPE_CHARACTER + exports.UNREFERENCED_STRING_TOKEN;
    exports.REGEX_ESCAPE_CHARACTER = new RegExp(exports.ESCAPE_CHARACTER.replace("\\", "\\\\"), "g");
    exports.REGEX_ESCAPED_ESCAPE_CHARACTER = new RegExp(exports.ESCAPE_CHARACTER.replace("\\", "\\\\") + exports.ESCAPE_CHARACTER.replace("\\", "\\\\"), "g");
    exports.REGEX_STRING_TOKEN = new RegExp(exports.STRING_TOKEN, "g");
    exports.REGEX_ESCAPED_STRING_TOKEN = new RegExp(exports.ESCAPE_CHARACTER + exports.ESCAPED_STRING_TOKEN, "g");
    exports.REGEX_UNREFERENCED_STRING_TOKEN = new RegExp(exports.UNREFERENCED_STRING_TOKEN, "g");
    exports.REGEX_UNREFERENCED_ESCAPED_STRING_TOKEN = new RegExp(exports.ESCAPE_CHARACTER + exports.ESCAPED_UNREFERENCED_STRING_TOKEN, "g");
    exports.DATE_REGEX = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z/;
    exports.OBJECT_START_TOKEN = "{";
    exports.OBJECT_END_TOKEN = "}";
    exports.TEMPLATE_OBJECT_START = "¦";
    exports.TEMPLATE_OBJECT_END = "‡";
    exports.TEMPLATE_OBJECT_FINAL = "—";
    exports.ARRAY_START_TOKEN = "|";
    exports.ARRAY_END_TOKEN = "÷";
    exports.ARRAY_REPEAT_TOKEN = "þ";
    exports.ARRAY_REPEAT_MANY_TOKEN = "^";
    exports.ARRAY_REPEAT_COUNT_THRESHOLD = 4;
    exports.REFERENCE_HEADER_LENGTH = 1;
    exports.DELIMITING_TOKENS_THRESHOLD = 122;
    exports.STRING_IDENT_PREFIX = "$";
    exports.INTEGER_SMALL_EXCLUSIVE_BOUND_LOWER = -10;
    exports.INTEGER_SMALL_EXCLUSIVE_BOUND_UPPER = 10;
    exports.INTEGER_SMALL_TOKEN_EXCLUSIVE_BOUND_LOWER = 191;
    exports.INTEGER_SMALL_TOKEN_EXCLUSIVE_BOUND_UPPER = 211;
    exports.INTEGER_SMALL_TOKEN_OFFSET = -201;
    exports.INTEGER_SMALL_TOKEN_ELEMENT_OFFSET = 9;
    exports.INTEGER_SMALL_TOKENS = ["À", "Á", "Â", "Ã", "Ä", "Å", "Æ", "Ç", "È", "É", "Ê", "Ë", "Ì", "Í", "Î", "Ï", "Ð", "Ñ", "Ò"];
  }
});

// ../../node_modules/zipson/lib/compressor/any.js
var require_any = __commonJS({
  "../../node_modules/zipson/lib/compressor/any.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    function compressAny(compressors, context, obj, invertedIndex, writer, options) {
      var type = typeof obj;
      if (type === "number") {
        compressors.number(compressors, context, obj, invertedIndex, writer, options);
      } else if (type === "string") {
        compressors.string(compressors, context, obj, invertedIndex, writer, options);
      } else if (type === "boolean") {
        writer.write(obj ? constants_1.BOOLEAN_TRUE_TOKEN : constants_1.BOOLEAN_FALSE_TOKEN);
      } else if (obj === null) {
        writer.write(constants_1.NULL_TOKEN);
      } else if (obj === void 0) {
        writer.write(constants_1.UNDEFINED_TOKEN);
      } else if (Array.isArray(obj)) {
        compressors.array(compressors, context, obj, invertedIndex, writer, options);
      } else if (obj instanceof Date) {
        compressors.date(compressors, context, obj.getTime(), invertedIndex, writer, options);
      } else {
        compressors.object(compressors, context, obj, invertedIndex, writer, options);
      }
    }
    exports.compressAny = compressAny;
  }
});

// ../../node_modules/zipson/lib/compressor/writer.js
var require_writer = __commonJS({
  "../../node_modules/zipson/lib/compressor/writer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ZipsonWriter = (
      /** @class */
      /* @__PURE__ */ function() {
        function ZipsonWriter2() {
        }
        return ZipsonWriter2;
      }()
    );
    exports.ZipsonWriter = ZipsonWriter;
    var ZipsonStringWriter = (
      /** @class */
      function(_super) {
        __extends(ZipsonStringWriter2, _super);
        function ZipsonStringWriter2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.value = "";
          return _this;
        }
        ZipsonStringWriter2.prototype.write = function(data) {
          this.value += data;
        };
        ZipsonStringWriter2.prototype.end = function() {
        };
        return ZipsonStringWriter2;
      }(ZipsonWriter)
    );
    exports.ZipsonStringWriter = ZipsonStringWriter;
  }
});

// ../../node_modules/zipson/lib/util.js
var require_util = __commonJS({
  "../../node_modules/zipson/lib/util.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var maxInteger = 2147483648;
    var minInteger = -2147483649;
    var base62 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function compressInteger(number) {
      if (number === 0) {
        return "0";
      }
      var result = "";
      var carry = number < 0 ? -number : number;
      var current = 0;
      var fraction;
      while (carry > 0) {
        carry = carry / 62;
        fraction = carry % 1;
        current = fraction * 62 + 0.1 << 0;
        carry -= fraction;
        result = base62[current] + result;
      }
      result = number < 0 ? "-" + result : result;
      return result;
    }
    exports.compressInteger = compressInteger;
    function decompressInteger(compressedInteger) {
      var value = 0;
      if (compressedInteger[0] === "0") {
        return value;
      } else {
        var negative = compressedInteger[0] === "-";
        var multiplier = 1;
        var leftBound = negative ? 1 : 0;
        for (var i = compressedInteger.length - 1; i >= leftBound; i--) {
          var code = compressedInteger.charCodeAt(i);
          var current = code - 48;
          if (code >= 97) {
            current -= 13;
          } else if (code >= 65) {
            current -= 7;
          }
          value += current * multiplier;
          multiplier *= 62;
        }
        return negative ? -value : value;
      }
    }
    exports.decompressInteger = decompressInteger;
    function compressFloat(float, fullPrecision) {
      if (fullPrecision === void 0) {
        fullPrecision = false;
      }
      if (fullPrecision) {
        var _a = float.toString().split("."), integer = _a[0], fraction = _a[1];
        var operator = integer === "-0" ? "-" : "";
        return "" + operator + compressInteger(parseInt(integer)) + constants_1.FLOAT_FULL_PRECISION_DELIMITER + fraction;
      } else {
        var integer = float >= maxInteger ? Math.floor(float) : float <= minInteger ? Math.ceil(float) : float << 0;
        var fraction = Math.round(constants_1.FLOAT_COMPRESSION_PRECISION * (float % 1));
        return "" + compressInteger(integer) + constants_1.FLOAT_REDUCED_PRECISION_DELIMITER + compressInteger(fraction);
      }
    }
    exports.compressFloat = compressFloat;
    function decompressFloat(compressedFloat) {
      if (compressedFloat.indexOf(constants_1.FLOAT_FULL_PRECISION_DELIMITER) > -1) {
        var _a = compressedFloat.split(constants_1.FLOAT_FULL_PRECISION_DELIMITER), integer = _a[0], fraction = _a[1];
        var mult = integer === "-0" ? -1 : 1;
        var uncompressedInteger = decompressInteger(integer);
        return mult * parseFloat(uncompressedInteger + "." + fraction);
      } else {
        var _b = compressedFloat.split(constants_1.FLOAT_REDUCED_PRECISION_DELIMITER), integer = _b[0], fraction = _b[1];
        var uncompressedInteger = decompressInteger(integer);
        var uncompressedFraction = decompressInteger(fraction);
        return uncompressedInteger + uncompressedFraction / constants_1.FLOAT_COMPRESSION_PRECISION;
      }
    }
    exports.decompressFloat = decompressFloat;
  }
});

// ../../node_modules/zipson/lib/compressor/array.js
var require_array = __commonJS({
  "../../node_modules/zipson/lib/compressor/array.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var writer_1 = require_writer();
    var util_1 = require_util();
    function compressArray(compressors, context, array, invertedIndex, writer, options) {
      context.arrayLevel++;
      if (context.arrayLevel > context.arrayItemWriters.length) {
        context.arrayItemWriters.push(new writer_1.ZipsonStringWriter());
      }
      var arrayItemWriter = context.arrayItemWriters[context.arrayLevel - 1];
      var parentWriter = context.arrayItemWriters[context.arrayLevel - 2] || writer;
      parentWriter.write(constants_1.ARRAY_START_TOKEN);
      var previousItem = "";
      var repeatedTimes = 0;
      var repeatManyCount = 0;
      var templateObject = new compressors.template.Object(array[0], array[1]);
      if (templateObject.isTemplating) {
        templateObject.compressTemplate(compressors, context, invertedIndex, parentWriter, options);
      }
      for (var i = 0; i < array.length; i++) {
        var item = array[i];
        arrayItemWriter.value = "";
        if (item === void 0) {
          item = null;
        }
        if (i > 1 && templateObject.isTemplating) {
          templateObject.isNextTemplateable(array[i], parentWriter);
        }
        if (templateObject.isTemplating) {
          templateObject.compressTemplateValues(compressors, context, invertedIndex, arrayItemWriter, options, array[i]);
        } else {
          compressors.any(compressors, context, item, invertedIndex, arrayItemWriter, options);
        }
        if (arrayItemWriter.value === previousItem) {
          repeatedTimes++;
          if (repeatedTimes >= constants_1.ARRAY_REPEAT_COUNT_THRESHOLD) {
            if (repeatManyCount === 0) {
              parentWriter.write(constants_1.ARRAY_REPEAT_MANY_TOKEN);
            }
            repeatManyCount++;
          } else {
            parentWriter.write(constants_1.ARRAY_REPEAT_TOKEN);
          }
        } else {
          repeatedTimes = 0;
          if (repeatManyCount > 0) {
            parentWriter.write(util_1.compressInteger(repeatManyCount));
            repeatManyCount = 0;
          }
          parentWriter.write(arrayItemWriter.value);
          previousItem = arrayItemWriter.value;
        }
      }
      if (repeatManyCount > 0) {
        parentWriter.write(util_1.compressInteger(repeatManyCount));
      }
      if (templateObject.isTemplating) {
        templateObject.end(parentWriter);
      }
      parentWriter.write(constants_1.ARRAY_END_TOKEN);
      context.arrayLevel--;
    }
    exports.compressArray = compressArray;
  }
});

// ../../node_modules/zipson/lib/compressor/string.js
var require_string = __commonJS({
  "../../node_modules/zipson/lib/compressor/string.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var util_1 = require_util();
    function compressString(compressors, context, obj, invertedIndex, writer, options) {
      var foundRef;
      var stringIdent = constants_1.STRING_IDENT_PREFIX + obj;
      if (options.detectUtcTimestamps && obj[obj.length - 1] === "Z" && obj.match(constants_1.DATE_REGEX)) {
        var date = Date.parse(obj);
        compressors.date(compressors, context, date, invertedIndex, writer, options);
      } else if ((foundRef = invertedIndex.stringMap[stringIdent]) !== void 0) {
        writer.write("" + constants_1.REF_STRING_TOKEN + foundRef);
      } else {
        var ref = util_1.compressInteger(invertedIndex.stringCount);
        var newRef = "" + constants_1.STRING_TOKEN + obj.replace(constants_1.REGEX_ESCAPE_CHARACTER, constants_1.ESCAPE_CHARACTER + constants_1.ESCAPE_CHARACTER).replace(constants_1.REGEX_STRING_TOKEN, constants_1.ESCAPED_STRING_TOKEN) + constants_1.STRING_TOKEN;
        if (ref.length + constants_1.REFERENCE_HEADER_LENGTH + 1 < newRef.length) {
          invertedIndex.stringMap[stringIdent] = ref;
          invertedIndex.stringCount++;
          writer.write(newRef);
        } else {
          writer.write("" + constants_1.UNREFERENCED_STRING_TOKEN + obj.replace(constants_1.REGEX_ESCAPE_CHARACTER, constants_1.ESCAPE_CHARACTER + constants_1.ESCAPE_CHARACTER).replace(constants_1.REGEX_UNREFERENCED_STRING_TOKEN, constants_1.ESCAPED_UNREFERENCED_STRING_TOKEN) + constants_1.UNREFERENCED_STRING_TOKEN);
        }
      }
    }
    exports.compressString = compressString;
  }
});

// ../../node_modules/zipson/lib/compressor/number.js
var require_number = __commonJS({
  "../../node_modules/zipson/lib/compressor/number.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var util_1 = require_util();
    function compressNumber(compressors, context, obj, invertedIndex, writer, options) {
      var foundRef;
      if (obj % 1 === 0) {
        if (obj < constants_1.INTEGER_SMALL_EXCLUSIVE_BOUND_UPPER && obj > constants_1.INTEGER_SMALL_EXCLUSIVE_BOUND_LOWER) {
          writer.write(constants_1.INTEGER_SMALL_TOKENS[obj + constants_1.INTEGER_SMALL_TOKEN_ELEMENT_OFFSET]);
        } else if ((foundRef = invertedIndex.integerMap[obj]) !== void 0) {
          writer.write("" + constants_1.REF_INTEGER_TOKEN + foundRef);
        } else {
          var ref = util_1.compressInteger(invertedIndex.integerCount);
          var compressedInteger = util_1.compressInteger(obj);
          var newRef = "" + constants_1.INTEGER_TOKEN + compressedInteger;
          if (ref.length + constants_1.REFERENCE_HEADER_LENGTH < newRef.length) {
            invertedIndex.integerMap[obj] = ref;
            invertedIndex.integerCount++;
            writer.write(newRef);
          } else {
            writer.write("" + constants_1.UNREFERENCED_INTEGER_TOKEN + compressedInteger);
          }
        }
      } else {
        var compressedFloat = util_1.compressFloat(obj, options.fullPrecisionFloats);
        if ((foundRef = invertedIndex.floatMap[compressedFloat]) !== void 0) {
          writer.write("" + constants_1.REF_FLOAT_TOKEN + foundRef);
        } else {
          var ref = util_1.compressInteger(invertedIndex.floatCount);
          var newRef = "" + constants_1.FLOAT_TOKEN + compressedFloat;
          if (ref.length + constants_1.REFERENCE_HEADER_LENGTH < newRef.length) {
            invertedIndex.floatMap[compressedFloat] = ref;
            invertedIndex.floatCount++;
            writer.write(newRef);
          } else {
            writer.write("" + constants_1.UNREFERENCED_FLOAT_TOKEN + compressedFloat);
          }
        }
      }
    }
    exports.compressNumber = compressNumber;
  }
});

// ../../node_modules/zipson/lib/compressor/object.js
var require_object = __commonJS({
  "../../node_modules/zipson/lib/compressor/object.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    function compressObject(compressors, context, obj, invertedIndex, writer, options) {
      writer.write(constants_1.OBJECT_START_TOKEN);
      var keys = Object.keys(obj);
      var templateObject = new compressors.template.Object(obj[keys[0]], obj[keys[1]]);
      if (templateObject.isTemplating) {
        templateObject.compressTemplate(compressors, context, invertedIndex, writer, options);
      }
      for (var i = 0; i < keys.length; i++) {
        if (i > 1 && templateObject.isTemplating) {
          templateObject.isNextTemplateable(obj[keys[i]], writer);
        }
        if (templateObject.isTemplating) {
          compressors.string(compressors, context, keys[i], invertedIndex, writer, options);
          templateObject.compressTemplateValues(compressors, context, invertedIndex, writer, options, obj[keys[i]]);
        } else {
          var key = keys[i];
          var val = obj[key];
          if (val !== void 0) {
            compressors.string(compressors, context, key, invertedIndex, writer, options);
            compressors.any(compressors, context, val, invertedIndex, writer, options);
          }
        }
      }
      ;
      if (templateObject.isTemplating) {
        templateObject.end(writer);
      }
      writer.write(constants_1.OBJECT_END_TOKEN);
    }
    exports.compressObject = compressObject;
  }
});

// ../../node_modules/zipson/lib/compressor/date.js
var require_date = __commonJS({
  "../../node_modules/zipson/lib/compressor/date.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var util_1 = require_util();
    function compressDate(compressors, context, obj, invertedIndex, writer, options) {
      var foundRef;
      var lowPrecisionDate = obj / constants_1.DATE_LOW_PRECISION;
      var isLowPrecision = lowPrecisionDate % 1 === 0;
      if (isLowPrecision) {
        if ((foundRef = invertedIndex.lpDateMap[lowPrecisionDate]) !== void 0) {
          writer.write("" + constants_1.REF_LP_DATE_TOKEN + foundRef);
        } else {
          var ref = util_1.compressInteger(invertedIndex.lpDateCount);
          var compressedDate = util_1.compressInteger(lowPrecisionDate);
          var newRef = "" + constants_1.LP_DATE_TOKEN + compressedDate;
          if (ref.length + constants_1.REFERENCE_HEADER_LENGTH < newRef.length) {
            invertedIndex.lpDateMap[lowPrecisionDate] = ref;
            invertedIndex.lpDateCount++;
            writer.write(newRef);
          } else {
            writer.write("" + constants_1.UNREFERENCED_LP_DATE_TOKEN + compressedDate);
          }
        }
      } else {
        if ((foundRef = invertedIndex.dateMap[obj]) !== void 0) {
          writer.write("" + constants_1.REF_DATE_TOKEN + foundRef);
        } else {
          var ref = util_1.compressInteger(invertedIndex.dateCount);
          var compressedDate = util_1.compressInteger(obj);
          var newRef = "" + constants_1.DATE_TOKEN + compressedDate;
          if (ref.length + constants_1.REFERENCE_HEADER_LENGTH < newRef.length) {
            invertedIndex.dateMap[obj] = ref;
            invertedIndex.dateCount++;
            writer.write(newRef);
          } else {
            writer.write("" + constants_1.UNREFERENCED_DATE_TOKEN + compressedDate);
          }
        }
      }
    }
    exports.compressDate = compressDate;
  }
});

// ../../node_modules/zipson/lib/compressor/util.js
var require_util2 = __commonJS({
  "../../node_modules/zipson/lib/compressor/util.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObject(obj) {
      var type = typeof obj;
      if (type === "number") {
        return false;
      } else if (type === "string") {
        return false;
      } else if (type === "boolean") {
        return false;
      } else if (obj === null) {
        return false;
      } else if (Array.isArray(obj)) {
        return false;
      } else if (obj instanceof Date) {
        return false;
      } else if (obj === void 0) {
        return false;
      } else {
        return true;
      }
    }
    exports.isObject = isObject;
  }
});

// ../../node_modules/zipson/lib/compressor/template/object.js
var require_object2 = __commonJS({
  "../../node_modules/zipson/lib/compressor/template/object.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var util_1 = require_util2();
    var TemplateObject = (
      /** @class */
      function() {
        function TemplateObject2(a, b) {
          this.isTemplating = false;
          this.struct = [];
          if (a != null && b != null) {
            this.isTemplating = buildTemplate(a, b, this.struct);
          }
        }
        TemplateObject2.prototype.compressTemplate = function(compressors, context, invertedIndex, writer, options) {
          compresObjectTemplate(compressors, context, invertedIndex, writer, options, this.struct);
        };
        TemplateObject2.prototype.compressTemplateValues = function(compressors, context, invertedIndex, writer, options, obj) {
          compressObjectValues(compressors, context, invertedIndex, writer, options, this.struct, obj);
        };
        TemplateObject2.prototype.isNextTemplateable = function(obj, writer) {
          this.isTemplating = conformsToStructure(this.struct, obj);
          if (!this.isTemplating) {
            writer.write(constants_1.TEMPLATE_OBJECT_FINAL);
          }
        };
        TemplateObject2.prototype.end = function(writer) {
          writer.write(constants_1.TEMPLATE_OBJECT_FINAL);
        };
        return TemplateObject2;
      }()
    );
    exports.TemplateObject = TemplateObject;
    function buildTemplate(a, b, struct, level) {
      if (level === void 0) {
        level = 0;
      }
      if (level > 6) {
        return false;
      }
      var keysA = Object.keys(a);
      var keysB = Object.keys(b);
      if (keysA.length !== keysB.length) {
        return false;
      }
      if (keysA.length > 10) {
        return false;
      }
      keysA.sort(function(a2, b2) {
        return a2.localeCompare(b2);
      });
      keysB.sort(function(a2, b2) {
        return a2.localeCompare(b2);
      });
      for (var i = 0; i < keysA.length; i++) {
        var keyA = keysA[i];
        var keyB = keysB[i];
        if (keyA !== keyB) {
          return false;
        }
        var valueA = a[keyA];
        var valueB = b[keyB];
        if (util_1.isObject(valueA)) {
          if (!util_1.isObject(valueB)) {
            return false;
          }
          var nextStruct = [];
          struct.push([keyA, nextStruct]);
          if (!buildTemplate(valueA, valueB, nextStruct, level + 1)) {
            return false;
          }
        } else if (util_1.isObject(valueB)) {
          return false;
        } else {
          struct.push([keyA]);
        }
      }
      return level > 0 || util_1.isObject(a);
    }
    function conformsToStructure(struct, obj) {
      if (!obj) {
        return false;
      }
      if (Object.keys(obj).length !== struct.length) {
        return false;
      }
      for (var i = 0; i < struct.length; i++) {
        var key = struct[i][0];
        var isNested = struct[i].length > 1;
        if (obj[key] === void 0) {
          return false;
        }
        if (isNested) {
          var x = struct[i];
          var y = x[1];
          if (!conformsToStructure(struct[i][1], obj[key])) {
            return false;
          }
        } else {
          if (util_1.isObject(obj[key])) {
            return false;
          }
        }
      }
      return true;
    }
    function compresObjectTemplate(compressors, context, invertedIndex, writer, options, struct) {
      writer.write(constants_1.TEMPLATE_OBJECT_START);
      for (var i = 0; i < struct.length; i++) {
        var key = struct[i][0];
        var isNested = struct[i].length > 1;
        compressors.string(compressors, context, key, invertedIndex, writer, options);
        if (isNested) {
          compresObjectTemplate(compressors, context, invertedIndex, writer, options, struct[i][1]);
        }
      }
      ;
      writer.write(constants_1.TEMPLATE_OBJECT_END);
    }
    function compressObjectValues(compressors, context, invertedIndex, writer, options, struct, obj) {
      for (var i = 0; i < struct.length; i++) {
        var key = struct[i][0];
        var value = obj[key];
        var isNested = struct[i].length > 1;
        if (isNested) {
          compressObjectValues(compressors, context, invertedIndex, writer, options, struct[i][1], value);
        } else {
          compressors.any(compressors, context, value, invertedIndex, writer, options);
        }
      }
      ;
    }
  }
});

// ../../node_modules/zipson/lib/compress.js
var require_compress = __commonJS({
  "../../node_modules/zipson/lib/compress.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var any_1 = require_any();
    var array_1 = require_array();
    var string_1 = require_string();
    var number_1 = require_number();
    var object_1 = require_object();
    var date_1 = require_date();
    var object_2 = require_object2();
    var compressors = {
      any: any_1.compressAny,
      array: array_1.compressArray,
      object: object_1.compressObject,
      string: string_1.compressString,
      date: date_1.compressDate,
      number: number_1.compressNumber,
      template: {
        Object: object_2.TemplateObject
      }
    };
    function makeCompressContext() {
      return {
        arrayItemWriters: [],
        arrayLevel: 0
      };
    }
    exports.makeCompressContext = makeCompressContext;
    function makeInvertedIndex() {
      return {
        stringMap: {},
        integerMap: {},
        floatMap: {},
        dateMap: {},
        lpDateMap: {},
        stringCount: 0,
        integerCount: 0,
        floatCount: 0,
        dateCount: 0,
        lpDateCount: 0
      };
    }
    exports.makeInvertedIndex = makeInvertedIndex;
    function compress(context, obj, invertedIndex, writer, options) {
      compressors.any(compressors, context, obj, invertedIndex, writer, options);
    }
    exports.compress = compress;
  }
});

// ../../node_modules/zipson/lib/decompressor/common.js
var require_common = __commonJS({
  "../../node_modules/zipson/lib/decompressor/common.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SKIP_SCALAR = {};
    var TargetType;
    (function(TargetType2) {
      TargetType2["ARRAY"] = "ARRAY";
      TargetType2["OBJECT"] = "OBJECT";
      TargetType2["SCALAR"] = "SCALAR";
      TargetType2["TEMPLATE_OBJECT"] = "TEMPLATE_OBJECT";
      TargetType2["TEMPLATE_OBJECT_PROPERTIES"] = "TEMPLATE_OBJECT_PROPERTIES";
      TargetType2["TEMPLATE_OBJECT_ELEMENTS"] = "TEMPLATE_OBJECT_ELEMENTS";
    })(TargetType = exports.TargetType || (exports.TargetType = {}));
  }
});

// ../../node_modules/zipson/lib/decompressor/scalar.js
var require_scalar = __commonJS({
  "../../node_modules/zipson/lib/decompressor/scalar.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var common_1 = require_common();
    var util_1 = require_util();
    function decompressScalar(token, data, cursor, orderedIndex) {
      var startIndex = cursor.index;
      var endIndex = cursor.index + 1;
      var foundStringToken;
      if (token === constants_1.STRING_TOKEN && (foundStringToken = constants_1.STRING_TOKEN) || token === constants_1.UNREFERENCED_STRING_TOKEN && (foundStringToken = constants_1.UNREFERENCED_STRING_TOKEN)) {
        var escaped = true;
        while (escaped && endIndex < data.length) {
          endIndex = data.indexOf(foundStringToken, endIndex);
          var iNumEscapeCharacters = 1;
          escaped = false;
          while (data[endIndex - iNumEscapeCharacters] === constants_1.ESCAPE_CHARACTER) {
            escaped = iNumEscapeCharacters % 2 === 1;
            iNumEscapeCharacters++;
          }
          endIndex++;
        }
        if (endIndex <= startIndex) {
          endIndex = data.length;
        }
      } else {
        while (!(data.charCodeAt(endIndex) > constants_1.DELIMITING_TOKENS_THRESHOLD) && endIndex < data.length) {
          endIndex++;
        }
      }
      if (!cursor.drain && endIndex === data.length) {
        return common_1.SKIP_SCALAR;
      }
      cursor.index = endIndex - 1;
      var tokenCharCode = token.charCodeAt(0);
      if (tokenCharCode > constants_1.INTEGER_SMALL_TOKEN_EXCLUSIVE_BOUND_LOWER && tokenCharCode < constants_1.INTEGER_SMALL_TOKEN_EXCLUSIVE_BOUND_UPPER) {
        return tokenCharCode + constants_1.INTEGER_SMALL_TOKEN_OFFSET;
      } else if (token === constants_1.ARRAY_REPEAT_MANY_TOKEN) {
        return util_1.decompressInteger(data.substring(startIndex + 1, endIndex));
      } else if (token === constants_1.REF_STRING_TOKEN) {
        return orderedIndex.strings[util_1.decompressInteger(data.substring(startIndex + 1, endIndex))];
      } else if (token === constants_1.REF_INTEGER_TOKEN) {
        return orderedIndex.integers[util_1.decompressInteger(data.substring(startIndex + 1, endIndex))];
      } else if (token === constants_1.REF_FLOAT_TOKEN) {
        return orderedIndex.floats[util_1.decompressInteger(data.substring(startIndex + 1, endIndex))];
      } else if (token === constants_1.REF_DATE_TOKEN) {
        return orderedIndex.dates[util_1.decompressInteger(data.substring(startIndex + 1, endIndex))];
      } else if (token === constants_1.REF_LP_DATE_TOKEN) {
        return orderedIndex.lpDates[util_1.decompressInteger(data.substring(startIndex + 1, endIndex))];
      } else if (token === constants_1.STRING_TOKEN) {
        return orderedIndex.strings[orderedIndex.strings.length] = data.substring(startIndex + 1, endIndex - 1).replace(constants_1.REGEX_ESCAPED_ESCAPE_CHARACTER, constants_1.ESCAPE_CHARACTER).replace(constants_1.REGEX_ESCAPED_STRING_TOKEN, constants_1.STRING_TOKEN);
      } else if (token === constants_1.INTEGER_TOKEN) {
        return orderedIndex.integers[orderedIndex.integers.length] = util_1.decompressInteger(data.substring(startIndex + 1, endIndex));
      } else if (token === constants_1.FLOAT_TOKEN) {
        return orderedIndex.floats[orderedIndex.floats.length] = util_1.decompressFloat(data.substring(startIndex + 1, endIndex));
      } else if (token === constants_1.DATE_TOKEN) {
        return orderedIndex.dates[orderedIndex.dates.length] = new Date(util_1.decompressInteger(data.substring(startIndex + 1, endIndex))).toISOString();
      } else if (token === constants_1.LP_DATE_TOKEN) {
        return orderedIndex.lpDates[orderedIndex.lpDates.length] = new Date(constants_1.DATE_LOW_PRECISION * util_1.decompressInteger(data.substring(startIndex + 1, endIndex))).toISOString();
      } else if (token === constants_1.UNREFERENCED_STRING_TOKEN) {
        return data.substring(startIndex + 1, endIndex - 1).replace(constants_1.REGEX_ESCAPED_ESCAPE_CHARACTER, constants_1.ESCAPE_CHARACTER).replace(constants_1.REGEX_UNREFERENCED_ESCAPED_STRING_TOKEN, constants_1.UNREFERENCED_STRING_TOKEN);
      } else if (token === constants_1.UNREFERENCED_INTEGER_TOKEN) {
        return util_1.decompressInteger(data.substring(startIndex + 1, endIndex));
      } else if (token === constants_1.UNREFERENCED_FLOAT_TOKEN) {
        return util_1.decompressFloat(data.substring(startIndex + 1, endIndex));
      } else if (token === constants_1.UNREFERENCED_DATE_TOKEN) {
        return new Date(util_1.decompressInteger(data.substring(startIndex + 1, endIndex))).toISOString();
      } else if (token === constants_1.UNREFERENCED_LP_DATE_TOKEN) {
        return new Date(constants_1.DATE_LOW_PRECISION * util_1.decompressInteger(data.substring(startIndex + 1, endIndex))).toISOString();
      } else if (token === constants_1.BOOLEAN_TRUE_TOKEN) {
        return true;
      } else if (token === constants_1.BOOLEAN_FALSE_TOKEN) {
        return false;
      } else if (token === constants_1.NULL_TOKEN) {
        return null;
      } else if (token === constants_1.UNDEFINED_TOKEN) {
        return void 0;
      }
      throw new Error("Unexpected scalar " + token + " at " + startIndex + "-" + endIndex);
    }
    exports.decompressScalar = decompressScalar;
  }
});

// ../../node_modules/zipson/lib/decompressor/template.js
var require_template = __commonJS({
  "../../node_modules/zipson/lib/decompressor/template.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function appendTemplateObjectValue(templateObjectTarget, targetValue) {
      var currentPath = templateObjectTarget.paths[templateObjectTarget.currentPathIndex];
      var i = 0;
      var targetObject = templateObjectTarget.currentObject;
      for (; i < currentPath.length - 1; i++) {
        var fragment = currentPath[i];
        targetObject = targetObject[fragment] = targetObject[fragment] || {};
      }
      if (targetValue !== void 0) {
        targetObject[currentPath[i]] = targetValue;
      }
    }
    function appendTemplateObjectPropertiesValue(templateObjectElementsTarget, targetValue) {
      if (templateObjectElementsTarget.currentPathIndex === -1) {
        templateObjectElementsTarget.value[targetValue] = templateObjectElementsTarget.currentObject = {};
      } else {
        appendTemplateObjectValue(templateObjectElementsTarget, targetValue);
      }
      if (++templateObjectElementsTarget.currentPathIndex === templateObjectElementsTarget.expectedPaths) {
        templateObjectElementsTarget.currentPathIndex = -1;
      }
    }
    exports.appendTemplateObjectPropertiesValue = appendTemplateObjectPropertiesValue;
    function appendTemplateObjectElementsValue(templateObjectPropertiesTarget, targetValue) {
      if (templateObjectPropertiesTarget.currentPathIndex === 0) {
        templateObjectPropertiesTarget.currentObject = {};
        templateObjectPropertiesTarget.value.push(templateObjectPropertiesTarget.currentObject);
      }
      appendTemplateObjectValue(templateObjectPropertiesTarget, targetValue);
      if (++templateObjectPropertiesTarget.currentPathIndex === templateObjectPropertiesTarget.expectedPaths) {
        templateObjectPropertiesTarget.currentPathIndex = 0;
      }
    }
    exports.appendTemplateObjectElementsValue = appendTemplateObjectElementsValue;
  }
});

// ../../node_modules/zipson/lib/decompressor/element.js
var require_element = __commonJS({
  "../../node_modules/zipson/lib/decompressor/element.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var common_1 = require_common();
    var scalar_1 = require_scalar();
    var template_1 = require_template();
    function decompressElement(c, cursor, data, orderedIndex) {
      var targetValue;
      if (c === constants_1.ARRAY_END_TOKEN || c === constants_1.OBJECT_END_TOKEN) {
        targetValue = cursor.currentTarget.value;
        cursor.currentTarget = cursor.stack[cursor.pointer - 1];
        cursor.pointer--;
      } else {
        targetValue = scalar_1.decompressScalar(c, data, cursor, orderedIndex);
        if (targetValue === common_1.SKIP_SCALAR) {
          return false;
        }
      }
      if (cursor.currentTarget.type === common_1.TargetType.SCALAR) {
        cursor.currentTarget.value = targetValue;
      } else if (cursor.currentTarget.type === common_1.TargetType.ARRAY) {
        cursor.currentTarget.value[cursor.currentTarget.value.length] = targetValue;
      } else if (cursor.currentTarget.type === common_1.TargetType.OBJECT) {
        if (cursor.currentTarget.key != null) {
          cursor.currentTarget.value[cursor.currentTarget.key] = targetValue;
          cursor.currentTarget.key = void 0;
        } else {
          cursor.currentTarget.key = targetValue;
        }
      } else if (cursor.currentTarget.type === common_1.TargetType.TEMPLATE_OBJECT) {
        cursor.currentTarget.currentToken = targetValue;
        cursor.currentTarget.currentTokens.push(targetValue);
      } else if (cursor.currentTarget.type === common_1.TargetType.TEMPLATE_OBJECT_PROPERTIES) {
        template_1.appendTemplateObjectPropertiesValue(cursor.currentTarget, targetValue);
      } else if (cursor.currentTarget.type === common_1.TargetType.TEMPLATE_OBJECT_ELEMENTS) {
        template_1.appendTemplateObjectElementsValue(cursor.currentTarget, targetValue);
      }
      return true;
    }
    exports.decompressElement = decompressElement;
  }
});

// ../../node_modules/zipson/lib/decompressor/stages.js
var require_stages = __commonJS({
  "../../node_modules/zipson/lib/decompressor/stages.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants_1 = require_constants();
    var common_1 = require_common();
    var scalar_1 = require_scalar();
    var element_1 = require_element();
    function decompressStages(cursor, data, orderedIndex) {
      for (; cursor.index < data.length; cursor.index++) {
        var c = data[cursor.index];
        if (c === constants_1.ARRAY_START_TOKEN) {
          cursor.currentTarget = { type: common_1.TargetType.ARRAY, value: [] };
          cursor.stack[++cursor.pointer] = cursor.currentTarget;
        } else if (c === constants_1.OBJECT_START_TOKEN) {
          cursor.currentTarget = { type: common_1.TargetType.OBJECT, value: {} };
          cursor.stack[++cursor.pointer] = cursor.currentTarget;
        } else if (c === constants_1.ARRAY_REPEAT_TOKEN && (cursor.currentTarget.type === common_1.TargetType.ARRAY || cursor.currentTarget.type === common_1.TargetType.TEMPLATE_OBJECT_ELEMENTS)) {
          var repeatedItem = cursor.currentTarget.value[cursor.currentTarget.value.length - 1];
          cursor.currentTarget.value.push(repeatedItem);
        } else if (c === constants_1.ARRAY_REPEAT_MANY_TOKEN && (cursor.currentTarget.type === common_1.TargetType.ARRAY || cursor.currentTarget.type === common_1.TargetType.TEMPLATE_OBJECT_ELEMENTS)) {
          var repeatCount = scalar_1.decompressScalar(data[cursor.index], data, cursor, orderedIndex);
          if (repeatCount === common_1.SKIP_SCALAR) {
            return;
          }
          var repeatedItem = cursor.currentTarget.value[cursor.currentTarget.value.length - 1];
          for (var i = 0; i < repeatCount; i++) {
            cursor.currentTarget.value.push(repeatedItem);
          }
        } else if (c === constants_1.TEMPLATE_OBJECT_START && (cursor.currentTarget.type === common_1.TargetType.TEMPLATE_OBJECT || cursor.currentTarget.type === common_1.TargetType.OBJECT || cursor.currentTarget.type === common_1.TargetType.ARRAY)) {
          if (cursor.currentTarget.type !== common_1.TargetType.TEMPLATE_OBJECT) {
            var parentTarget = cursor.currentTarget;
            cursor.currentTarget = { type: common_1.TargetType.TEMPLATE_OBJECT, value: void 0, currentTokens: [], currentRoute: [], paths: [], level: 0, parentTarget };
            cursor.stack[++cursor.pointer] = cursor.currentTarget;
          } else {
            for (var i = 0; i < cursor.currentTarget.currentTokens.length - 1; i++) {
              var currentToken = cursor.currentTarget.currentTokens[i];
              cursor.currentTarget.paths[cursor.currentTarget.paths.length] = cursor.currentTarget.currentRoute.concat(currentToken);
            }
            if (cursor.currentTarget.currentToken != null) {
              cursor.currentTarget.currentRoute.push(cursor.currentTarget.currentToken);
            }
            cursor.currentTarget.currentTokens = [];
            cursor.currentTarget.level++;
          }
        } else if (c === constants_1.TEMPLATE_OBJECT_END && cursor.currentTarget.type === common_1.TargetType.TEMPLATE_OBJECT) {
          for (var i = 0; i < cursor.currentTarget.currentTokens.length; i++) {
            var currentToken = cursor.currentTarget.currentTokens[i];
            cursor.currentTarget.paths[cursor.currentTarget.paths.length] = cursor.currentTarget.currentRoute.concat(currentToken);
          }
          cursor.currentTarget.currentTokens = [];
          cursor.currentTarget.currentRoute = cursor.currentTarget.currentRoute.slice(0, -1);
          cursor.currentTarget.level--;
          if (cursor.currentTarget.level < 0) {
            var paths = cursor.currentTarget.paths;
            var parentTarget = cursor.currentTarget.parentTarget;
            cursor.pointer--;
            if (parentTarget.type === common_1.TargetType.ARRAY) {
              cursor.currentTarget = { type: common_1.TargetType.TEMPLATE_OBJECT_ELEMENTS, value: parentTarget.value, paths, currentPathIndex: 0, expectedPaths: paths.length, currentObject: {} };
            } else if (parentTarget.type === common_1.TargetType.OBJECT) {
              cursor.currentTarget = { type: common_1.TargetType.TEMPLATE_OBJECT_PROPERTIES, value: parentTarget.value, paths, currentPathIndex: -1, expectedPaths: paths.length, currentObject: {} };
            }
            cursor.stack[++cursor.pointer] = cursor.currentTarget;
          }
        } else if (c === constants_1.TEMPLATE_OBJECT_FINAL) {
          cursor.currentTarget = cursor.stack[--cursor.pointer];
        } else {
          if (!element_1.decompressElement(c, cursor, data, orderedIndex)) {
            return;
          }
        }
      }
    }
    exports.decompressStages = decompressStages;
  }
});

// ../../node_modules/zipson/lib/decompress.js
var require_decompress = __commonJS({
  "../../node_modules/zipson/lib/decompress.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var common_1 = require_common();
    var stages_1 = require_stages();
    function makeOrderedIndex() {
      return {
        strings: [],
        integers: [],
        floats: [],
        dates: [],
        lpDates: []
      };
    }
    exports.makeOrderedIndex = makeOrderedIndex;
    function makeCursor(drain) {
      var rootTarget = { type: common_1.TargetType.SCALAR, value: void 0 };
      var stack = new Array(10);
      stack[0] = rootTarget;
      return { index: 0, rootTarget, stack, currentTarget: rootTarget, pointer: 0, drain };
    }
    function decompress(data, orderedIndex) {
      var cursor = makeCursor(true);
      stages_1.decompressStages(cursor, data, orderedIndex);
      return cursor.rootTarget.value;
    }
    exports.decompress = decompress;
    function decompressIncremental(orderedIndex) {
      var cursor = makeCursor(false);
      var buffer = "";
      function increment(data) {
        if (data === null) {
          cursor.drain = true;
        } else if (data.length === 0) {
          return;
        } else {
          buffer += data;
        }
        var cursorIndexBefore = cursor.index;
        stages_1.decompressStages(cursor, buffer, orderedIndex);
        var movedAmount = cursor.index - cursorIndexBefore;
        if (movedAmount > 0) {
          buffer = buffer.substring(movedAmount);
          cursor.index -= movedAmount;
        }
      }
      return { increment, cursor };
    }
    exports.decompressIncremental = decompressIncremental;
  }
});

// ../../node_modules/zipson/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/zipson/lib/index.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function __export(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var compress_1 = require_compress();
    var writer_1 = require_writer();
    var decompress_1 = require_decompress();
    __export(require_writer());
    __export(require_common());
    function parse(data) {
      var orderedIndex = decompress_1.makeOrderedIndex();
      return decompress_1.decompress(data, orderedIndex);
    }
    exports.parse = parse;
    function parseIncremental() {
      var orderedIndex = decompress_1.makeOrderedIndex();
      var _a = decompress_1.decompressIncremental(orderedIndex), cursor = _a.cursor, increment = _a.increment;
      return function(data) {
        increment(data);
        if (data === null) {
          return cursor.rootTarget.value;
        }
      };
    }
    exports.parseIncremental = parseIncremental;
    function stringifyTo(data, writer, options) {
      if (options === void 0) {
        options = {};
      }
      var invertedIndex = compress_1.makeInvertedIndex();
      var context = compress_1.makeCompressContext();
      compress_1.compress(context, data, invertedIndex, writer, options);
      writer.end();
    }
    exports.stringifyTo = stringifyTo;
    function stringify(data, options) {
      var writer = new writer_1.ZipsonStringWriter();
      stringifyTo(data, writer, options);
      return writer.value;
    }
    exports.stringify = stringify;
  }
});
export default require_lib();
//# sourceMappingURL=zipson.js.map
