{"version":3,"file":"tasks-DtSsBL6W.js","sources":["../../../../node_modules/lodash/uniq.js","../../src/helpers/query/tasks.js"],"sourcesContent":["var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n","import { toValue } from 'vue';\nimport _mapValues from 'lodash/mapValues';\nimport _uniq from 'lodash/uniq';\nimport _without from 'lodash/without';\nimport { convertValues, getAxiosInstance, mapFields, fetchDocsById, getBaseDocumentPath } from './utils';\nimport { FIRESTORE_DATABASES, FIRESTORE_COLLECTIONS } from '../../constants/firebase';\n\nexport const getTasksRequestBody = ({\n  registered = true,\n  allData = false,\n  orderBy,\n  aggregationQuery,\n  pageLimit,\n  page,\n  paginate = false,\n  select = ['name'],\n}) => {\n  const requestBody = { structuredQuery: {} };\n\n  if (orderBy) {\n    requestBody.structuredQuery.orderBy = orderBy;\n  }\n\n  if (!aggregationQuery) {\n    if (paginate) {\n      requestBody.structuredQuery.limit = pageLimit;\n      requestBody.structuredQuery.offset = page * pageLimit;\n    }\n\n    if (!allData) {\n      requestBody.structuredQuery.select = {\n        fields: select.map((field) => ({ fieldPath: field })),\n      };\n    }\n  }\n\n  requestBody.structuredQuery.from = [\n    {\n      collectionId: 'tasks',\n      allDescendants: false,\n    },\n  ];\n\n  if (registered) {\n    requestBody.structuredQuery.where = {\n      fieldFilter: {\n        field: { fieldPath: 'registered' },\n        op: 'EQUAL',\n        value: { booleanValue: true },\n      },\n    };\n  }\n\n  if (aggregationQuery) {\n    return {\n      structuredAggregationQuery: {\n        ...requestBody,\n        aggregations: [\n          {\n            alias: 'count',\n            count: {},\n          },\n        ],\n      },\n    };\n  }\n\n  return requestBody;\n};\n\nexport const taskFetcher = async (registered = true, allData = false, select = ['name', 'testData', 'demoData']) => {\n  const axiosInstance = getAxiosInstance();\n  const requestBody = getTasksRequestBody({\n    registered,\n    allData,\n    aggregationQuery: false,\n    paginate: false,\n    select: allData ? '' : select,\n  });\n\n  return axiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(({ data }) => mapFields(data));\n};\n\n/**\n * Fetch task documents by their IDs.\n *\n * @param {Array<String>} taskIds â€“ The array of task IDs to fetch.\n * @returns {Promise<Array<Object>>} The array of task documents.\n */\nexport const fetchByTaskId = async (taskIds) => {\n  const taskDocs = toValue(taskIds).map((taskId) => ({\n    collection: FIRESTORE_COLLECTIONS.TASKS,\n    docId: taskId,\n  }));\n\n  return fetchDocsById(taskDocs, FIRESTORE_DATABASES.ADMIN);\n};\n\nexport const getVariantsRequestBody = ({ registered = false, aggregationQuery, pageLimit, page, paginate = false }) => {\n  const requestBody = { structuredQuery: {} };\n\n  if (!aggregationQuery) {\n    if (paginate) {\n      requestBody.structuredQuery.limit = pageLimit;\n      requestBody.structuredQuery.offset = page * pageLimit;\n    }\n  }\n\n  requestBody.structuredQuery.from = [\n    {\n      collectionId: 'variants',\n      allDescendants: true,\n    },\n  ];\n\n  if (registered) {\n    requestBody.structuredQuery.where = {\n      fieldFilter: {\n        field: { fieldPath: 'registered' },\n        op: 'EQUAL',\n        value: { booleanValue: true },\n      },\n    };\n  }\n\n  if (aggregationQuery) {\n    return {\n      structuredAggregationQuery: {\n        ...requestBody,\n        aggregations: [\n          {\n            alias: 'count',\n            count: {},\n          },\n        ],\n      },\n    };\n  }\n\n  return requestBody;\n};\n\nexport const variantsFetcher = async (registered = false) => {\n  const axiosInstance = getAxiosInstance();\n  const requestBody = getVariantsRequestBody({\n    registered,\n    aggregationQuery: false,\n    paginate: false,\n  });\n\n  return axiosInstance\n    .post(`${getBaseDocumentPath()}:runQuery`, requestBody)\n    .then(async ({ data }) => {\n      // Convert to regular object. Second arg is true to return parent doc ID as well.\n      const variants = mapFields(data, true);\n\n      // Retrieve all paths to the parent task documents. Note that there will be\n      // duplicates so we use _uniq. We also use _without to remove undefined\n      // values. The undefined values come from continuation tokens when the query\n      // is paginated.\n      const taskDocPaths = _uniq(\n        _without(\n          data.map((taskDoc) => {\n            if (taskDoc.document?.name) {\n              return taskDoc.document.name.split('/variants/')[0];\n            } else {\n              return undefined;\n            }\n          }),\n          undefined,\n        ),\n      );\n\n      // Use batchGet to get all task docs with one post request\n      const batchTaskDocs = await axiosInstance\n        .post(`${getBaseDocumentPath()}:batchGet`, {\n          documents: taskDocPaths,\n        })\n        .then(({ data }) => {\n          return _without(\n            data.map(({ found }) => {\n              if (found) {\n                return {\n                  name: found.name,\n                  data: {\n                    id: found.name.split('/tasks/')[1],\n                    ..._mapValues(found.fields, (value) => convertValues(value)),\n                  },\n                };\n              }\n              return undefined;\n            }),\n            undefined,\n          );\n        });\n\n      const taskDocDict = batchTaskDocs.reduce((acc, task) => {\n        acc[task.data.id] = { ...task };\n        return acc;\n      }, {});\n\n      // But the order of batchGet is not guaranteed, so we need to match the task\n      // docs back with their variants.\n      return variants.map((variant) => {\n        const task = taskDocDict[variant.parentDoc];\n        return {\n          id: variant.id,\n          variant,\n          task: task.data,\n        };\n      });\n    })\n    .catch((error) => {\n      console.error(error);\n      return [];\n    });\n};\n"],"names":["baseUniq","require$$0","uniq","array","uniq_1","getTasksRequestBody","registered","allData","orderBy","aggregationQuery","pageLimit","page","paginate","select","requestBody","field","taskFetcher","axiosInstance","getAxiosInstance","getBaseDocumentPath","data","mapFields","fetchByTaskId","taskIds","taskDocs","toValue","taskId","FIRESTORE_COLLECTIONS","fetchDocsById","FIRESTORE_DATABASES","getVariantsRequestBody","variantsFetcher","variants","taskDocPaths","_uniq","_without","taskDoc","_a","taskDocDict","found","_mapValues","value","convertValues","acc","task","variant","error"],"mappings":"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","x_google_ignoreList":[0]}