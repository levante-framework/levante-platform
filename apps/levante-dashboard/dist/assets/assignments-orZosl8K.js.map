{"version":3,"file":"assignments-orZosl8K.js","sources":["../../../../node_modules/lodash/replace.js","../../src/helpers/query/assignments.js"],"sourcesContent":["var toString = require('./toString');\n\n/**\n * Replaces matches for `pattern` in `string` with `replacement`.\n *\n * **Note:** This method is based on\n * [`String#replace`](https://mdn.io/String/replace).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to modify.\n * @param {RegExp|string} pattern The pattern to replace.\n * @param {Function|string} replacement The match replacement.\n * @returns {string} Returns the modified string.\n * @example\n *\n * _.replace('Hi Fred', 'Fred', 'Barney');\n * // => 'Hi Barney'\n */\nfunction replace() {\n  var args = arguments,\n      string = toString(args[0]);\n\n  return args.length < 3 ? string : string.replace(args[1], args[2]);\n}\n\nmodule.exports = replace;\n","import { toValue, toRaw } from 'vue';\nimport _find from 'lodash/find';\nimport _flatten from 'lodash/flatten';\nimport _get from 'lodash/get';\nimport _groupBy from 'lodash/groupBy';\nimport _mapValues from 'lodash/mapValues';\nimport _replace from 'lodash/replace';\nimport _uniq from 'lodash/uniq';\nimport _without from 'lodash/without';\nimport _isEmpty from 'lodash/isEmpty';\nimport { convertValues, getAxiosInstance, getBaseDocumentPath, getProjectId, mapFields } from './utils';\nimport { pluralizeFirestoreCollection, isLevante } from '@/helpers';\n\nconst userSelectFields = ['name', 'assessmentPid', 'username', 'studentData', 'schools', 'classes', 'userType'];\n\nconst assignmentSelectFields = [\n  'assessments',\n  'assigningOrgs',\n  'completed',\n  'dateAssigned',\n  'dateClosed',\n  'dateOpened',\n  'id',\n  'legal',\n  'name',\n  'publicName',\n  'readOrgs',\n  'sequential',\n  'started',\n];\n\nexport const getAssignmentsRequestBody = ({\n  adminId,\n  orgType,\n  orgId,\n  orgArray = [],\n  aggregationQuery,\n  pageLimit,\n  page,\n  paginate = true,\n  select = assignmentSelectFields,\n  filter = {},\n  orderBy = [],\n  grades = [],\n  isCollectionGroupQuery = true,\n}) => {\n  const requestBody = {\n    structuredQuery: {},\n  };\n\n  if (!aggregationQuery) {\n    if (paginate) {\n      requestBody.structuredQuery.limit = pageLimit;\n      requestBody.structuredQuery.offset = page * pageLimit;\n    }\n\n    if (select.length > 0) {\n      requestBody.structuredQuery.select = {\n        fields: select.map((field) => ({ fieldPath: field })),\n      };\n    }\n  }\n\n  requestBody.structuredQuery.from = [\n    {\n      collectionId: 'assignments',\n      allDescendants: isCollectionGroupQuery,\n    },\n  ];\n\n  if (adminId && (orgId || orgArray)) {\n    requestBody.structuredQuery.where = {\n      compositeFilter: {\n        op: 'AND',\n        filters: [\n          {\n            fieldFilter: {\n              field: { fieldPath: 'id' },\n              op: 'EQUAL',\n              value: { stringValue: adminId },\n            },\n          },\n        ],\n      },\n    };\n\n    if (!_isEmpty(orgArray)) {\n      requestBody.structuredQuery.where.compositeFilter.filters.push({\n        fieldFilter: {\n          field: {\n            fieldPath: `readOrgs.${pluralizeFirestoreCollection(orgType)}`,\n          },\n          op: 'ARRAY_CONTAINS_ANY',\n          value: {\n            arrayValue: {\n              values: [\n                orgArray.map((orgId) => {\n                  return { stringValue: orgId };\n                }),\n              ],\n            },\n          },\n        },\n      });\n    } else {\n      requestBody.structuredQuery.where.compositeFilter.filters.push({\n        fieldFilter: {\n          field: {\n            fieldPath: `readOrgs.${pluralizeFirestoreCollection(orgType)}`,\n          },\n          op: 'ARRAY_CONTAINS',\n          value: { stringValue: orgId },\n        },\n      });\n    }\n\n    if (!_isEmpty(grades)) {\n      requestBody.structuredQuery.where.compositeFilter.filters.push({\n        fieldFilter: {\n          field: { fieldPath: 'userData.grade' },\n          op: 'IN',\n          value: {\n            arrayValue: {\n              values: [\n                ...grades.map((grade) => {\n                  return { stringValue: grade };\n                }),\n              ],\n            },\n          },\n        },\n      });\n    }\n\n    if (['Completed', 'Started', 'Assigned'].includes(filter?.value)) {\n      requestBody.structuredQuery.where.compositeFilter.filters.push({\n        fieldFilter: {\n          field: { fieldPath: `progress.${filter.taskId.replace(/-/g, '_')}` },\n          op: 'EQUAL',\n          value: { stringValue: filter.value.toLowerCase() },\n        },\n      });\n    } else if (!_isEmpty(filter)) {\n      requestBody.structuredQuery.where.compositeFilter.filters.push({\n        fieldFilter: {\n          field: { fieldPath: `userData.${filter.field}` },\n          op: 'EQUAL',\n          value: { stringValue: filter.value },\n        },\n      });\n    }\n  } else {\n    const currentDate = new Date().toISOString();\n    requestBody.structuredQuery.where = {\n      fieldFilter: {\n        field: { fieldPath: 'dateClosed' },\n        op: 'GREATER_THAN_OR_EQUAL',\n        value: { timestampValue: currentDate },\n      },\n    };\n  }\n\n  if (!_isEmpty(orderBy)) {\n    requestBody.structuredQuery.orderBy = orderBy;\n  }\n\n  if (aggregationQuery) {\n    return {\n      structuredAggregationQuery: {\n        ...requestBody,\n        aggregations: [\n          {\n            alias: 'count',\n            count: {},\n          },\n        ],\n      },\n    };\n  }\n\n  return requestBody;\n};\n\nexport const getFilteredScoresRequestBody = ({\n  adminId,\n  orgId,\n  orgType,\n  orgArray,\n  filter,\n  select = ['scores', 'reliable', 'engagementFlags'],\n  aggregationQuery,\n  grades,\n  paginate = true,\n  page,\n  pageLimit,\n}) => {\n  const requestBody = {\n    structuredQuery: {},\n  };\n  if (!aggregationQuery) {\n    if (paginate) {\n      requestBody.structuredQuery.limit = pageLimit;\n      requestBody.structuredQuery.offset = page * pageLimit;\n    }\n    requestBody.structuredQuery.select = {\n      fields: select.map((field) => ({ fieldPath: field })),\n    };\n  }\n  requestBody.structuredQuery.from = [\n    {\n      collectionId: 'runs',\n      allDescendants: true,\n    },\n  ];\n  requestBody.structuredQuery.where = {\n    compositeFilter: {\n      op: 'AND',\n      filters: [\n        {\n          fieldFilter: {\n            field: { fieldPath: 'assignmentId' },\n            op: 'EQUAL',\n            value: { stringValue: adminId },\n          },\n        },\n        {\n          fieldFilter: {\n            field: { fieldPath: 'taskId' },\n            op: 'EQUAL',\n            value: { stringValue: filter.taskId },\n          },\n        },\n        {\n          fieldFilter: {\n            field: { fieldPath: 'bestRun' },\n            op: 'EQUAL',\n            value: { booleanValue: true },\n          },\n        },\n      ],\n    },\n  };\n  if (!_isEmpty(orgArray)) {\n    requestBody.structuredQuery.where.compositeFilter.filters.push({\n      fieldFilter: {\n        field: {\n          fieldPath: `readOrgs.${pluralizeFirestoreCollection(orgType)}`,\n        },\n        op: 'ARRAY_CONTAINS_ANY',\n        value: {\n          arrayValue: {\n            values: [\n              orgArray.map((orgId) => {\n                return { stringValue: orgId };\n              }),\n            ],\n          },\n        },\n      },\n    });\n  } else {\n    requestBody.structuredQuery.where.compositeFilter.filters.push({\n      fieldFilter: {\n        field: {\n          fieldPath: `readOrgs.${pluralizeFirestoreCollection(orgType)}`,\n        },\n        op: 'ARRAY_CONTAINS',\n        value: { stringValue: orgId },\n      },\n    });\n  }\n  if (filter) {\n    requestBody.structuredQuery.where.compositeFilter.filters.push({\n      compositeFilter: {\n        op: 'OR',\n        filters: [\n          {\n            compositeFilter: {\n              op: 'AND',\n              filters: [\n                {\n                  compositeFilter: {\n                    op: 'OR',\n                    filters: [\n                      {\n                        fieldFilter: {\n                          field: { fieldPath: 'userData.schoolLevel' },\n                          op: 'EQUAL',\n                          value: { stringValue: 'elementary' },\n                        },\n                      },\n                      {\n                        fieldFilter: {\n                          field: { fieldPath: 'userData.schoolLevel' },\n                          op: 'EQUAL',\n                          value: { stringValue: 'early-childhood' },\n                        },\n                      },\n                    ],\n                  },\n                },\n                // Add filter inequalities here\n                // Inequalities that match elementary school students\n              ],\n            },\n          },\n          {\n            compositeFilter: {\n              op: 'AND',\n              filters: [\n                {\n                  compositeFilter: {\n                    op: 'OR',\n                    filters: [\n                      {\n                        fieldFilter: {\n                          field: { fieldPath: 'userData.schoolLevel' },\n                          op: 'EQUAL',\n                          value: { stringValue: 'middle' },\n                        },\n                      },\n                      {\n                        fieldFilter: {\n                          field: { fieldPath: 'userData.schoolLevel' },\n                          op: 'EQUAL',\n                          value: { stringValue: 'high' },\n                        },\n                      },\n                      {\n                        fieldFilter: {\n                          field: { fieldPath: 'userData.schoolLevel' },\n                          op: 'Equal',\n                          value: { stringValue: 'postsecondary' },\n                        },\n                      },\n                    ],\n                  },\n                },\n                // Add filter inequalities here\n                // Inequalities that match middle and high school students\n              ],\n            },\n          },\n        ],\n      },\n    });\n    if (filter.value === 'Green') {\n      // If the filter requests average students, define filters in which\n      // elementary school students have the inequality percentileScore >= 50\n      requestBody.structuredQuery.where.compositeFilter.filters[4].compositeFilter.filters[0].compositeFilter.filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'GREATER_THAN_OR_EQUAL',\n            value: { doubleValue: 50 },\n          },\n        },\n      );\n      // middle/high school students have the inequality categoryScore >= upper cutoff\n      requestBody.structuredQuery.where.compositeFilter.filters[4].compositeFilter.filters[1].compositeFilter.filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'GREATER_THAN_OR_EQUAL',\n            value: { doubleValue: filter.cutoffs.above }, // For middle/high students, the same field applies but the inequality changes.\n          },\n        },\n      );\n    } else if (filter.value === 'Yellow') {\n      // If the filter requests some support students, define filters in which\n      // elementary school students have the inequality percentileScore < 50 and > 25\n      requestBody.structuredQuery.where.compositeFilter.filters[4].compositeFilter.filters[0].compositeFilter.filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'LESS_THAN',\n            value: { doubleValue: 50 },\n          },\n        },\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'GREATER_THAN',\n            value: { doubleValue: 25 },\n          },\n        },\n      );\n      // middle/high school students have the inequality categoryScore < upper cutoff and > some cutoff\n      requestBody.structuredQuery.where.compositeFilter.filters[4].compositeFilter.filters[1].compositeFilter.filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'LESS_THAN',\n            value: { doubleValue: filter.cutoffs.above }, // For middle/high students, the same field applies but the inequality changes.\n          },\n        },\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'GREATER_THAN',\n            value: { doubleValue: filter.cutoffs.some }, // For middle/high students, the same field applies but the inequality changes.\n          },\n        },\n      );\n    } else if (filter.value === 'Pink') {\n      // If the filter requests extra support students, define filters in which\n      // elementary school students have the inequality percentileScore <= 25\n      requestBody.structuredQuery.where.compositeFilter.filters[4].compositeFilter.filters[0].compositeFilter.filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'LESS_THAN_OR_EQUAL',\n            value: { doubleValue: 25 },\n          },\n        },\n      );\n      // middle/high school students have the inequality categoryScore <= some cutoff\n      requestBody.structuredQuery.where.compositeFilter.filters[4].compositeFilter.filters[1].compositeFilter.filters.push(\n        {\n          fieldFilter: {\n            field: { fieldPath: filter.field },\n            op: 'LESS_THAN_OR_EQUAL',\n            value: { doubleValue: filter.cutoffs.some }, // For middle/high students, the same field applies but the inequality changes.\n          },\n        },\n      );\n    }\n    if (!_isEmpty(grades)) {\n      requestBody.structuredQuery.where.compositeFilter.filters.push({\n        fieldFilter: {\n          field: { fieldPath: 'userData.grade' },\n          op: 'IN',\n          value: {\n            arrayValue: {\n              values: [\n                ...grades.map((grade) => {\n                  return { stringValue: grade };\n                }),\n              ],\n            },\n          },\n        },\n      });\n    }\n  }\n  if (aggregationQuery) {\n    return {\n      structuredAggregationQuery: {\n        ...requestBody,\n        aggregations: [\n          {\n            alias: 'count',\n            count: {},\n          },\n        ],\n      },\n    };\n  }\n  return requestBody;\n};\n\nexport const getScoresRequestBody = ({\n  runIds,\n  orgType,\n  orgId,\n  aggregationQuery,\n  pageLimit,\n  page,\n  paginate = true,\n  select = ['scores'],\n}) => {\n  const requestBody = {\n    structuredQuery: {},\n  };\n\n  if (!aggregationQuery) {\n    if (paginate) {\n      requestBody.structuredQuery.limit = pageLimit;\n      requestBody.structuredQuery.offset = page * pageLimit;\n    }\n\n    requestBody.structuredQuery.select = {\n      fields: select.map((field) => ({ fieldPath: field })),\n    };\n  }\n\n  requestBody.structuredQuery.from = [\n    {\n      collectionId: 'runs',\n      allDescendants: true,\n    },\n  ];\n\n  requestBody.structuredQuery.where = {\n    compositeFilter: {\n      op: 'AND',\n      filters: [\n        {\n          fieldFilter: {\n            field: { fieldPath: 'id' },\n            op: 'IN',\n            value: {\n              arrayValue: {\n                values: [\n                  runIds.map((runId) => {\n                    return { stringValue: runId };\n                  }),\n                ],\n              },\n            },\n          },\n        },\n        {\n          fieldFilter: {\n            field: {\n              fieldPath: `readOrgs.${pluralizeFirestoreCollection(orgType)}`,\n            },\n            op: 'ARRAY_CONTAINS',\n            value: { stringValue: orgId },\n          },\n        },\n      ],\n    },\n  };\n\n  if (aggregationQuery) {\n    return {\n      structuredAggregationQuery: {\n        ...requestBody,\n        aggregations: [\n          {\n            alias: 'count',\n            count: {},\n          },\n        ],\n      },\n    };\n  }\n\n  return requestBody;\n};\n\nexport const assignmentCounter = (adminId, orgType, orgId, filters = [], orderBy = []) => {\n  const adminAxiosInstance = getAxiosInstance();\n\n  // Only allow one non-org filter\n  let nonOrgFilter = null;\n  let orgFilters = null;\n  let gradeFilters = null;\n  filters.forEach((filter) => {\n    if (filter.collection === 'schools') {\n      orgFilters = filter;\n    } else if (filter.collection === 'grade') {\n      gradeFilters = filter;\n    } else if (filter.collection !== 'schools') {\n      if (nonOrgFilter) {\n        throw new Error('You may specify at most one filter');\n      } else {\n        nonOrgFilter = filter;\n      }\n    }\n  });\n  let requestBody;\n  if (nonOrgFilter && nonOrgFilter.collection === 'scores') {\n    let orgFilter = null;\n    let gradeFilter = null;\n    if (orgFilters && orgFilters.collection === 'schools' && !_isEmpty(orgFilters.value)) {\n      orgFilter = orgFilters.value;\n    }\n    if (gradeFilters && gradeFilters.collection === 'grade') {\n      gradeFilter = gradeFilters.value;\n    }\n    requestBody = getFilteredScoresRequestBody({\n      adminId: adminId,\n      orgType: orgFilter ? 'school' : orgType,\n      orgId: orgFilter ? null : orgId,\n      orgArray: orgFilter,\n      grades: gradeFilter,\n      filter: nonOrgFilter,\n      aggregationQuery: true,\n    });\n    return adminAxiosInstance.post(':runAggregationQuery', requestBody).then(({ data }) => {\n      return Number(convertValues(data[0].result?.aggregateFields?.count));\n    });\n  } else {\n    let userFilter = null;\n    let orgFilter = null;\n    let gradeFilter = null;\n    if (nonOrgFilter && nonOrgFilter.collection === 'users' && nonOrgFilter.collection === 'assignments') {\n      userFilter = nonOrgFilter;\n    }\n    if (orgFilters && orgFilters.collection === 'schools' && !_isEmpty(orgFilters.value)) {\n      orgFilter = orgFilters.value;\n    }\n    if (gradeFilters && gradeFilters.collection === 'grade') {\n      gradeFilter = gradeFilters.value;\n    }\n    const requestBody = getAssignmentsRequestBody({\n      adminId: adminId,\n      orgType: orgFilter ? 'school' : orgType,\n      orgId: orgFilter ? null : orgId,\n      orgArray: orgFilter,\n      aggregationQuery: true,\n      filter: userFilter || nonOrgFilter,\n      grades: gradeFilter,\n      orderBy: toRaw(orderBy),\n    });\n    return adminAxiosInstance.post(':runAggregationQuery', requestBody).then(({ data }) => {\n      return Number(convertValues(data[0].result?.aggregateFields?.count));\n    });\n  }\n};\n\nexport const assignmentPageFetcher = async (\n  adminId,\n  orgType,\n  orgId,\n  pageLimit,\n  page,\n  includeScores = false,\n  select = undefined,\n  paginate = true,\n  filters = [],\n  orderBy = [],\n) => {\n  const adminAxiosInstance = getAxiosInstance();\n  const adminProjectId = getProjectId();\n\n  // Only allow one non-org filter\n  let nonOrgFilter = null;\n  let orgFilters = null;\n  let gradeFilters = null;\n  filters?.forEach((filter) => {\n    if (filter.collection === 'schools') {\n      orgFilters = filter;\n    } else if (filter.collection === 'grade') {\n      gradeFilters = filter;\n    } else if (filter.collection !== 'schools') {\n      if (nonOrgFilter) {\n        throw new Error('You may specify at most one filter');\n      } else {\n        nonOrgFilter = filter;\n      }\n    }\n  });\n\n  // Handle filtering based on scores\n  if (nonOrgFilter && nonOrgFilter.collection === 'scores') {\n    let orgFilter = null;\n    let gradeFilter = null;\n    if (orgFilters && orgFilters.collection === 'schools' && !_isEmpty(orgFilters.value)) {\n      orgFilter = orgFilters.value;\n    }\n    if (gradeFilters && gradeFilters.collection === 'grade') {\n      gradeFilter = gradeFilters.value;\n    }\n    const requestBody = getFilteredScoresRequestBody({\n      adminId: adminId,\n      orgType: orgFilter ? 'school' : orgType,\n      orgId: orgFilter ? null : orgId,\n      orgArray: orgFilter,\n      filter: nonOrgFilter,\n      aggregationQuery: false,\n      grades: gradeFilter,\n      paginate: true,\n      page: page.value,\n      pageLimit: pageLimit.value,\n    });\n    console.log(\n      `Fetching page ${page.value} for ${adminId} with filter ${filters[0].value} on field ${filters[0].field}`,\n    );\n    return adminAxiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(async ({ data }) => {\n      const scoresData = mapFields(data, true);\n\n      // Generate a list of user docs paths\n      const userDocPaths = _uniq(\n        _without(\n          data.map((scoreDoc) => {\n            if (scoreDoc.document?.name) {\n              return _replace(scoreDoc.document.name.split('/runs/')[0], adminProjectId, adminProjectId);\n            } else {\n              return undefined;\n            }\n          }),\n          undefined,\n        ),\n      );\n\n      // Use a batch get to grab the user docs\n      const batchUserDocs = await adminAxiosInstance\n        .post(`${getBaseDocumentPath()}:batchGet`, {\n          documents: userDocPaths,\n          mask: { fieldPaths: userSelectFields },\n        })\n        .then(({ data }) => {\n          return _without(\n            data.map(({ found }) => {\n              if (found) {\n                return {\n                  name: found.name,\n                  userId: found.name.split('/users/')[1],\n                  data: _mapValues(found.fields, (value) => convertValues(value)),\n                };\n              }\n              return undefined;\n            }),\n            undefined,\n          );\n        });\n\n      // Generate a list of assignment doc paths\n      const assignmentDocPaths = userDocPaths.map((userDocPath) => {\n        return `${userDocPath}/assignments/${adminId}`;\n      });\n\n      // Batch get assignment docs\n      const batchAssignmentDocs = await adminAxiosInstance\n        .post(`${getBaseDocumentPath()}:batchGet`, {\n          documents: assignmentDocPaths,\n          mask: { fieldPaths: assignmentSelectFields },\n        })\n        .then(({ data }) => {\n          return _without(\n            data.map(({ found }) => {\n              if (found) {\n                return {\n                  name: found.name,\n                  userId: found.name.split('/users/')[1].split('/')[0],\n                  data: _mapValues(found.fields, (value) => convertValues(value)),\n                };\n              }\n              return undefined;\n            }),\n            undefined,\n          );\n        });\n\n      // Merge the scores into the assignment object\n      const unretrievedScores = [];\n      const initialScoredAssignments = batchAssignmentDocs.map((assignment) => {\n        const scoredAssessments = _without(\n          assignment.data.assessments.map((assessment) => {\n            const runId = assessment.runId;\n            const scoresObject = _get(_find(scoresData, { id: runId }), 'scores');\n            const reliable = _get(_find(scoresData, { id: runId }), 'reliable');\n            const engagementFlags = _get(_find(scoresData, { id: runId }), 'engagementFlags');\n            if (!scoresObject && runId) {\n              const runPath = `projects/${adminProjectId}/databases/(default)/documents/users/${assignment.userId}/runs/${runId}`;\n              unretrievedScores.push(runPath);\n            }\n            return {\n              ...assessment,\n              scores: scoresObject,\n              reliable,\n              engagementFlags,\n            };\n          }),\n          undefined,\n        );\n        return {\n          userId: assignment.userId,\n          data: {\n            ...assignment.data,\n            assessments: scoredAssessments,\n          },\n        };\n      });\n\n      // Use the list of unretrieved scores and batchGet\n      const otherScores = await adminAxiosInstance\n        .post(`${getBaseDocumentPath()}:batchGet`, {\n          documents: unretrievedScores,\n          mask: { fieldPaths: ['scores', 'reliable', 'engagementFlags'] },\n        })\n        .then(({ data }) => {\n          return _without(\n            data.map(({ found }) => {\n              if (found) {\n                return {\n                  id: found.name.split('/runs/')[1],\n                  ..._mapValues(found.fields, (value) => convertValues(value)),\n                };\n              }\n              return undefined;\n            }),\n            undefined,\n          );\n        });\n\n      // Merge the newly retrieved scores with the scoredAssignments object\n      const scoredAssignments = initialScoredAssignments.map((assignment) => {\n        const scoredAssessments = assignment.data.assessments.map((assessment) => {\n          const runId = assessment.runId;\n          const runScores = _get(_find(otherScores, { id: runId }), 'scores');\n          const reliable = _get(_find(otherScores, { id: runId }), 'reliable');\n          const engagementFlags = _get(_find(otherScores, { id: runId }), 'engagementFlags');\n          if (runScores) {\n            return {\n              ...assessment,\n              scores: runScores,\n              reliable,\n              engagementFlags,\n            };\n          } else {\n            return assessment;\n          }\n        });\n        return {\n          userId: assignment.userId,\n          data: {\n            ...assignment.data,\n            assessments: scoredAssessments,\n          },\n        };\n      });\n\n      // Integrate the assignment and scores objects\n      return _without(\n        data.map((score) => {\n          if (_get(score, 'document')) {\n            const userId = score.document.name.split('/users/')[1].split('/runs/')[0];\n            const assignmentDoc = _find(scoredAssignments, {\n              userId: userId,\n            });\n            const userDoc = _find(batchUserDocs, { userId: userId });\n            return {\n              user: {\n                ...userDoc.data,\n                userId: userDoc.userId,\n              },\n              assignment: assignmentDoc.data,\n            };\n          } else {\n            return undefined;\n          }\n        }),\n        undefined,\n      );\n    });\n  } else {\n    let userFilter = null;\n    let orgFilter = null;\n    let gradeFilter = null;\n    if (nonOrgFilter && nonOrgFilter.collection === 'users') {\n      if (nonOrgFilter.field === 'grade') {\n        gradeFilter = nonOrgFilter.value;\n      } else {\n        userFilter = nonOrgFilter;\n      }\n    }\n    if (orgFilters && orgFilters.collection === 'schools' && !_isEmpty(orgFilters.value)) {\n      orgFilter = orgFilters.value;\n    }\n    if (gradeFilters && gradeFilters.collection === 'grade') {\n      gradeFilter = gradeFilters.value;\n    }\n    const requestBody = getAssignmentsRequestBody({\n      adminId: adminId,\n      orgType: orgFilter ? 'school' : orgType,\n      orgId: orgFilter ? null : orgId,\n      orgArray: orgFilter,\n      aggregationQuery: false,\n      pageLimit: pageLimit.value,\n      page: page.value,\n      paginate: paginate,\n      select: select,\n      filter: userFilter || nonOrgFilter,\n      grades: gradeFilter,\n      orderBy: toRaw(orderBy),\n    });\n\n    console.log(`Fetching page ${page.value} for ${adminId}`);\n    return adminAxiosInstance.post(`${getBaseDocumentPath()}:runQuery`, requestBody).then(async ({ data }) => {\n      const assignmentData = mapFields(data, true);\n\n      // Get User docs\n      const userDocPaths = _uniq(\n        _without(\n          data.map((adminDoc) => {\n            if (adminDoc.document?.name) {\n              return adminDoc.document.name.split('/assignments/')[0];\n            } else {\n              return undefined;\n            }\n          }),\n          undefined,\n        ),\n      );\n\n      // Use batchGet to get all user docs with one post request\n      const batchUserDocs = await adminAxiosInstance\n        .post(`${getBaseDocumentPath()}:batchGet`, {\n          documents: userDocPaths,\n          mask: { fieldPaths: userSelectFields },\n        })\n        .then(({ data }) => {\n          return _without(\n            data.map(({ found }) => {\n              if (found) {\n                const userId = found.name.split('/users/')[1];\n                return {\n                  name: found.name,\n                  data: {\n                    ..._mapValues(found.fields, (value) => convertValues(value)),\n                    userId,\n                  },\n                };\n              }\n              return undefined;\n            }),\n            undefined,\n          );\n        });\n\n      let batchSurveyDocs = [];\n      if (isLevante) {\n        console.log('adminId: ', adminId);\n        // Batch get survey response docs\n        batchSurveyDocs = await Promise.all(\n          userDocPaths.map(async (userDocPath) => {\n            const userId = userDocPath.split('/users/')[1];\n            const surveyQuery = {\n              structuredQuery: {\n                from: [\n                  {\n                    collectionId: 'surveyResponses',\n                  },\n                ],\n                where: {\n                  fieldFilter: {\n                    field: { fieldPath: 'administrationId' },\n                    op: 'EQUAL',\n                    value: { stringValue: adminId },\n                  },\n                },\n              },\n            };\n\n            try {\n              const { data } = await adminAxiosInstance.post(\n                `${getBaseDocumentPath()}/users/${userId}:runQuery`,\n                surveyQuery,\n              );\n\n              const validResponses = data\n                .filter((doc) => doc.document)\n                .map((doc) => ({\n                  name: doc.document.name,\n                  ..._mapValues(doc.document.fields, (value) => convertValues(value)),\n                }));\n\n              return validResponses.length > 0 ? validResponses[0] : null;\n            } catch (error) {\n              console.error('Error fetching survey response: ', error);\n              return null;\n            }\n          }),\n        );\n      }\n\n      // Merge assignments, users, and survey data\n      const scoresObj = assignmentData.map((assignment, index) => {\n        const user = batchUserDocs.find((userDoc) => userDoc.name.includes(assignment.parentDoc));\n        const surveyResponse = isLevante ? batchSurveyDocs[index] : null;\n\n        let progress = 'assigned';\n        if (surveyResponse) {\n          // Check completion based on user type\n          if (user.data.userType === 'student') {\n            progress = surveyResponse.general?.isComplete ? 'completed' : 'started';\n          } else if (['parent', 'teacher'].includes(user.data.userType)) {\n            // For parent/teacher, check both general and specific parts\n            const generalComplete = surveyResponse.general?.isComplete || false;\n            const specificItems = surveyResponse?.specific || [];\n\n            if (specificItems.length > 0) {\n              const allSpecificComplete = specificItems.every((item) => item.isComplete === true);\n              // Both general and all specific items must be complete\n              progress = generalComplete && allSpecificComplete ? 'completed' : 'started';\n            } else {\n              progress = 'started';\n            }\n          }\n        }\n\n        return {\n          assignment,\n          user: user.data,\n          roarUid: user.name.split('/users/')[1],\n          ...(isLevante && {\n            survey: {\n              progress,\n              ...surveyResponse,\n            },\n          }),\n        };\n      });\n\n      if (includeScores) {\n        // Use batchGet to get all of the run docs (including their scores)\n        const runDocPaths = _flatten(\n          assignmentData.map((assignment) => {\n            const runIds = _without(\n              assignment.assessments.map((assessment) => assessment.runId),\n              undefined,\n            );\n            return runIds.map((runId) => `${getBaseDocumentPath()}/runs/${runId}`);\n          }),\n        );\n\n        const batchRunDocs = await adminAxiosInstance\n          .post(`${getBaseDocumentPath()}:batchGet`, {\n            documents: runDocPaths,\n            mask: { fieldPaths: ['scores', 'reliable', 'engagementFlags'] },\n          })\n          .then(({ data }) => {\n            return _without(\n              data.map(({ found }) => {\n                if (found) {\n                  return {\n                    name: found.name,\n                    data: _mapValues(found.fields, (value) => convertValues(value)),\n                  };\n                }\n                return undefined;\n              }),\n              undefined,\n            );\n          });\n\n        // Again the order of batchGet is not guaranteed. This time, we'd like to\n        // group the runDocs by user's roarUid, in the same order as the userDocPaths\n        const runs = _groupBy(batchRunDocs, (runDoc) => runDoc.name.split('/users/')[1].split('/runs/')[0]);\n\n        for (const score of scoresObj) {\n          const userRuns = runs[score.roarUid];\n          for (const task of score.assignment.assessments) {\n            const runId = task.runId;\n            task['scores'] = _get(\n              _find(userRuns, (runDoc) => runDoc.name.includes(runId)),\n              'data.scores',\n            );\n            task['reliable'] = _get(\n              _find(userRuns, (runDoc) => runDoc.name.includes(runId)),\n              'data.reliable',\n            );\n            task['engagementFlags'] = _get(\n              _find(userRuns, (runDoc) => runDoc.name.includes(runId)),\n              'data.engagementFlags',\n            );\n          }\n        }\n      }\n\n      return scoresObj;\n    });\n  }\n};\n\n/**\n/**\n * Fetches the assignments that are currently open for a user.\n *\n * @param {ref<String>} roarUid - A Vue ref containing the user's ROAR ID.\n * @returns {Promise<Array>} - A promise that resolves to an array of open assignments for the user.\n */\nexport const getUserAssignments = async (roarUid) => {\n  const adminAxiosInstance = getAxiosInstance();\n  const assignmentRequest = getAssignmentsRequestBody({\n    aggregationQuery: false,\n    paginate: false,\n    isCollectionGroupQuery: false,\n  });\n  const userId = toValue(roarUid);\n  return await adminAxiosInstance\n    .post(`${getBaseDocumentPath()}/users/${userId}:runQuery`, assignmentRequest)\n    .then(async ({ data }) => {\n      const assignmentData = mapFields(data);\n      const openAssignments = assignmentData.filter((assignment) => new Date(assignment.dateOpened) <= new Date());\n      return openAssignments;\n    });\n};\n\nexport const assignmentFetchAll = async (adminId, orgType, orgId, includeScores = false) => {\n  return await assignmentPageFetcher(\n    adminId,\n    orgType,\n    orgId,\n    { value: 2 ** 31 - 1 },\n    { value: 0 },\n    includeScores,\n    true,\n    true,\n  );\n};\n"],"names":["toString","require$$0","replace","args","string","replace_1","userSelectFields","assignmentSelectFields","getAssignmentsRequestBody","adminId","orgType","orgId","orgArray","aggregationQuery","pageLimit","page","paginate","select","filter","orderBy","grades","isCollectionGroupQuery","requestBody","field","_isEmpty","pluralizeFirestoreCollection","grade","currentDate","getFilteredScoresRequestBody","assignmentPageFetcher","includeScores","filters","adminAxiosInstance","getAxiosInstance","adminProjectId","getProjectId","nonOrgFilter","orgFilters","gradeFilters","orgFilter","gradeFilter","getBaseDocumentPath","data","scoresData","mapFields","userDocPaths","_uniq","_without","scoreDoc","_a","_replace","batchUserDocs","found","_mapValues","value","convertValues","assignmentDocPaths","userDocPath","batchAssignmentDocs","unretrievedScores","initialScoredAssignments","assignment","scoredAssessments","assessment","runId","scoresObject","_get","_find","reliable","engagementFlags","runPath","otherScores","scoredAssignments","runScores","score","userId","assignmentDoc","userDoc","userFilter","toRaw","assignmentData","adminDoc","batchSurveyDocs","surveyQuery","validResponses","doc","error","scoresObj","index","user","surveyResponse","progress","generalComplete","_b","specificItems","allSpecificComplete","item","runDocPaths","_flatten","batchRunDocs","runs","_groupBy","runDoc","userRuns","task","getUserAssignments","roarUid","assignmentRequest","toValue","assignmentFetchAll"],"mappings":"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","x_google_ignoreList":[0]}