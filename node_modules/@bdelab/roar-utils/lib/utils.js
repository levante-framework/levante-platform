function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/* eslint-disable no-underscore-dangle */
import path from 'path-browserify';
import mime from 'mime-types';
import { deviceType, primaryInput } from 'detect-it';

// converts a string to camel case
export function camelize(string) {
  return string.replace(/^([A-Z])|[\s-_](\w)/g, function (_0, p1, p2, _1) {
    if (p2) return p2.toUpperCase();
    return p1.toLowerCase();
  });
}

// get an object where the key is camelize(filename) and the value is the filename
export function camelizeFiles(files) {
  var obj = {};
  var _iterator = _createForOfIteratorHelper(files),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var filePath = _step.value;
      var fileName = path.parse(filePath).name;
      obj[camelize(fileName)] = filePath;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return obj;
}

/*
Plays the correct audio based on user response.
If user response does not matter, it will play a neutral feedback audio.
Takes in 3 parameters:
- responseIsCorrect (boolean || null): if the user's response was correct/incorrect
OR null if it does matter, ex. true OR null
- correct/neutral audio (string): path to the audio file, ex. "http://localhost:8080/audio/feedbackAudio.mp3"
- incorrect audio (string): path to the audio file
*/

/*
Examples of the function can be called

playFeedbackAudio(true, 'correct.mp3', 'incorrect.mp3')
playFeedbackAudio(null, 'neutral.mp3',)
*/

export function playFeedbackAudio(responseIsCorrect, audio1, audio2) {
  var audioToPlay;
  if (responseIsCorrect || responseIsCorrect === null) {
    audioToPlay = audio1;
  } else {
    audioToPlay = audio2;
  }
  new Audio(audioToPlay).play();
}

// Gets the app language based on the lng query string. Using this because ROAR apps use i18next.
export function getLanguage(setLanguage) {
  if (setLanguage) return setLanguage;
  var urlParams = new URLSearchParams(window.location.search);
  return urlParams.get('lng') || 'en';
}

// Gets the device type based on the device inputs
export function getDevice() {
  if (deviceType === 'touchOnly' || deviceType === 'hybrid' && primaryInput === 'touch') {
    return 'mobile';
  }
  return 'desktop';
}

// Returns device-level information of user through the browser window object.
export function getDeviceInfo() {
  var width = window.innerWidth;
  var height = window.innerHeight;
  var language = window.navigator.language;
  var userAgent = window.navigator.userAgent;
  var userAgentData = window.navigator.userAgentData;
  return {
    screen: {
      width: width,
      height: height
    },
    language: language,
    userAgent: userAgent,
    platform: userAgentData.platform,
    mobile: userAgentData.mobile,
    engine: userAgentData.brands[0].brand,
    engineVersion: userAgentData.brands[0].version,
    browser: userAgentData.brands[1].brand,
    browserVersion: userAgentData.brands[1].version
  };
}

/**
 * Returns the formatted URL based on different conditions for asset type,
 * nesting and default values.
 *
 * @param {string} bucketURI - The bucket URI where the assets are stored.
 * Ex. 'https://storage.googleapis.com/${bucketName}
 * @param {string} filePath - The file path of the asset.
 * @param {string} lng - The language identifier as a ISO 639-1 code. Ex. 'en' for English
 * @param {string} device - The device identifier.
 * @param {string} type - The type of asset category. Can be one of the following:
 * 'device', 'shared', 'shared/device', 'languageSpecific', 'default'.
 * @param {boolean} nested - Indicates if the asset is nested in language specific data.
 *  Default is false.
 * @param {boolean} isDefault - Indicates if the asset is from default data. Default is false.
 * @returns {string} The formatted URL based on the given conditions.
 * Ex. 'https://storage.googleapis.com/${bucketName}/${lng}/${device}/${file}'
 */

export function getFormattedURL(bucketURI, filePath, lng, device, type, nested, isDefault) {
  if (isDefault && nested && type === 'device' || nested && type === 'device') {
    return "".concat(bucketURI, "/").concat(lng, "/").concat(device, "/").concat(filePath);
  }
  if (isDefault && nested && type === 'shared' || nested && type === 'shared') {
    return "".concat(bucketURI, "/").concat(lng, "/shared/").concat(filePath);
  }
  if (type === 'device') {
    return "".concat(bucketURI, "/").concat(device, "/").concat(filePath);
  }
  if (type === 'shared/device') {
    return "".concat(bucketURI, "/shared/").concat(device, "/").concat(filePath);
  }
  if (type === 'languageSpecific') {
    return "".concat(bucketURI, "/").concat(lng, "/").concat(filePath);
  }
  if (type === 'default') {
    return "".concat(bucketURI, "/").concat(filePath);
  }
  return "".concat(bucketURI, "/shared/").concat(filePath);
}
export function getAssetType(asset) {
  var mimeType = mime.lookup(asset);
  if (!mimeType) {
    throw new Error("Unrecognized file extension in path: ".concat(asset));
  }
  if (mimeType.startsWith('image/')) return 'images';
  if (mimeType.startsWith('audio/')) return 'audio';
  if (mimeType.startsWith('video/')) return 'video';
  throw new Error("Unsupported MIME type for file: ".concat(asset, ". Only image, audio, and video files are supported."));
}

/**
 * Calculates and returns age data based on the provided birth month, birth year,
 * age, and age in months.
 *
 * @function getAgeData
 *
 * @param {string|number|null} birthMonth - The month of birth (1-12).
 * If not provided, it will be calculated based on other parameters.
 * @param {string|number|null} birthYear - The year of birth.
 * If not provided, it will be calculated based on other parameters.
 * @param {string|number|null} age - The age in years.
 * If not provided, it will be calculated based on other parameters.
 * @param {string|number|null} ageMonths - The age in months.
 * If not provided, it will be calculated based on other parameters.
 *
 * @returns {Object} ageData - The calculated age data.
 * @returns {number|null} ageData.age - The calculated age in years.
 * @returns {number|null} ageData.ageMonths - The calculated age in months.
 * @returns {number|null} ageData.birthMonth - The calculated or provided month of birth.
 * @returns {number|null} ageData.birthYear - The calculated or provided year of birth.
 */

export var getAgeData = function getAgeData(birthMonth, birthYear, age, ageMonths) {
  // milliseconds per year (accounting for leap years)
  var msPerYear = 1000 * 60 * 60 * 24 * 365.25;
  var currDate = new Date();
  var safeNumber = function safeNumber(value) {
    var numValue = Number(value);
    return Object.is(numValue, NaN) || numValue === 0 ? null : numValue;
  };
  var bm = safeNumber(birthMonth);
  var by = safeNumber(birthYear);
  var yearsOld = safeNumber(age);
  var ageM = safeNumber(ageMonths);
  var ageData = {
    age: yearsOld,
    ageMonths: ageM
  };
  if (bm && by) {
    ageData.birthMonth = bm;
    ageData.birthYear = by;
    var birthDate = new Date(by, bm - 1, currDate.getDate());
    var decimalYear = (currDate - birthDate) / msPerYear;
    ageData.age = Math.floor(decimalYear);
    ageData.ageMonths = ageM || Math.floor(decimalYear * 12);
  } else if (by) {
    ageData.birthYear = by;
    ageData.birthMonth = currDate.getMonth() + 1;
    var _birthDate = new Date(by, ageData.birthMonth - 1, currDate.getDate());
    var _decimalYear = (currDate - _birthDate) / msPerYear;
    ageData.age = Math.floor(_decimalYear);
    ageData.ageMonths = ageM || Math.floor(_decimalYear * 12);
  } else if (ageM) {
    var _birthDate2 = new Date();
    _birthDate2.setMonth(_birthDate2.getMonth() - ageM);
    ageData.birthYear = _birthDate2.getFullYear();
    ageData.birthMonth = _birthDate2.getMonth() + 1;
    ageData.age = Math.floor((currDate - _birthDate2) / msPerYear);
  } else if (yearsOld) {
    ageData.birthYear = currDate.getFullYear() - yearsOld;
    ageData.birthMonth = currDate.getMonth() + 1;
    ageData.ageMonths = yearsOld * 12;
  } else {
    ageData.birthMonth = null;
    ageData.birthYear = null;
  }
  return ageData;
};

/**
 * Return grade after min/max filtering and accounting for string values.
 *
 * @function getGrade
 *
 * @param {string|number|null} inputGrade - The input grade.
 * @param {number} gradeMin - The minimum grade. Default is 0 (for Kindergarten).
 * @param {number} gradeMax - The maximum grade. Default is 12.
 *
 * @returns {number} numeric grade
 */
export var getGrade = function getGrade(inputGrade) {
  var gradeMin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var gradeMax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 13;
  var parsedGrade = Number(inputGrade);
  var gradeStringMap = {
    k: 0,
    tk: 0,
    pk: 0,
    preschool: 0,
    prekindergarten: 0,
    transitionalkindergarten: 0,
    kindergarten: 0,
    infanttoddler: 0,
    infant: 0,
    toddler: 0,
    first: 1,
    firstgrade: 1,
    second: 2,
    secondgrade: 2,
    third: 3,
    thirdgrade: 3,
    fourth: 4,
    fourthgrade: 4,
    fifth: 5,
    fifthgrade: 5,
    sixth: 6,
    sixthgrade: 6,
    seventh: 7,
    seventhgrade: 7,
    eighth: 8,
    eighthgrade: 8,
    ninth: 9,
    ninthgrade: 9,
    tenth: 10,
    tenthgrade: 10,
    eleventh: 11,
    eleventhgrade: 11,
    twelfth: 12,
    twelfthgrade: 12,
    freshman: 9,
    sophomore: 10,
    junior: 11,
    senior: 12,
    postgraduate: 13,
    university: 13,
    graduate: 13,
    master: 13,
    doctorate: 13,
    masters: 13
  };

  // if inputGrade is null or undefined, return undefined to avoid an error with undefined.toLowerCase()
  if (inputGrade === null || inputGrade === undefined) {
    return undefined;
  }
  if (Number.isNaN(parsedGrade)) {
    // Grade is a string. Remove any whitespace and hyphens. Make lowercase.
    // And refer to the gradeStringMap for the mapping.
    var spaceRegex = /\s/g;
    var hyphenRegex = /-/g;
    var standardizedGradeString = inputGrade.toLowerCase().replace(spaceRegex, '').replace(hyphenRegex, '');
    var grade = gradeStringMap[standardizedGradeString];
    if (grade === undefined) return undefined;
    if (grade < gradeMin) return gradeMin;
    if (grade > gradeMax) return gradeMax;
    return grade;
  }
  if (parsedGrade < gradeMin) {
    return gradeMin;
  }
  if (parsedGrade > gradeMax) {
    return gradeMax;
  }

  // grade is within range and is a number
  return parsedGrade;
};

/**
 * Return grade after min/max filtering and accounting for string values.
 *
 * @const median
 *
 * @param {array} array - Array of response times.
 *
 * @returns {number} median of array of response times
 */
export var median = function median(array) {
  array.sort(function (a, b) {
    return b - a;
  });
  var length = array.length;
  if (length % 2 === 0) {
    return (array[length / 2] + array[length / 2 - 1]) / 2;
  }
  return array[Math.floor(length / 2)];
};

/**
 * Returns a function that evaluates the reliability of a run based on the following criteria:
 *
 * @param {number} responseTimeLowThreshold - The minimum acceptable response time threshold in MS.
 * @param {number} responseTimeHighThreshold - The maximum acceptable response time threshold in MS.
 * @param {number} accuracyThreshold - The minimum acceptable accuracy threshold.
 * @param {array} includedReliabilityFlags - An array of flags that should be included
 * when evaluating reliability.
 * @returns {function} baseValidityEvaluator - A function that evaluates the reliability of a run.
 */
export function createEvaluateValidity(_ref) {
  var _ref$responseTimeLowT = _ref.responseTimeLowThreshold,
    responseTimeLowThreshold = _ref$responseTimeLowT === void 0 ? 400 : _ref$responseTimeLowT,
    _ref$responseTimeHigh = _ref.responseTimeHighThreshold,
    responseTimeHighThreshold = _ref$responseTimeHigh === void 0 ? 10000 : _ref$responseTimeHigh,
    _ref$accuracyThreshol = _ref.accuracyThreshold,
    accuracyThreshold = _ref$accuracyThreshol === void 0 ? 0.2 : _ref$accuracyThreshol,
    _ref$minResponsesRequ = _ref.minResponsesRequired,
    minResponsesRequired = _ref$minResponsesRequ === void 0 ? 0 : _ref$minResponsesRequ,
    _ref$includedReliabil = _ref.includedReliabilityFlags,
    includedReliabilityFlags = _ref$includedReliabil === void 0 ? ['responseTimeTooFast'] : _ref$includedReliabil;
  return function baseEvaluateValidity(_ref2) {
    var responseTimes = _ref2.responseTimes,
      responses = _ref2.responses,
      correct = _ref2.correct,
      completed = _ref2.completed;
    var flags = [];
    var isReliable = false;
    if (responseTimes.length < minResponsesRequired) {
      flags.push('notEnoughResponses');
    } else {
      var _correct$filter$lengt;
      // verifies if responseTimes lie above or below a threshold
      if (median(responseTimes) <= responseTimeLowThreshold) {
        flags.push('responseTimeTooFast');
      }
      if (median(responseTimes) >= responseTimeHighThreshold) {
        flags.push('responseTimeTooSlow');
      }
      if (completed === false && includedReliabilityFlags.includes('incomplete')) {
        flags.push('incomplete');
      }

      // TODO: Calculate response similarity based on maxChainLength

      // Calculate accuracy based on the number of correct responses
      var numCorrect = (_correct$filter$lengt = correct === null || correct === void 0 ? void 0 : correct.filter(function (x) {
        return x === 1;
      }).length) !== null && _correct$filter$lengt !== void 0 ? _correct$filter$lengt : 0;
      if (numCorrect / correct.length <= accuracyThreshold) {
        flags.push('accuracyTooLow');
      }
      isReliable = flags.filter(function (x) {
        return includedReliabilityFlags.includes(x);
      }).length === 0;
      flags = flags.filter(function (x) {
        return includedReliabilityFlags.includes(x);
      });
    }
    return {
      flags: flags,
      isReliable: isReliable
    };
  };
}

/**
 * Tracks response times and invokes callback function when response times
 * exceed specified thresholds.
 *
 * @class ResponseTimeTracker
 * @param {Function} evaluateValidity function to be called to generate an decision on the
 *    reliability of a run
 * @param {Function} addEngagementFlags function passed through to update the run's
 *  firekit object with flags tripped
 * @param {number} minResponsesRequired The minimum number of responses required before
 *   checking for threshold exceedance.
 * @property {Array<number>} _responseTimes An array to store the response times.
 * @property {Array<number>} _responses An array to store the responses
 * (keypresses or button choices).
 * @property {Array<number>} _correct An array to store the correctness of the responses.
 */
export var ValidityEvaluator = /*#__PURE__*/function () {
  function ValidityEvaluator(_ref3) {
    var _ref3$evaluateValidit = _ref3.evaluateValidity,
      evaluateValidity = _ref3$evaluateValidit === void 0 ? createEvaluateValidity() : _ref3$evaluateValidit,
      _ref3$handleEngagemen = _ref3.handleEngagementFlags,
      handleEngagementFlags = _ref3$handleEngagemen === void 0 ? function () {} : _ref3$handleEngagemen;
    _classCallCheck(this, ValidityEvaluator);
    this.evaluateValidity = evaluateValidity;
    this.handleEngagementFlags = handleEngagementFlags;
    this._responseTimes = [];
    this._responses = [];
    this._correct = [];
    this._preserveFlags = [];
    this.currentBlock = undefined;
    this.reliabilityByBlock = {};
    this.completed = false;
  }

  /**
   * Takes in array of flags and returns array of flags with current block appended to each flag
   * @function appendCurrentBlockToFlags
   * @param {Array<string>} flags
   */
  _createClass(ValidityEvaluator, [{
    key: "appendCurrentBlockToFlags",
    value: function appendCurrentBlockToFlags(flags) {
      var _this = this;
      if (this.currentBlock !== undefined) {
        // We only want to append for block based flags, incomplete would be a global flag
        return flags.map(function (flag) {
          return flag !== 'incomplete' ? "".concat(flag, "_").concat(_this.currentBlock) : flag;
        });
      }
      return flags;
    }

    /**
     * Returns true if all blocks so far are reliable, false if not
     * @function calculateReliabilityWithBlocks
     */
  }, {
    key: "calculateReliabilityWithBlocks",
    value: function calculateReliabilityWithBlocks() {
      return Object.values(this.reliabilityByBlock).every(function (x) {
        return x === true;
      });
    }

    /**
     *  @function startNewBlockValidation Called when a new block is started to reset the
     * data arrays and update the evaluateValidity function if needed
     * For block-scoped assessments, this function must be called with the first block name
     * before beginning the first block
     * @param {Function} evaluateValidity
     * @param {String} currentBlock The name of the current block
     */
  }, {
    key: "startNewBlockValidation",
    value: function startNewBlockValidation(currentBlock) {
      var evaluateValidity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.evaluateValidity;
      // Compute and store flags from the previous block
      // The first conditional prevents a tooFewResponses flag from being
      // stored erroneously before the initial block begins
      if (this._responseTimes.length > 0 && currentBlock !== undefined) {
        var flags = this.calculateAndUpdateFlags();
        // Update new flags to preserveFlags array
        this._preserveFlags = [].concat(_toConsumableArray(this._preserveFlags), _toConsumableArray(this.appendCurrentBlockToFlags(flags)));
      }
      this.currentBlock = currentBlock;
      this.evaluateValidity = evaluateValidity;
      this._responseTimes = [];
      this._responses = [];
      this._correct = [];
      this.completed = false;
    }

    /**
     *  @function markAsCompleted Called when a block or task is completed.
     * For block-scoped assessments, this function must be called at the completion
     * of each block
     * */
  }, {
    key: "markAsCompleted",
    value: function markAsCompleted() {
      this.completed = true;
      this.calculateAndUpdateFlags();
    }

    /**
     *  @function calculateAndUpdateFlags Helper function to calculate flag and reliability
     * and use the handleEngagementFlags function to update the run's firekit object
     * @return {Array<string>} flags
     * */
  }, {
    key: "calculateAndUpdateFlags",
    value: function calculateAndUpdateFlags() {
      var _this$evaluateValidit = this.evaluateValidity({
          responseTimes: this._responseTimes,
          responses: this._responses,
          correct: this._correct,
          completed: this.completed
        }),
        flags = _this$evaluateValidit.flags,
        isReliable = _this$evaluateValidit.isReliable;

      // Case for block based assessments
      if (this.currentBlock !== undefined) {
        this.reliabilityByBlock[this.currentBlock] = isReliable;

        // Please note that calling this function with a new set of engagement flags
        // will overwrite the previous set.
        this.handleEngagementFlags([].concat(_toConsumableArray(this._preserveFlags), _toConsumableArray(this.appendCurrentBlockToFlags(flags))), this.calculateReliabilityWithBlocks(), this.reliabilityByBlock);
      } else {
        // Please note that calling this function with a new set of engagement flags
        // will overwrite the previous set.
        this.handleEngagementFlags(flags, isReliable);
      }
      return flags;
    }

    /**
     * Updates ValidityEvaluator arrays (responseTimes, response, and accuracy) with
     *
     * @function addResponseData
     * @param {number} responseTime Time it took for a user to respond to a stimulus
     * @param {string} response  Choice that a user responded with
     * ex: left_arrow, right_arrow, button_3
     * @param {number} isCorrect 1 if a user answered correctly, 0 if answered incorrectly
     */
  }, {
    key: "addResponseData",
    value: function addResponseData(responseTime, response, isCorrect) {
      this._responseTimes.push(responseTime);
      this._responses.push(response);
      this._correct.push(isCorrect);
      this.calculateAndUpdateFlags();
    }
  }]);
  return ValidityEvaluator;
}();